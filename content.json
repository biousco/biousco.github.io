{"meta":{"title":"Biousco's Blog","subtitle":"Biousco","description":"Biousco's Blog","author":"Biousco","url":"http://weibo.com/biousco"},"pages":[{"title":"关于我","date":"2015-01-04T11:21:06.000Z","updated":"2016-08-02T08:02:31.256Z","comments":true,"path":"about/index.html","permalink":"http://weibo.com/biousco/about/index.html","excerpt":"","text":"你好。我叫林浩笙。目前在广东外语外贸大学，2013年入读，计算机专业。平时非常安静，话比较少。和兴趣对的人比较能聊得来。上了大学加入了学校的管乐团，学习的乐器是Baritone（上低音号），你也可以叫他Euphonium（次中音号）。认识了很多朋友，以后工作有机会还想参加乐团。专业方面，之前对设计有兴趣，后来发现还是敲敲代码比较适合我。目前在学习前端知识和后台知识。参加了学校的一个社团，比赛的时候一个人把前端和后台的部分都做了，设计也涉及了一部分。用的比较特别的东西是Bootstrap,Thinkphp。几个月后看这些东西也觉得没什么特别的了，不过相信以后会学得更好。想去互联网大公司，认识牛B的人，学到新技术，往深的地方学习。玩音乐游戏OSU，LOL，单机动作类什么的，看新番，没事就刷刷微博看看知乎自己做点小东西。搭建这个网站好像学了不少东西。最开始是用Linux，然后发现期末考了，刷题库的时候无聊了就搞搞其他的东西，接触了Node.js，然后发现有Hexo这个东西。一步一步学，什么Markdown，Github也入门了一点点。"},{"title":"categories","date":"2016-08-02T08:01:57.762Z","updated":"2015-01-05T08:05:29.000Z","comments":true,"path":"categories/index.html","permalink":"http://weibo.com/biousco/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-08-02T08:01:57.764Z","updated":"2015-01-05T03:04:01.000Z","comments":true,"path":"tags/index.html","permalink":"http://weibo.com/biousco/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实习招聘面试经历-4","slug":"实习招聘面试经历-4","date":"2016-08-02T05:33:07.000Z","updated":"2016-08-02T07:49:05.968Z","comments":true,"path":"2016/08/02/实习招聘面试经历-4/","link":"","permalink":"http://weibo.com/biousco/2016/08/02/实习招聘面试经历-4/","excerpt":"","text":"（啪啪啪，之前写完文章写了一半不知怎么就忘记继续发=。= 现在是8/2，文章大概是一个多月前写的）终于到最后一篇啦。虽然技术面试早就结束了，不过还是前个星期接到最后一家的Hr的电话，因为已经确定去哪一家了所以就拒绝了。至此所有的面试都结束啦~结果还是挺不错的。 总结一下最后一家的面试，电面，周日早上10点开始，每轮40分钟左右，最后一面出了点意外花了一个多小时。隔一个小时左右下一轮，2点半结束所有技术面。效率太高啦，而且面试官很nice，赞。 一面 - 基础 &amp; 广度 声音比较小而且有点杂，下次应该和面试官说提高一下音量，不然一些问题都听不清楚。 自我介绍，学习前端中遇到的一些比较困难的问题，收获最多的是什么印象中还是很多面试官都会问我这个问题，但是说实话，当时觉得难的然后解决了的现在肯定不难了，那些难的没解决的说出来又觉得不好（没有去解决问题），之前面试的时候提过在移动端图片的上传的处理，其实主要是比较绕，而且有兼容问题，涉及到一些dataUrl，canvas和formdata的转换，说实话也不怎么难，但是因为时间久了，大半年前的东西细节基本忘记了，说出来反而容易被面试官问倒，所以说了一次就不想再说了。然后就讲了移动端的PC端的区别，就是和之前说的差不多。 css的优先级排序 em和rem的区别 盒模型是什么重构方面的问题，优先级排序其实有点不清楚几个嵌套时的优先级，笔试题的时候遇到了，靠猜。基本的优先级：!important &gt; 内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity不知道一些文章看到的每个选择器的权重是哪里看来的=。=当时没有讲出现的位置和嵌套的影响 url输入到看到内容发生了什么 dns查找的过程这里有太多东西可以讲了，不过当时刚好复习了DNS查找，就着重讲了这部分。然后就是基本的一个网页请求的过程，没有太深入各个部分比如网络层TCP/IP，服务器怎么拿到请求的资源然后返回，页面渲染的过程。面试官说能讲多少讲多少，但是当时有点紧张就讲的不是很多了。DNS查找就包括递归查找和迭代查找啦。 模块化AMD和CMD的区别都是异步加载，但是在加载顺序上有区别。（错了）AMD：Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范，RequireJS支持；CMD：Common Module Definition 通用模块定义。Seajs。最明显的区别就是在模块定义时对依赖的处理不同AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块CMD推崇就近依赖，只有在用到某个模块的时候再去requireAMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同后面看了文章发现说错了，准确的说是执行时机不同。https://www.zhihu.com/question/20351507现在都用webpack和ES6了 jquery事件中bind，live，delegate的区别当时说了事件的原理，三个阶段，为什么会用live。但是不知道live和delegate的区别。http://kb.cnblogs.com/page/94469/文章说的挺清楚了，live是需要监听的元素进行调用，然后jquery会将事件绑定到document节点上，根据事件类型和选择器进行触发事件delegate是容器元素进行调用，就和on一样啦，不过参数顺序有区别。 123 $('a').live('click', function() &#123; alert(\"That tickles!\") &#125;);$('#container').delegate('a', 'click', function() &#123; alert(\"That tickles!\") &#125;);$('#container').on('click', 'a', function () &#123; alert(\"That tickles!\")&#125;); live比delegate好，live需要包装一个元素后，调用live时才绑定事件到document上；delegate直接找到容器元素。虽然现在都是用on来做了。 MVC是什么，M,V,C之间相互怎么通信刚开始是面试官问我一个例子：新浪微博，发布微博和展示微博，怎么做到各个模块的解耦。刚开始没有提示MVC，自己有一点点MVC的思想，但是说的有点乱，估计面试官不满意，然后就让我说MVC，说完噼里啪啦一顿后让我再复述一遍。就比较清晰了（说MVC的时候自己在纸上做了笔记）。面试官太Nice啦！ cookie Session localstorage区别和用途都是存储。说完区别后问我另一个场景：使用localstorage缓存js文件，简述方案解决缓存和更新的问题 跨域的解决方案，页面的一些优化方案，webview和html之前怎么相互通信，HTTP协议，get和post的区别，几个常用的状态码 给两个具体场景说方案：1. 使用localstorage缓存js文件，简述方案解决缓存和更新的问题 2. 就是上面说的新浪的例子 二面 - 深入 简历写了angular：双向绑定的原理。angular适合用在什么场景，用一个例子说明jq和ng的实现的过程和不同点，我用了购物车的例子，然后问为什么需要双向绑定，有什么好处，有什么缺点，怎么解决。 还是根据简历：前端数据渲染方案，jq，模板引擎，MVVM，这三种方案的具体实现过程，各自的优势和劣势，分别适合用在什么场景 HTTP协议，盒模型是什么，float和absolute的区别，三种方案说水平垂直居中。 数组去重怎么做，多维数组呢 一个需求：图片可以拖动，当拖动释放的时候根据释放的速度计算图片继续滑动的速度（释放的一瞬间越快，图片继续划得越远），说方案 三面 - 大方向 为什么学习前端，学了一年都是怎么学的。读了什么书，上什么论坛，从哪些渠道获取知识。 作为一名学生和作为一名实习生，对一个产品的看法，了解，完成的过程中要怎么做。 技术问了3个开放问题 pc和mobile的适配 前端性能优化 前端安全。根据我说的简单深入。为什么要用雪碧图，为什么要减少请求数 实习时间安排，介绍了部门，有没有什么问题想问他。感觉三面基本都差不多","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://weibo.com/biousco/tags/面试/"},{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/tags/前端/"}]},{"title":"实习招聘面试经历-3","slug":"实习招聘面试经历-3","date":"2016-04-05T07:46:48.000Z","updated":"2016-08-02T07:50:25.642Z","comments":true,"path":"2016/04/05/实习招聘面试经历-3/","link":"","permalink":"http://weibo.com/biousco/2016/04/05/实习招聘面试经历-3/","excerpt":"1.跨域 讲jsonp的原理,实现 jsonp的安全性:当时自己说的是可不可以判断来源,比如请求头,域名.然后面试官说jsonp是get请求,没有origin的.我又猜测用reffer? 嗯,这个对了;我还猜测是不是用cookie和session.但是直接的script请求是不能带上这个的.面试官让我再想,我就猜可不可以传多一个验证的字段验证身份.对了.后面自己看书发现了这种方法就是token.记录如下:先介绍CSRF: 跨站请求伪造，cross site requrest forgery.意思是跨域发出请求，请求是身份认证后的（除了referer不一样，cookie是一样的）原理: 受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。cookie发送:如果是内存cookie,都可以正常发送,如果是本地cookie,需要带有p3p属性.get请求可以通过img等标签,post请求直接通过form表单提交. CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！","text":"1.跨域 讲jsonp的原理,实现 jsonp的安全性:当时自己说的是可不可以判断来源,比如请求头,域名.然后面试官说jsonp是get请求,没有origin的.我又猜测用reffer? 嗯,这个对了;我还猜测是不是用cookie和session.但是直接的script请求是不能带上这个的.面试官让我再想,我就猜可不可以传多一个验证的字段验证身份.对了.后面自己看书发现了这种方法就是token.记录如下:先介绍CSRF: 跨站请求伪造，cross site requrest forgery.意思是跨域发出请求，请求是身份认证后的（除了referer不一样，cookie是一样的）原理: 受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。cookie发送:如果是内存cookie,都可以正常发送,如果是本地cookie,需要带有p3p属性.get请求可以通过img等标签,post请求直接通过form表单提交. CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 防御： Cookie Hashing, 所有表单中包含同一个伪随机值,表单提交的时候提交这个cookie(加密后)进行验证 用验证码,能完全解决,但是用户体验不好 One-Time Token, 不同的表单包含一个不同的伪随机值. 服务端给一个token,token可能包含时间戳,用户名id,随机字符串 限制Session Cookie的生命周期 检查Referer 对于jsonp,过滤callback函数名,按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。 参考: 浅谈CSRF攻击方式 跨域有没有额外的请求? 当时说没有=.= 后来想到又OPTIONS,自己确实遇到过的.OPTIONS的用途:1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。 跨域的话,有没有遇到传cookie的问题?没有=.= 怎么解决?查了一下资料,大概是这几种: 在后端提供一个获取其他域名下的所有cookie的接口,前端拿到cookie直接设置/或者后台返回设置cookie的js代码,前端jsonp加载 通过script发起一个请求,请求一个后端接口,发送一个加密的key,服务端验证key的合法性,在接口返回中写入登陆成功的cookie sohu的解决方法: 在登陆域名passport.sohu.com下登陆,通过隐藏的iframe提交登陆,返回内容写入成功登陆的cookie,此时cookie只有passport,然后前端通过登陆成功的标志操作iframe请求,带上cookie.后端检查到成功登陆的cookie后返回一段发起多个登陆请求的html片段; 这段html会请求一个加密后的17173的登陆url,这个链接就包含2中讲的key了,后面就和2一样. 在IE中,需要在响应内容的头部加入P3P. 其实当时如果不太紧张应该是可以想出来的=.= 当时说自己没遇到不会.参考: 实现跨域cookie共享(转载) 移动端相关 tap的实现原理,解决什么问题(300ms是系统为了检测是不是双击) 一个元素保留了tap事件和click事件,怎么阻止click事件的触发参考StackOverlow: Prevent click event after handling jQuery Mobile tap event on iOS12345$('elementsSetThatCanBeTapped').on('tap', function(e) &#123; e.preventDefault(); e.stopPropagation(); $(this).off('click');&#125;) 看起来是解除了click事件,阻止默认行为和冒泡.我试试看..嗯试了一下真的可以.但是如果可以,不要绑定click事件就好了吧…上面差不多就是这么做了.不过如果有事件委托那不太一样.果然面试的时候脑子不顶用啊哈哈. 阻止事件冒泡/默认事件怎么做 XSS问我还有没有了解其他前端安全.说了XSS.Cross Site Scripting.跨站脚本.然而重点不在跨站上.发生在目标网站中目标用户的浏览器层面上,当用户浏览器渲染整个HTML文档的过程中出现了不被预期的脚本指令并执行时,XSS发生了.跨站是因为一般攻击都是获取第三方的脚本资源(script请求).分为三种:反射型,存储型,DOMXSS 反射型: XSS代码在url中作为输入提交到服务端,服务端解析后响应并在响应内容中出现这段xss代码,浏览器执行.(get,跳转) 存储型: XSS代码存在服务端,比如留言板 DOMXSS: 通过各种输入点/输出点进行攻击(输入:document.cookie/location/url),(输出:docuemnt.write/window.open…) 防御措施: 不要在页面中插入任何不可信数据，除非这些数已经进行了编码 在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码.编码的有6个: (当时蒙对了4个=.=)123456&amp; --&gt; &amp;amp;&lt; --&gt; &amp;lt;&gt; --&gt; &amp;gt;&quot; --&gt; &amp;quot;&apos; --&gt; &amp;#x27;/ --&gt; &amp;#x2F; 不推荐将单引号( ‘ )编码为 &apos; 因为它并不是标准的HTML标签需要对斜杠号( / )编码，因为在进行XSS攻击时，斜杠号对于关闭当前HTML标签非常有用 在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码属性一定用引号,属性里的引号就进行编码 在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码 在将不可信数据插入到Style属性里时，对这些数据进行CSS编码 在将不可信数据插入到HTML URL里时，对这些数据进行URL编码 参考: 防御 XSS 的七条原则","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://weibo.com/biousco/tags/面试/"},{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/tags/前端/"}]},{"title":"实习招聘面试经历-2","slug":"实习招聘面试经历-2","date":"2016-03-13T14:25:14.000Z","updated":"2016-04-05T09:28:03.000Z","comments":true,"path":"2016/03/13/实习招聘面试经历-2/","link":"","permalink":"http://weibo.com/biousco/2016/03/13/实习招聘面试经历-2/","excerpt":"1. Angular双向绑定的实现嗯…面试三次,每个面试官都会问我这个问题,这里还是贴一下参考的文章吧:Angular沉思录（一） 数据的双向绑定AngularJS 数据双向绑定揭秘简易实现版本:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var Scope = function () &#123; this.$$watchers = [];&#125;Scope.prototype.$watch = function( watchExp, listener ) &#123; this.$$watchers.push( &#123; watchExp: watchExp, listener: listener || function () &#123;&#125; &#125;);&#125;;Scope.prototype.$digest = function() &#123; var dirty; do &#123; dirty = false; for (var i = this.$$watchers.length - 1; i &gt;= 0; i--) &#123; var newValue = this.$$watchers[i].watchExp(), oldValue = this.$$watchers[i].last; if( oldValue !== newValue) &#123; this.$$watchers[i].listener(newValue, oldValue); dirty = true; this.$$watchers[i].last = newValue; &#125; &#125;; &#125; while(dirty);&#125;;var $scope = new Scope();$scope.name = 'Ryan';$scope.$watch(function () &#123; return $scope.name;&#125;, function ( newValue, oldValue ) &#123; console.log('Input Value has update:' + newValue + ' and Old Value is: ' + oldValue); element[0].value = newValue; tips.innerHTML = newValue&#125;);/** 视图到模型 **/var element = document.querySelectorAll('input'), tips = document.querySelectorAll('#tips')[0];element[0].addEventListener('keyup', function () &#123; $scope.name = element[0].value; $scope.$digest();&#125;)/** 模型到视图 **/var updateScopeValue = function () &#123; $scope.name = 'Bob'; $scope.$digest();&#125;var btn = document.getElementsByTagName('button')[0];btn.addEventListener('click', function () &#123; updateScopeValue();&#125;)","text":"1. Angular双向绑定的实现嗯…面试三次,每个面试官都会问我这个问题,这里还是贴一下参考的文章吧:Angular沉思录（一） 数据的双向绑定AngularJS 数据双向绑定揭秘简易实现版本:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var Scope = function () &#123; this.$$watchers = [];&#125;Scope.prototype.$watch = function( watchExp, listener ) &#123; this.$$watchers.push( &#123; watchExp: watchExp, listener: listener || function () &#123;&#125; &#125;);&#125;;Scope.prototype.$digest = function() &#123; var dirty; do &#123; dirty = false; for (var i = this.$$watchers.length - 1; i &gt;= 0; i--) &#123; var newValue = this.$$watchers[i].watchExp(), oldValue = this.$$watchers[i].last; if( oldValue !== newValue) &#123; this.$$watchers[i].listener(newValue, oldValue); dirty = true; this.$$watchers[i].last = newValue; &#125; &#125;; &#125; while(dirty);&#125;;var $scope = new Scope();$scope.name = 'Ryan';$scope.$watch(function () &#123; return $scope.name;&#125;, function ( newValue, oldValue ) &#123; console.log('Input Value has update:' + newValue + ' and Old Value is: ' + oldValue); element[0].value = newValue; tips.innerHTML = newValue&#125;);/** 视图到模型 **/var element = document.querySelectorAll('input'), tips = document.querySelectorAll('#tips')[0];element[0].addEventListener('keyup', function () &#123; $scope.name = element[0].value; $scope.$digest();&#125;)/** 模型到视图 **/var updateScopeValue = function () &#123; $scope.name = 'Bob'; $scope.$digest();&#125;var btn = document.getElementsByTagName('button')[0];btn.addEventListener('click', function () &#123; updateScopeValue();&#125;) 自己又在纸上仔细捋了一遍,发现之前面试说的还是有些不太对的地方: $$watch存放的不只是模型,准确来说是一个对象数组,每个对象存储着需要监控的变量和更新时执行的监听函数 $digest是遍历$$watch,发现数据脏了就执行$$watch里的对应的监控的变量的监听函数 在监听函数里将数据绑定到界面上,实现模型-&gt;视图 视图到模型的更新通过监听事件,直接设置value jQuery和Zepto的区别 jQuery: 历史悠久,对PC端友好,体积相对于Zepto过大,但有丰富的插件支持和社区支持 Zepto: 专门为移动端定制,比如tap事件,体积小,一些功能没有jQuery那么完善,不支持链式调用,不支持高级选择器(可以用原生选择器再包装),插件比较少,和jQuery不兼容 贴一篇文章: zepto和jquery的区别，zepto的不同使用8条小结啊,属性选择器是支持的=.= 之前一直以为不支持: Zepto 的选择器表达式: [name=value] 中value 必须用 双引号 “ or 单引号 ‘ 括起来例如执行：$(‘[data-userid=123123123]’)结果：Error: SyntaxError: DOM Exception 12 解决办法： $(‘[data-userid=”123123123]”‘) or $(“[data-userid=’123123123’]”) 觉得其他比较明显的不同是: 不能自定义事件;但可以:$(&#39;&#39;).bind(&#39;my&#39;, function(){}); 选择selected和checked用prop方法其他在上面的文章写的挺清楚的.但是一般还是用了jQuery了哈哈哈 JavaScript原生事件感觉自己运气真好..面试前有比较仔细的看了这部分.看的是红色的那本JavaScript高级程序设计,讲的很明白很透彻: 事件流从页面中接受事件的顺序IE：事件冒泡Netscape：事件捕获DOM事件流： 捕获阶段，处于目标阶段，事件冒泡阶段（高版本浏览器会在捕获阶段触发事件） 事件处理程序 HTML事件，函数有局部变量event，this等于事件目标元素；紧密耦合，时差问题 DOM0级，btn.onclick = function () {}；this引用当前元素，在冒泡阶段处理，删除通过 btn.onclick = null; DOM2级，addEventListener，第三个参数：true：捕获阶段调用，false：冒泡阶段调用；可以添加多个处理程序，按顺序触发，this指向当前元素，用false兼容大部分浏览器 IE：attachEvent，冒泡，作用域为全局作用域，this为window，顺序相反 事件对象 DOM&amp;HTML： event对象：this指向currentTarget，target包含事件的实际目标；用type处理多个事件；eventPhase确定处于哪个阶段，从1开始 IE：DOM0级：window.event，attach：event。用event.srcElement比较保险（attach中this是window）；阻止：returnValue = false；cancelBubble = false 如何改变this的指向面试的时候想到了函数绑定bind.面试官让我写出来=.=啊当时就比较慌了.想了一下,觉得还是说自己会的就好,就说了用apply或者call来实现.后面翻了一下书也确实是这么写的:12345function bind(fn, context) &#123; return function () &#123; return fn.apply(context, arguments); &#125;;&#125; 函数绑定要创建一个函数,可以在特定的this环境中以指定参数调用另一个函数.该技巧常常和回调函数与事件处理程序一起使用,以便在将函数作为变量传递的同事保留代码执行环境 1234567891011121314var handler = &#123; message: \"Event handled\", handleClick: function (event) &#123; alert(this.message); &#125;&#125;;var btn = document.getElementById('my-btn');EventUtil.addHandler(btn, \"click\", bind(handler.handleClick, handler));//Event handled//ES5: EventUtil.addHandler(btn, \"click\", handler.handleClick.bind(handler)); 只要是将某个函数指针以值的形式进行传递,同时该函数必须在特定环境中执行,就需要这个绑定函数. 需要克隆元素并绑定之前所有的事件/移除一个元素所有绑定的事件/让事件执行的顺序都相同?这个之前没想过,但是有看到一篇文章说这个.感觉是会维护一个数组,数组保存着所有用户自己定义的事件,然后克隆的时候直接遍历这个数组绑定事件/移除事件.让事件执行顺序相同就根据浏览器(IE),逆序绑定事件达到所有事件执行顺序都相同.说是这么说,也不知道是不是真的这么干,明天查查资料.断网啦睡觉啦.~~ Node的IO的了解这个真不了解=.= 下面摘抄自&lt;&lt;深入浅出Nodejs&gt;&gt; 在Node中,除了JavaScript是单线程外,Node自身其实是多线程的,只是I/O线程使用的CPU较少.另一个需要重视的观点是,除了用户代码无法并行执行外,所有的I/O(磁盘I/0和网络I/O)则是可以并行起来的. Node的执行模型包括:事件循环,观察者,请求对象,I/O线程池JavaScript的代码通过调用C++核心模块进行下层的操作.从JavaScript调用Node的核心模块,核心模块调用C++内建模块,内建模块通过libuv进行系统调用;libuv有两个平台的实现,实际上调用uv_fs_open()方法;在uv_fs_open()调用过程中,创建了一个FSReqWrap请求对象,JS层传入的参数和方法都封装在这个请求对象中,回调函数是oncomplete_sym:req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback);包装完毕后,Windows下调用QueueUserWorkItem()将这个FSReqWrap对象推入线程池中等待执行.至此,由JavaScript层面发起的异步调用第一阶段就此结束.JavaScript线程可以继续执行当前任务的后续操作,I/O操作就在线程池中等待执行.达到异步的目的.执行回调:线程池中的IO操作调用完毕后,通过PostQueuedCompletionStatus()通知IOCP(IO完成端口),提交执行状态,并将线程归还线程池.这个过程中,事件循环的IO观察者都会检查线程池中是否有执行完的请求,如果存在,将请求对象加入队列,作为事件处理.IO观察者的回调函数就是取出请求对象的result属性作为参数,oncomplete_sym作为方法,调用执行.达到调用JavaScript中传入的回调函数的目的.有张图好想贴上来!!就在书上~~ 看多几遍大概了解这个工作流程了. ## Cookie与Session的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上； cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； 参考文章:理解Cookie和Session机制","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://weibo.com/biousco/tags/面试/"},{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/tags/前端/"}]},{"title":"实习招聘面试经历-1","slug":"实习招聘面试经历-1","date":"2016-03-09T15:10:32.000Z","updated":"2016-03-09T15:20:34.000Z","comments":true,"path":"2016/03/09/实习招聘面试经历-1/","link":"","permalink":"http://weibo.com/biousco/2016/03/09/实习招聘面试经历-1/","excerpt":"1. 无线端开发和PC端开发有什么不同？从三个方面讲：HTML：使用很多新的标签：12&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1\"&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; 在body里面可以使用&lt;header&gt;&lt;section&gt;等H5新标签CSS：使用rem单位；rem单位的计算方法：40 * （设备宽度 / 设计图宽度）；使用的时候实际设计图大小/40面试的时候说错了=。= 但是他没告诉我（把设计图宽度和设备宽度说反了）设置在document.documentElement.style.fontSize；设备宽度为document.documentElement.clientWidth使用更多的CSS3动画；flex布局，但是要考虑兼容性问题针对特定大小的设备进行媒体查询JavaScript：使用一些轻量级的第三方库，如用zepto代替jquery，vue代替angular；流量很重要，更要注重js文件的压缩合并混淆；其他的当时没想到","text":"1. 无线端开发和PC端开发有什么不同？从三个方面讲：HTML：使用很多新的标签：12&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1\"&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; 在body里面可以使用&lt;header&gt;&lt;section&gt;等H5新标签CSS：使用rem单位；rem单位的计算方法：40 * （设备宽度 / 设计图宽度）；使用的时候实际设计图大小/40面试的时候说错了=。= 但是他没告诉我（把设计图宽度和设备宽度说反了）设置在document.documentElement.style.fontSize；设备宽度为document.documentElement.clientWidth使用更多的CSS3动画；flex布局，但是要考虑兼容性问题针对特定大小的设备进行媒体查询JavaScript：使用一些轻量级的第三方库，如用zepto代替jquery，vue代替angular；流量很重要，更要注重js文件的压缩合并混淆；其他的当时没想到 2. 移动端图片有做什么优化 根据设备的像素密度使用不同大小的图片；实现方法：通过cdn的云处理，在js里判断是不是Retina屏幕，根据像素比使用不同尺寸的图片达到目的 使用新的格式比如Webp。 压缩图片，也可以使用cdn来实现，jpg控制质量 使用雪碧图，将小图合并；但是也不能做太大的图片，占用太多的内存。 3. 对ES6的了解 新增的变量定义关键字：let, const；分别对应块级作用域和常亮 对数组，正则表达式进行了一些拓展，比如解构赋值（当时忘记这个词了），其实并没怎么了解，只是有看过 异步写法的优化：promise的使用 4. 对Node的了解 使用node写过豆瓣首页的爬虫 爬虫的使用有使用第三方的模块，比如eventproxy；也有使用promise进行改写 知道babel编译，但没有用确实没怎么写过啦，不过下次可以说一些gulp相关的东西，一些文件操作 5. 写测试 使用Mocha和Chai 主要是功能性的测试，比如表单。实际项目不会写，因为时间比较紧张。 学习了百度的IFE的教程，里面写了一些测试，不用人工测试比较方便。 6. Angular相关 对双向绑定的理解。当时说的有点乱，这里引用一下：用户在视图上的修改会自动同步到数据模型中去，同样的，如果数据模型中的值发生了变化，也会立刻同步到视图中去。当时把模型说成了js了=。=捂脸逃 双向绑定怎么实现。脏检查维护一个监控数组，对前端事件进行绑定，改变模型的时候调用更新方法；（$digest）更新方法是通过遍历监控数组，对每一项进行检查，发现有不同的时候就相应的更新数据在模型里面使用$apply或者改变$scope的属性也会触发$digest 活动使用一些利弊比较笨重，性能不太好，需要不断的遍历检查；可以使用vue或者react来做；好处就是渲染数据比较方便，更新模型也比较方便 使用的一些心得封装一些指令和过滤器：cdn图片处理的过滤器，全站活动通用的下载浮层封装成指令模板 7. 跨域解决方案 jsonp。其实是面试快结束了，面试官问我有没有什么问题。我就问了jsonp是不是必须要后台的支持。答案是是。jsonp利用的是资源可以跨域，请求到数据。本质上请求接口得到的数据是一个变量，然后在js里对变量进行操作。jsonp的返回必须要字符串拼接成合法的js语句，然后才能执行（我问是因为Angular好像不用后台支持就能用了，现在想应该是后台有写好吧，开发的人没有去问。然后面试官就问我其他的跨域解决方案了） 添加请求头，就是CORS，定义一下Access-cross-allow-origin，如果当前请求的域名在这里面的话就可以跨域了。顺便提一下，这里会产生一个OPTION请求，浏览器自己请求的，进行嗅探 通过后台代理进行，比如后台java可以请求到跨域的数据，然后进行处理后再返回，后台和前端页面是同一个域名，就没有跨域的问题了 8. 其他 对HTTP2的了解：不太了解，说了一下增加并发数，忘记了=。=引用： 异步连接多路复用；头部压缩；请求/响应管线化；多路复用请求；对请求划分优先级；压缩HTTP头；服务器推送流（即Server Push技术）；SPDY试图保留HTTP的现有语义，所以cookies、ETags等特性都是可用的。 复杂一点的选择器可以用document.querySelector来实现 面试评价（我问的）：可以增加知识的深度，加强js基础，库和框架是学不完的，多深入了解 注意移动端的性能，内存，电量，流量都是很重要的，要选择一些轻量的解决方案 自我介绍感觉有点啰嗦了=。=实习经历感觉讲的有点多，下次要注意一下 9. 体会当时5点正在刷网页，好像是在看围棋大战。戴着耳机，突然感觉到有动静，有点激动，发现还是杭州的。不过当时没想到是阿里，以为是什么推销电话=。=真是太naive啦。面试官声音好好听啊~了解到是面试，很紧张，就麻烦面试官等2分钟，想自己整理一下情绪哈哈哈。然后就关掉浏览器，打开自己的博客啊，简历啊，准备等会可以看看，又准备一些纸和笔，想待会可以写下来整理一下思路，顺便记录一下面试问题。然后打开了手机的录音机= =想把面试过程录音下来。然而，事实是，一接到电话就自动停止录音了….电话结束了才发现。接着就是插上耳机等面试官打电话过来了，还是很快的。面试官叫阿大，来自技术工程部，属于淘宝的部门。觉得阿大好好人，好nice！！我说完一段话都会回应我，也是让我没那么紧张了。面试24分钟，面试完脸热热的= =，也很口渴。啊~~好想去阿里啊~~~目前状态是面试中，估计一面是过了吧…二面希望自己好好加油。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://weibo.com/biousco/tags/面试/"},{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/tags/前端/"}]},{"title":"移动端SeeApp开发总结-5","slug":"移动端SeeApp开发总结-5","date":"2016-03-07T12:15:44.000Z","updated":"2016-03-07T12:48:32.000Z","comments":true,"path":"2016/03/07/移动端SeeApp开发总结-5/","link":"","permalink":"http://weibo.com/biousco/2016/03/07/移动端SeeApp开发总结-5/","excerpt":"这次总结一下用Angular的一些小技巧~ 好的实践 自动启动：ng-app，自动引导启动第一个ng-app;手工启动：angular.bootstrap() 使用ng-bind代替双括号语法。避免Angular用数据替换时出现双括号；实在要用时，使用ng-cloak,并且能避免内容闪烁 需要使用background-image时，可以自己定义指令： 123456789app.directive('backImg', function()&#123; return function(scope, element, attrs)&#123; attrs.$observe('backImg', function(value) &#123; element.css(&#123; 'background-image': 'url(' + value +')' &#125;); &#125;); &#125;;&#125;); 也可以使用ng-style来实现。","text":"这次总结一下用Angular的一些小技巧~ 好的实践 自动启动：ng-app，自动引导启动第一个ng-app;手工启动：angular.bootstrap() 使用ng-bind代替双括号语法。避免Angular用数据替换时出现双括号；实在要用时，使用ng-cloak,并且能避免内容闪烁 需要使用background-image时，可以自己定义指令： 123456789app.directive('backImg', function()&#123; return function(scope, element, attrs)&#123; attrs.$observe('backImg', function(value) &#123; element.css(&#123; 'background-image': 'url(' + value +')' &#125;); &#125;); &#125;;&#125;); 也可以使用ng-style来实现。 过滤器的实践： 1&lt;img ng-src=\"imgsrc | imageFormat: 200 : 200\" /&gt; 123456789101112131415/* 添加cdn的图片处理后缀 */app.filter('imageFormat', function() &#123; return function(path, width, height, mode) &#123; if (!path) &#123; return \"\"; &#125; if (!width || !height) &#123; return path; &#125; mode = mode || 0; width = see.isRetina() ? parseInt((window.devicePixelRatio || 1) * width) : parseInt(width); height = see.isRetina() ? parseInt((window.devicePixelRatio || 1) * height) : parseInt(height); return path + \"?imageView2/\" + mode + \"/w/\" + width + \"/h/\" + height + \"/q/80\"; &#125;;&#125;); 列表渲染完成使用回调函数： 1&lt;li ng-repeat=\"t in list\" on-finish-render-filters=\"callback\"&gt;&lt;/li&gt; 123456789101112131415app.directive('onFinishRenderFilters', function ($timeout) &#123; return &#123; restrict: 'A', link: function(scope, element, attr) &#123; if (scope.$last === true) &#123; $timeout(function() &#123; var fun = scope.$parent[attr.onFinishRenderFilters]; if(fun) &#123; fun(); &#125; &#125;); &#125; &#125; &#125;;&#125;); 定义服务的三种api：provider,factory,service;factory：只需要一些数据和方法的集合service：通过构造函数的方式创建service，利用面向对象来定义，通过原型模式创建对象。单例对象provider：能使用config()方法来配置，通过this.$get()来进行依赖注入。可配置性强，在应用开始前进行配置下面是自己写的一个创建接口的provider: 1234567891011121314151617181920212223242526272829303132333435363738app.provider('BackEndList', function() &#123; this.list = []; this.setBackEndList = function(list) &#123; if (list) &#123; this.list = list; &#125; &#125;; this.$get = function($http, $httpParamSerializerJQLike) &#123; var t = this, href = window.location.href, testStr = \"\"; if (href.indexOf('localhost') &gt; -1 || href.indexOf('192.168') &gt; -1) testStr = \"/Mock\"; var service = &#123;&#125;; angular.forEach(this.list, function(value) &#123; service[value.name] = function() &#123; return $http(&#123; url: see.getUrlPrefix(true) + value.url + testStr, mothod: value.method || \"get\", dataType: value.dataType || \"json\" &#125;); &#125;; &#125;); return service; &#125;;&#125;);app.config(function (BackEndListProvider) &#123; BackEndListProvider.setBackEndList([&#123; name: \"getYearIndex\", url: \"/act/actShoppingYear/getActivity\" &#125;, &#123; name: \"getCoupon\", url: \"/act/actShoppingYear/getCoupon\" &#125;, &#123; name: \"getShareCoupon\", url: \"/act/actShoppingYear/getExtraCoupon\" &#125;]);&#125;); 关于三者的参考文章:AngularJS中service,factory,provider的区别 http请求时如果需要jQuery的格式，使用$httpParamSerializerJQLike，调用原生$http方法 初始化可以使用ng-init=&quot;init()&quot;，或者在angular.element(document).ready()中写 Angular和jQuery一起用的时候，使用$会调用jQuery。 使用测试数据可以用Mockjs controller里面也可以使用filter： 123app.controller('Ctrl', function ($scope, $filter) &#123; $scope.cur_date = parseInt($filter('date')(new Date(), 'dd'), 10);&#125;) 不是Angular触发的事件要更新数据时，使用$apply： 123$scope.$apply(function () &#123; $scope.a = 'test';&#125;); 使用Angular自带的$timeout，原理同上 单次绑定模板，减少数据监控，提高性能： 123&lt;li ng-repeat=\"t in list\"&gt; &lt;span ng-bind=\"::t.name\"&gt;&lt;/span&gt;&lt;/li&gt; 参考文章:Exploring Angular 1.3: One-time bindings","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://weibo.com/biousco/tags/Angular/"}]},{"title":"移动端SeeApp开发总结-4","slug":"移动端SeeApp开发总结-4","date":"2016-01-31T04:15:44.000Z","updated":"2016-01-31T07:34:50.000Z","comments":true,"path":"2016/01/31/移动端SeeApp开发总结-4/","link":"","permalink":"http://weibo.com/biousco/2016/01/31/移动端SeeApp开发总结-4/","excerpt":"一晃眼已经2016年了，隔了几个月没有总结写文章好想抽死自己。而且要准备校招了得放点东西到这里呀。寒假又来See实习了。大三上学期也断断续续帮See写一些页面：http://biouscowork.sinaapp.com/，每次活动都各种熬夜，后面才慢慢改善。接下来写一些这些页面的总结和坑。这次是接口渲染。 Ajax &amp; Cgi CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。 这就是经常说的接口啦。cgi这个词是看过某大大写的页面后才发现原来应该这么叫。一般请求接口返回的就是需要渲染的数据了，比如这个：getActivity 。一般后台给的都是json，如果是字符串的话就前端解析一下就好了。一般一个活动页面是这样的流程：前端重构好，拿到接口后就直接渲染。运营提供数据给后台开发，后台改接口返回的数据。不是之前的php框架那样服务器渲染好后吐出html，用接口的html一般没有太多数据，所以要是接口请求失败了或者请求时间比较长页面会有很长的空白，体验没那么好。自己总结一下优缺点吧：优点： 简单的前后端分离，后端只提供数据，前端专注渲染 容易控制一些异步的数据展现 可以通过接口的代理简单实现本地开发，不需要太依赖后端环境 缺点： 请求上多了接口，渲染工作放在了客户端，性能不太好 和后台联调需要一些时间，沟通成本增加 不利于SEO，不过这种做的一般是活动页面，SEO并不是很重要 js代码需要一定的组织","text":"一晃眼已经2016年了，隔了几个月没有总结写文章好想抽死自己。而且要准备校招了得放点东西到这里呀。寒假又来See实习了。大三上学期也断断续续帮See写一些页面：http://biouscowork.sinaapp.com/，每次活动都各种熬夜，后面才慢慢改善。接下来写一些这些页面的总结和坑。这次是接口渲染。 Ajax &amp; Cgi CGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。 这就是经常说的接口啦。cgi这个词是看过某大大写的页面后才发现原来应该这么叫。一般请求接口返回的就是需要渲染的数据了，比如这个：getActivity 。一般后台给的都是json，如果是字符串的话就前端解析一下就好了。一般一个活动页面是这样的流程：前端重构好，拿到接口后就直接渲染。运营提供数据给后台开发，后台改接口返回的数据。不是之前的php框架那样服务器渲染好后吐出html，用接口的html一般没有太多数据，所以要是接口请求失败了或者请求时间比较长页面会有很长的空白，体验没那么好。自己总结一下优缺点吧：优点： 简单的前后端分离，后端只提供数据，前端专注渲染 容易控制一些异步的数据展现 可以通过接口的代理简单实现本地开发，不需要太依赖后端环境 缺点： 请求上多了接口，渲染工作放在了客户端，性能不太好 和后台联调需要一些时间，沟通成本增加 不利于SEO，不过这种做的一般是活动页面，SEO并不是很重要 js代码需要一定的组织 渲染的几种方式实习的时候有幸见到几种不同的方法渲染数据，总结一下，大概三种：jQuery的DOM操作，前端模板引擎，MV*框架 DOM操作用jquery操作数据：123456789101112131415161718192021222324var li = t.li_sample.clone(true).attr('name','li_row').attr('f_id', f.f_id).show();if (f.u_id == see.user.uid) &#123; li.find('[name=delete]').attr('f_id', f.f_id).show();&#125;li.find('[name=img]').attr('src', f.f_headimg).on('click', function () &#123; var u_url = see.isInApps()?\"see://userCenter?u_id=\"+dt.circle.owner_id:\"http://m.seeapp.com\"; window.location.href = u_url;&#125;);li.find('[name=nick]').text(f.f_username);li.find('[name=comment]').text(f.f_comment);if(f.u_isdaren == 1) &#123; li.find('.daren-logo').show();&#125;if(f.u_tag) &#123; li.find('[name=tag]').text(f.u_tag).css('display', 'inline-block');&#125;if(f.circle) &#123; li.find('[name=circle_name]').text(f.circle.cir_name); var url = see.getUrlPrefix() + \"/static/detail/circle.html?cir_id=\" + f.circle.cir_id; li.find('.circle').show().attr('data-href',url).on('click', function(event) &#123; event.preventDefault(); window.location.href = url; &#125;);&#125; 嗯，第一次实习见到的代码是这样的。当时觉得好厉害，原来jQuery可以这么用，之前都只会用来写动画。后面见到其他的方法后觉得这种方法一般般咯： 需要不断的查找dom节点，觉得影响性能。而且一般通过属性name来查找，但是name属性一般用来给后台传值用，觉得可以用其他的字段来代替。 需要判断字段的合法性。当某个字段不存在时特别容易报错，影响接下来的数据渲染。 渲染和其他的操作混在一起了：比如添加类名、绑定事件 优点是比较直观易懂。适合小片的数据展示 主要流程是，复制一个html中的父节点，在里面渲染数据后append到容器中。 还有一种同样是操作dom的方式：1234567891011121314151617181920212223242526272829303132collection: function(ret)&#123; if (render._check(ret))&#123; var goodsClass = ret.data.item_list; var $collections = $('.mod_collection'); goodsClass.forEach(function(array,index)&#123; var virtualDOMs = array.map(render._collectionBox); $collections.eq(index).append(virtualDOMs); &#125;); &#125;&#125;,_collectionBox: function(collectionObj)&#123; var $collectionBox = $('&lt;div class=\"mod_collection_box\"&gt;&lt;/div&gt;'); var itemInfo = collectionObj.item_info.map(render._collectionItem); var $collectionGoods = $('&lt;div class=\"box_content\"&gt;&lt;/div&gt;'); $collectionGoods.html(itemInfo); $collectionBox.append(render._collectionBanner(collectionObj.base_info)); $collectionBox.append($collectionGoods); return $collectionBox;&#125;, 用map函数返回做好的dom片段加入页面中，每个片段用$生成。感觉代码比上面的要好看的多。 没有了dom的查找，用$生成html片段，但js里就包含太多html的东西了 事件绑定都放到所有节点渲染完毕后来做 很多数据结构必须为数组，不过这个和后台约定就好了 刚开始做的活动基本都是这么干，然后js随随便便就67百行了：双11预热，当时不懂封装什么的，代码只是简单的分了点层。后面学习了其他的写法，有几点可以进行改进： 将所有请求的接口放到一个对象：1234t.RequestURL = &#123; 'getUserdetail': t.apiDomain + '/user/getUserdetail', 'getFormalData': t.apiDomain + '/act1111_formal/getFormalData'&#125;; 或者这么写：12345var cgi = &#123; getOneDayLimitData: function()&#123; return $.getJSON(apiDomain + '/index.php/actBlack5/getOneDayLimitData'); &#125;&#125;; 第二种方法可以很优雅的在函数里这么用：1cgi.getOneDayLimitData().done(render.limit); 一股浓浓的angular的味道！缺点是用zepto就不能这么链式调用了。不过zepto改一下源码应该也能这么干。另外全部写在一起也方便对接口路径做一些处理，比如加上时间戳：1getActivity: '/actXmas/getActivity' + '?timestamp=' + (new Date()).getTime(), 不用在函数里一个个找来修改了。 能放到对象的不止接口，像一些cdn处理的后缀也可以放进去12345678t.ImageSnipper = &#123; group : \"?imageView2/2/w/600/q/80\", collection : \"?imageView2/2/w/600/q/80\", collection_item : \"?imageView2/2/w/200/q/80\", recommend : \"?imageView2/2/w/300/q/80\", top_item: \"?imageView2/2/w/300/q/80\", bottom_item: \"?imageView2/2/w/300/q/80\"&#125;; 以前全部写在渲染的函数里真的太麻烦了，不方便维护和修改，当然这里也只是简单封装，后面angular可以配置得更灵活点 前端模板引擎这个就类似后台的MVC的V了。只不过放到js来做。这是在另一个师兄的代码里看到的，第一眼又是惊艳到我：12345tags = $(Util.tmpl(tplCoverStr, &#123; collection_info: data[i].collection_info, url:see.getUrlPrefix() + \"/static/detail/collection.html?id=\"&#125;));wrapper.appendChild(tags[0]); js真的超级简单，然后看一下html：1234567891011121314151617181920212223&lt;script type=\"text/template\" id=\"tpl-collection-items\"&gt;&lt;div class=\"j-slide-list com-wrap\" curindex=\"0\" size=\"&lt;%= pageSize %&gt;\"&gt;&lt;% for (var i = 0, k = 0; i &lt; list.length; i+=3, k++) &#123; %&gt; &lt;ul class=\"com-list com&lt;%= k %&gt;\" classindex=\"&lt;%= k %&gt;\"&gt; &lt;% for (var j = 0; j &lt; 3; j++) &#123; %&gt; &lt;% if (i + j &gt;= list.length) &#123; continue;&#125; %&gt; &lt;li&gt; &lt;!-- 假数据里面没看到超链接，如果有的话，需要自己加上去 --&gt; &lt;a href=\"&lt;%=url + list[i + j].item_id %&gt;\"&gt; &lt;b style=\"background-image:url(&lt;%= list[i + j].item_imgurl %&gt;)\"&gt;&lt;/b&gt; &lt;p&gt;&lt;%= list[i + j].item_name %&gt;&lt;/p&gt; &lt;p class=\"dis\"&gt;&lt;%= list[i + j].item_comments %&gt;&lt;/p&gt; &lt;p class=\"price\"&gt; &lt;span class=\"preferential\"&gt;¥&lt;%= list[i + j].price %&gt;&lt;/span&gt; &lt;span class=\"original\"&gt;¥&lt;%= list[i + j].ori_price %&gt;&lt;/span&gt; &lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;% &#125; %&gt;&lt;/div&gt;&lt;/script&gt; 和后台的MVC基本一样，用原生的js的语法进行循环赋值判断什么的。 适合直白的列表展示，没有太多的条件逻辑。如果条件很多的话html会很多很乱 可以在html里放一份注释的渲染后的样本例子，先改动栗子再改模板，方便调试 一些数据需要在js里进行处理后再进行渲染，或者改成适合渲染的结构 不好做数据有效性验证，最好渲染前处理一遍数据 数据出错不好做定位 在开发里试过一两次，用的模板引擎好像是腾讯出品，选其他的大概也不会差太多：123456var top_item_list = &#123; data: data.top_item_list&#125;;_html = template('p_top_item_list',top_item_list);document.getElementById('T_top_item_list').innerHTML = _html;$(\".m-goods-card04\").find('img[name=lazyload]').on('load',resizeImg); 用模板引擎的函数处理一遍html和数据，返回html片段，直接塞进父容器就好，后面再进行一些事件绑定。 MV*框架现在都用这个来做活动了，用的是Angular。暑假实习的时候用这个写了后台，活动没有选他是因为觉得有点杀鸡用牛刀了。但是后面公司又来了一位大大，全部用Angular写，然后我也尝试了一下，发现效果真的很好~每次请求一次服务，在html里写好指令就ok了123456789101112 BackEndList.getYearIndex().success(function (data) &#123; if (data.result == 1) &#123; $scope.data = data.data; $scope.cur_firstList = data.data.firstList[$scope.cur_first_date]; $scope.typeList = data.data.typeList; $scope.typeSubList = filterSubList($scope.typeList); &#125; else &#123; console.log('warn'); &#125; &#125;)&#125;; 终于不用花太多精力在写数据渲染上了TAT。后面再单独写一篇关于Angular的总结。总之用了这个，代码量真的会少，工作效率真的提高了！另外事件绑定也没有以前那么麻烦，更直白一点了。 今天周末来公司加班。然而老大说需求改了，先不做。啊，今天就在公司坐着吹吹水写这个东西了。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://weibo.com/biousco/tags/JavaScript/"},{"name":"ajax","slug":"ajax","permalink":"http://weibo.com/biousco/tags/ajax/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://weibo.com/biousco/tags/模板引擎/"},{"name":"Angular","slug":"Angular","permalink":"http://weibo.com/biousco/tags/Angular/"}]},{"title":"移动端SeeApp开发总结-3","slug":"移动端SeeApp开发总结-3","date":"2015-09-07T08:56:00.000Z","updated":"2015-09-07T09:00:15.000Z","comments":true,"path":"2015/09/07/移动端SeeApp开发总结-3/","link":"","permalink":"http://weibo.com/biousco/2015/09/07/移动端SeeApp开发总结-3/","excerpt":"这次只讲一个东西：移动端图片压缩&amp;上传。 DOM12&lt;input id=\"uploadPic_input\" type=\"file\" accept=\"image/*\" style=\"display:block;opacity:0;\" name=\"image\"&gt;&lt;a id=\"uploadPic_btn\" href=\"javascript:void(0);\" class=\"a02\"&gt; 在移动端，input大部分还是支持的，当类型为file时，苹果会弹出拍照/录像和照片图库；手上没安卓= =，记得也是类似的选项。但是需求是只要图片，所以用了accpet这个属性，就能自动地把录像这个选项去掉了。accept还支持选定的格式，语法：1&lt;input accept=\"audio/*|video/*|image/*|MIME_type\"&gt; 目前还是候选推荐标准（W3C Candidate Recommendation），但是支持的浏览器还是挺多的，测试中都能正常使用。相关链接：accept这里设置为透明是业务需要，默认不展示这个按钮。","text":"这次只讲一个东西：移动端图片压缩&amp;上传。 DOM12&lt;input id=\"uploadPic_input\" type=\"file\" accept=\"image/*\" style=\"display:block;opacity:0;\" name=\"image\"&gt;&lt;a id=\"uploadPic_btn\" href=\"javascript:void(0);\" class=\"a02\"&gt; 在移动端，input大部分还是支持的，当类型为file时，苹果会弹出拍照/录像和照片图库；手上没安卓= =，记得也是类似的选项。但是需求是只要图片，所以用了accpet这个属性，就能自动地把录像这个选项去掉了。accept还支持选定的格式，语法：1&lt;input accept=\"audio/*|video/*|image/*|MIME_type\"&gt; 目前还是候选推荐标准（W3C Candidate Recommendation），但是支持的浏览器还是挺多的，测试中都能正常使用。相关链接：accept这里设置为透明是业务需要，默认不展示这个按钮。 上传流程后台提供的上传图片的接口返回的是一个字符串，字符串的值是图片在服务器存放的路径。在整个流程的最后上传图片的路径，而不是图片。考虑到还要预览图片，就没有用FileReader这个接口来预览，而是等图片上传完毕后直接贴上链接，在上传图片时，还要有提示信息，比如上传进度。此外，预览的图片还能进行删除操作。在移动端，由于手机摄像头的升级，图片的体积一般很大，1~2M都是正常的范围，为了节省流量并加速，必须对图片进行压缩操作再进行上传，而服务器也会对图片进行压缩，所以最后再次请求的预览的图片其实很小。 图片压缩流程参考文章：移动端图片上传后进行压缩功能 在移动端压缩图片并且上传主要用到filereader、canvas以及formdata这三个h5的api。逻辑并不难。整个过程就是： 用户使用input file上传图片的时候，用filereader读取用户上传的图片数据（base64格式） 把图片数据传入img对象，然后将img绘制到canvas上，再调用canvas.toDataURL对图片进行压缩 获取到压缩后的base64格式图片数据，转成二进制塞入formdata，再通过XmlHttpRequest提交formdata。 具体细节利用FileReader获取图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var imageCompress = new (function (file) &#123;var filechooser = document.getElementById(\"uploadPic_input\");// 用于压缩图片的canvasvar canvas = document.createElement(\"canvas\");var ctx = canvas.getContext('2d');// 瓦片canvasvar tCanvas = document.createElement(\"canvas\");var tctx = tCanvas.getContext(\"2d\");var maxsize = 100 * 1024;var progress_timer = null;filechooser.onchange = function () &#123; if(window.navigator.userAgent.toLowerCase().indexOf('android') &gt; -1) &#123; uploadPic.uploadWithnoCompress(); return; &#125; if (!this.files.length) &#123; see.tips('请上传正确的图片'); return; &#125; var files = Array.prototype.slice.call(this.files); files.forEach(function (file, i) &#123; if (!/\\/(?:jpeg|png|gif)/i.test(file.type)) &#123; see.tips('非法格式'); return; &#125; var reader = new FileReader(); //获取图片大小 var size = file.size/1024 &gt; 1024 ? (~~(10*file.size/1024/1024))/10 + \"MB\" : ~~(file.size/1024) + \"KB\"; reader.onload = function () &#123; var result = this.result; var img = new Image(); img.src = result; //如果图片大小小于100kb，则直接上传 if (result.length &lt;= maxsize) &#123; img = null; return; &#125; //图片加载完毕之后进行压缩，然后上传 if (img.complete) &#123; callback(); &#125; else &#123; img.onload = callback; &#125; function callback() &#123; var data = compress(img); upload(data, file.type, file.name); img = null; &#125; &#125;; reader.readAsDataURL(file); &#125;)&#125;; 由于很多微信内的安卓机并不支持Canvas的.toDataURL方法，这里安卓就用另一种没有压缩的办法来实现文件上传 监听input元素，元素的files属性是一个FileList，存放着将要上传的文件，用Array.prototype.slice.call()方法将对象转换为数组，然后用forEach来遍历数组。 紧接着对上传的文件进行一系列的判断，然后就开始调用FileReader接口了。 ~~是将浮点数转为整数，只保留小数部分 HTML5接口的FileReader有两个方法：readAsDataURL和readAsText。readAsDataURL传入一个blob类型的数据，返回Data URL，一般是Base64的字符串。这个两个方法是异步的，因此，给reader定义一个onload事件，数据加载完成后，onload事件里的result就是处理完成后的结果。参考：FileReader readAsDataURL完成后返回大概这么一个字符串：data:image/jpeg;base64,/9j/4AAQSkZJRgABA...QAASABIAAD/4QB=中间有7w多个字符，表示一张图片： Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 在onload事件里，创建了一个Image对象，返回一个DOM元素，给Image对象赋DataURL的值。Image对象有很多属性，其中一个是complete，返回浏览器是否已完成对图像的加载。加载成功后，调用压缩方法，再调用上传的方法，否则等加载完成后再进行调用。参考：HTML DOM Image 对象 HTMLImageElement 用canvas压缩12345678910111213141516171819202122232425262728293031323334353637383940414243function compress(img) &#123; var initSize = img.src.length; var width = img.width; var height = img.height; //如果图片大于四百万像素，计算压缩比并将大小压至400万以下 var ratio; if ((ratio = width * height / 4000000)&gt;1) &#123; ratio = Math.sqrt(ratio); width /= ratio; height /= ratio; &#125;else &#123; ratio = 1; &#125; canvas.width = width; canvas.height = height; //铺底色 ctx.fillStyle = \"#fff\"; ctx.fillRect(0, 0, canvas.width, canvas.height); //如果图片像素大于100万则使用瓦片绘制 var count; if ((count = width * height / 1000000) &gt; 1) &#123; count = ~~(Math.sqrt(count)+1); //计算要分成多少块瓦片`~~`是取整数部分 //计算每块瓦片的宽和高 var nw = ~~(width / count); var nh = ~~(height / count); tCanvas.width = nw; tCanvas.height = nh; for (var i = 0; i &lt; count; i++) &#123; for (var j = 0; j &lt; count; j++) &#123; tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh); ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh); &#125; &#125; &#125; else &#123; ctx.drawImage(img, 0, 0, width, height); &#125; //进行最小压缩 var ndata = canvas.toDataURL('image/jpeg', 0.1); tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0; return ndata;&#125; 压缩函数接受的参数是一个image类型的DOM节点，这个image的url是base64编码的，能直接读取数据 压缩图片主要就是canvas的drawImage方法以及toDataURL方法 drawImage：接受八个参数，分别是：数据类型（DOM节点），起始x坐标，起始y坐标，图像宽，图像高（相对于图像而言），起始x坐标，起始y坐标，画布宽，画布高（相对于画布而言）。非常详细。主要功能是在画板上绘画图片。参考：drawImage toDataURL：接受两个参数，数据类型和jpeg质量，返回一个字符串，就是base64编码的图片数据。参考：toDataURL 下面是原文内容： 在IOS中，canvas绘制图片是有两个限制的： 首先是图片的大小，如果图片的大小超过两百万像素，图片也是无法绘制到canvas上的，调用drawImage的时候不会报错，但是你用toDataURL获取图片数据的时候获取到的是空的图片数据。 再者就是canvas的大小有限制，如果canvas的大小大于大概五百万像素（即宽高乘积）的时候，不仅图片画不出来，其他什么东西也都是画不出来的。 应对第一种限制，处理办法就是瓦片绘制了。瓦片绘制，也就是将图片分割成多块绘制到canvas上，我代码里的做法是把图片分割成100万像素一块的大小，再绘制到canvas上。 而应对第二种限制，我的处理办法是对图片的宽高进行适当压缩，我代码里为了保险起见，设的上限是四百万像素，如果图片大于四百万像素就压缩到小于四百万像素。四百万像素的图片应该够了，算起来宽高都有2000X2000了。 如此一来就解决了IOS上的两种限制了。 除了上面所述的限制，还有两个坑，一个就是canvas的toDataURL是只能压缩jpg的，当用户上传的图片是png的话，就需要转成 jpg，也就是统一用canvas.toDataURL(“image/jpeg”, 0.1) ， 类型统一设成jpeg，而压缩比就自己控制了。 另一个就是如果是png转jpg，绘制到canvas上的时候，canvas存在透明区域的话，当转成jpg的时候透明区域会变成黑色，因为 canvas的透明像素默认为rgba(0,0,0,0)，所以转成jpg就变成rgba(0,0,0,1)了，也就是透明背景会变成了黑色。解决办法就 是绘制之前在canvas上铺一层白色的底色。 上传图片12345678910111213141516171819202122232425262728293031323334353637383940414243function upload(basestr, type, filename) &#123; var text = window.atob(basestr.split(\",\")[1]); var buffer = new Uint8Array(text.length); var pecent = 0 , loop = null; for (var i = 0; i &lt; text.length; i++) &#123; buffer[i] = text.charCodeAt(i); &#125; var blob = new Blob([buffer], &#123;type: type&#125;); var xhr = new XMLHttpRequest(); var formdata = new FormData(); //在一个Formdata里面传入多个数据，后台判断filename formdata.append('image', blob, filename); formdata.append('type','1'); xhr.open('post', 'http://m.seeapp.com/image/upload'); //设置与后台对应的请求头 xhr.setRequestHeader(\"Accept\",\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\"); xhr.setRequestHeader(\"Cache-Control\",\"max-age=0\"); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; uploadPic.success($.parseJSON(xhr.responseText)); &#125; &#125;; xhr.upload.addEventListener('progress', function (e) &#123; if (loop) return; pecent = ~~(100 * e.loaded / e.total) / 2; showProgress(\"正在上传中...\" + pecent + \"%\"); if (pecent == 50) &#123; mockProgress(); &#125; &#125;, false); function mockProgress() &#123; if (loop) return; loop = setInterval(function () &#123; pecent = pecent+2; showProgress(\"正在上传中...\" + pecent + \"%\"); if (pecent &gt;= 99) &#123; clearInterval(loop); &#125; &#125;, 30) &#125; xhr.send(formdata);&#125; 首先是btoa()方法： 由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。例如，发送某些含有 ASCII 码表中 0 到 31 之间的控制字符的数据。 然后是Uint8Array对象： The Uint8Array typed array represents an array of 8-bit unsigned integers. The contents are initialized to 0. Once established, you can reference elements in the array using the object’s methods, or using standard array index syntax (that is, using bracket notation). Uint8Array数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。 把base64的内容都转移到Uint8Array对象中 Blob对象 A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn’t necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user’s system. 好吧这三个东西把我搞懵了=。=，都是理解意思，然而并不知道以后可以怎么用。 在调试接口的时候，用文章原来的实现方法并不能成功，后来调试才发现需要一些必要的参数：formdata.append(&#39;image&#39;, blob, filename);。当然不同项目也不同，随机应变，查一下文档就能知道使用方法了。 后面紧接着XMLHttpRequest和FormData，这两个比较熟悉，就不贴了。另外用原生的xhr时，请求的头部一些必要的信息必须加上，通过测试用的接口和Chrome的工具来查看到底需要哪些参数，哪些头部。 后面就是ajax请求了。新的接口提供了progress事件，可以检测上传的进度。 结束 感觉写了好多= =。当时Sheen提出要压缩图片的时候，我内心是崩溃的..刚来公司几天就接手这个项目，好不容易摸清了ajax应用的套路，刚把无刷新上传写好就让我加个压缩功能~~不过后来百度了一下好像也没有特别难啦哈哈哈，虽然兼容性有点问题~后来在安卓版本的微信里面发现canvas有些功能不能用，就砍掉了，用一个上传插件来写，没有经过压缩的步骤。 不过在ios端加上这个之后确实好了很多，很多图片在一般的网络环境上传也快了，在wifi下能看到正在上传50%然后一下子就好了也是挺爽的一件事。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://weibo.com/biousco/tags/JavaScript/"},{"name":"ajax","slug":"ajax","permalink":"http://weibo.com/biousco/tags/ajax/"},{"name":"canvas","slug":"canvas","permalink":"http://weibo.com/biousco/tags/canvas/"},{"name":"FileUpload","slug":"FileUpload","permalink":"http://weibo.com/biousco/tags/FileUpload/"}]},{"title":"移动端SeeApp开发总结-2","slug":"移动端SeeApp开发总结-2","date":"2015-09-01T03:12:45.000Z","updated":"2015-09-01T03:26:29.000Z","comments":true,"path":"2015/09/01/移动端SeeApp开发总结-2/","link":"","permalink":"http://weibo.com/biousco/2015/09/01/移动端SeeApp开发总结-2/","excerpt":"上一次记录了Fiddler和js结构组织，这次写一下在js里具体一个模块是怎么写的。 通用函数encodeURIComponent()和decodeURIComponent()encodeURIComponent： 把字符串作为URI 组件进行编码 不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII标点符号进行编码 其他字符（比如：;/?:@&amp;=+$,# 这些用于分隔URI组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。栗子：encodeURIComponent(&quot;你好，世界！&quot;)输出为%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81","text":"上一次记录了Fiddler和js结构组织，这次写一下在js里具体一个模块是怎么写的。 通用函数encodeURIComponent()和decodeURIComponent()encodeURIComponent： 把字符串作为URI 组件进行编码 不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII标点符号进行编码 其他字符（比如：;/?:@&amp;=+$,# 这些用于分隔URI组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。栗子：encodeURIComponent(&quot;你好，世界！&quot;)输出为%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81 decodeURIComponent： decodeURIComponent() 函数可对 encodeURIComponent() 函数编码的 URI 进行解码。 与encodeURIComponent()相反。 什么时候用到这两个函数：登录成功后或者任何操作后对于跳转回原页面。1t.login_a.attr('href','http://m.seeapp.com/see/static/detail/login.html?ref='+ encodeURIComponent(window.location.href)); 在链接后面加上一个参数ref，参数值为当前页面的URI。为什么需要进行编码：为什么要对URI进行编码 Url中有些字符会引起歧义：例如Url参数字符串中使用key=value键值对这样的形式来传参，键值对之间以&amp;符号分隔，如/s?q=abc&amp;ie=utf- 8。如果你的value字符串中包含了=或者&amp;，那么势必会造成接收Url的服务器解析错误，因此必须将引起歧义的&amp;和=符号进行转义， 也就是对其进行编码 Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，例如中文。否则如果客户端浏览器和服务端浏览器支持的字符集不同的情况下，中文可能会造成问题。 在跳转到login.html之后点击登陆，在js里面获取ref参数，链接直接跳转到参数值，就能回到原来的页面了：1window.location.href = see.get_param('ref'); 获取URI中的参数1234567891011121314151617181920212223t.get_param = function(key)&#123; if(window.location.href.indexOf('?')==-1)&#123; return null; &#125; var uri = window.location.href.replace(/^[^\\?]*\\?/,''); var data = &#123;&#125;; var pairs = uri.split('&amp;'); for(var k in pairs)&#123; if(typeof(pairs[k])=='string') &#123; var k_v_arr = pairs[k].split('='); if (k_v_arr.length) &#123; data[k_v_arr[0]] = k_v_arr[1] || ''; &#125; &#125; &#125; if(key in data)&#123; return data[key]; &#125; return null;&#125;; window.location.href.replace(/^[^\\?]*\\?/,&#39;&#39;);这个正则把URL中?之前的字符串都替换成了空格，只剩下?后面的参数然后通过split()函数，把参数字符串通过&amp;分隔开来成为数组。不断地对每一个数组项进行判断。对数组项比如&quot;tid=10222&quot;通过=来分隔，就得到参数名和参数值了。123456var a = \"http://m.seeapp.com/see/static/detail/index.html?tid=10222&amp;h=121&amp;oo=0000\".replace(/^[^\\?]*\\?/,'');/* a = \"tid=10222&amp;h=121&amp;oo=0000\" */a.split('&amp;');/* a = [\"tid=10222\", \"h=121\", \"oo=0000\"] */var barr = a[0].split('=');/* barr = ['tid','10222']; 当时阿里的网招的笔试题也有这道题目。123456789101112131415161718function parseQueryString(input) &#123; var output; var arr = input.replace(/^[^\\?]*\\?/,''); var data = []; data = arr.split('&amp;'); var result = &#123;&#125;; for(var key in data) &#123; if(typeof data[key] == 'string') &#123; var barr = data[key].split('='); result[barr[0]] = barr[1]; &#125; &#125; console.log(result);&#125; 注意result[barr[0]] = barr[1];这里如果直接用result.barr[0] = barr[1];会报错。 一般流程其实回过了头来看，大部分的流程其实很类似，一般的流程都是这样： 创建一个匿名函数，代表一个功能 在函数内定义将要使用到的各种DOM节点，请求的url 在用jQuery找DOM节点的时候，多用find()方法，避免全局寻找节点。对应的标签用name属性来分辨 创建一个初始化方法：包括一系列的判断，事件绑定 在初始化方法里会用到一些请求，把请求包装成另外一个函数 在请求函数里，判断对应返回的数据进行DOM节点的更新 注意不要在异步请求里返回数据，要么直接在请求成功后的回调函数里处理，要么传入一个回调函数 某些需要被其他类使用的状态可以保存在类的公共变量里，在执行时都能使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/**获取页面求同款的详情*/var theme = new (function()&#123; var t = this; //在函数内定义将要使用到的各种DOM节点，请求的url t.url = 'http://m.seeapp.com/index.php/theme/getTheme?theme_id='; t.theme_box = $('#theme_box'); t.banner_box = t.theme_box.find('[name=banner_box]'); t.banner = t.theme_box.find('[name=banner]'); t.img = t.theme_box.find('[name=img]'); t.nick = t.theme_box.find('[name=nick]'); t.time = t.theme_box.find('[name=time]'); t.type = t.theme_box.find('[name=type]'); t.content = t.theme_box.find('[name=content]'); t.wish_list = t.theme_box.find('[name=wish_list]'); t.price_range = t.theme_box.find('[name=price_range]'); t.like_count = t.theme_box.find('[name=like_count]'); t.reply_count = t.theme_box.find('[name=reply_count]'); t.loading_box = $('#loading_box'); t.like_btn = $(\"#like_btn\"); t.reply_count_num = 0; t.adminBox = t.theme_box.find('[name=adminBox]'); t.isbyowner = t.theme_box.find('[name=isbyowner]'); t.replyBtnBox = t.theme_box.find('[name=replyBtnBox]'); //创建一个初始化方法：包括一系列的判断，事件绑定 //在初始化方法里会用到一些请求，把请求包装成另外一个函数 t.get_theme = function()&#123; $.getJSON(t.get_url(),function(ret)&#123; if(ret.result == 1)&#123; t.render_theme(ret.data); t.loading_box.hide(); t.theme_box.show(); &#125;else&#123; see.tips('OOPS！该内容获取不到...'); &#125; &#125;); &#125;; t.get_theme_id = function()&#123; var id = see.get_param('tid'); if($.isNumeric(id))&#123; return parseInt(id); &#125; return 0; &#125;; t.get_url = function()&#123; return t.url + t.get_theme_id(); &#125;; //对在请求函数里返回的数据进行DOM节点的更新 t.render_theme = function(dt)&#123; if(dt.theme)&#123; t.banner.attr('src', dt.theme.t_imgurl); t.nick.text(dt.theme.u_username); t.img.attr('src',dt.theme.u_headimg); t.time.text(see.format_time(dt.theme.t_time)); t.content.text(dt.theme.t_title); t.price_range.text(dt.theme.t_price); t.like_count.text(dt.theme.t_followcount); t.reply_count.text(dt.theme.t_findcount); t.reply_count_num = parseInt(dt.theme.t_findcount); t.type.text(parseInt(dt.theme.t_hunttype)==0?'求同款':'求搭配'); t.wish_list.text(dt.wanted[0].o_remark || dt.wanted[0].o_name); if(dt.theme.isbyowner) &#123; t.replyBtnBox.hide(); t.adminBox.show(); t.isbyowner.text(dt.theme.t_followcount); &#125; for(var k in dt.wanted[0].clue)&#123; var c = dt.wanted[0].clue[k]; var param = JSON.parse(c.cl_parameter); var span = $('&lt;span class=\"tag tag-'+param.direction+'\" style=\"left:'+parseFloat(param.x)*100+'%; top:'+parseFloat(param.y)*100+'%;\"&gt;&lt;i&gt;&lt;/i&gt;&lt;font&gt;'+param.title+'&lt;/font&gt;&lt;/span&gt;'); t.banner_box.append(span); &#125; &#125;; if (dt.isfollow) &#123; t.like_btn.addClass('liked'); &#125; else &#123; t.like_btn.removeClass('liked'); &#125; &#125;;&#125;); 微信JSSDK这次分享和图片预览用到了微信的SDK。 配置12345678910111213141516$.getJSON('http://m.seeapp.com/index.php/activity/getConfig?u='+encodeURIComponent(location.href), function(json)&#123; wx.config(json); wx.ready(function()&#123; var url = ''; var img = ''; var global_share_title = '你负责看，See负责找'; var desc = '你负责看，See负责找'; wx.onMenuShareTimeline(&#123; title: global_share_title, // 分享标题 link: url, // 分享链接 imgUrl: img, // 分享图标 success: function () &#123;&#125;, cancel: function () &#123;&#125; &#125;); &#125;);&#125;); 公司之前是写了一个接口，传入当前的url获取JSSDK的参数对象12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名，见附录1 jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2&#125;); 配置成功后就可以使用各种api了，最常用的是自定义分享的标题，图片。有时候需要在分享后做一些处理，就在回调函数里写一些东西，比如发送请求来统计等。12345678910t.image_preview = function (current_img) &#123; if (typeof WeixinJSBridge != 'undefined') &#123; WeixinJSBridge.invoke('imagePreview', &#123; 'current' : current_img, 'urls' : t.img_view_list &#125;); &#125; else &#123; //留个空给后面补齐非微信浏览器 &#125;&#125; 这个在旧版本的微信貌似可以使用，是图片预览插件。有时候可以用有时候不可以=。=","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://weibo.com/biousco/tags/JavaScript/"},{"name":"WXJSSDK","slug":"WXJSSDK","permalink":"http://weibo.com/biousco/tags/WXJSSDK/"}]},{"title":"移动端SeeApp开发总结-1","slug":"移动端SeeApp开发总结-1","date":"2015-08-26T13:37:11.000Z","updated":"2015-08-26T13:40:49.000Z","comments":true,"path":"2015/08/26/移动端SeeApp开发总结-1/","link":"","permalink":"http://weibo.com/biousco/2015/08/26/移动端SeeApp开发总结-1/","excerpt":"暑假在See实习：See 一张图片找到全球同款。进去之后接手的第一个项目是继续完成移动端版的App。需求有：登录，发表心愿，同求等等，主要是把整个流程都完成。年少无知的我以为只是重构点移动端页面，竟然说2天半可以完成（其实如果只是重构是真的够了）；然后Sheen一脸惊讶，拍拍肩膀：”你确定？”。最后给了我5天左右的时间。好，不废话了。其实主要做的东西就是ajax和后台交互，移动端文件上传。","text":"暑假在See实习：See 一张图片找到全球同款。进去之后接手的第一个项目是继续完成移动端版的App。需求有：登录，发表心愿，同求等等，主要是把整个流程都完成。年少无知的我以为只是重构点移动端页面，竟然说2天半可以完成（其实如果只是重构是真的够了）；然后Sheen一脸惊讶，拍拍肩膀：”你确定？”。最后给了我5天左右的时间。好，不废话了。其实主要做的东西就是ajax和后台交互，移动端文件上传。 Fiddler调试后台接口先介绍这个前端神器。 Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。 刚开始的时候不知道这货能干什么。从SVN拿到之前写了一半的H5（下面都这么叫）的代码后，直接打开index.html是没什么内容的，问了后台相关的人员，才知道是通过url上的参数来ajax提交获得数据再渲染到页面的。之前做的东西ajax都只是局部刷新，比如下拉菜单，搜索关键词提示；自己也有考虑过网页能不能不通过后台来渲染而直接是返回数据前端来填充呢？发现这不就是我想实现的前后端分离嘛~加上参数后发现还是没有数据。有跨域问题：js请求的后台接口和当前的index.html并不在同一个域名。这时候就要祭出大杀器Fiddler了。 按我的理解，Fiddler能把所有的请求和响应都收集起来，从本机发出的请求都通过Fiddler，从外面进来的响应也都通过Fiddler。除此之外，Fiddler能随意修改这些请求和响应。这点就是他强大的地方了。 打开Fiddler和生产环境下的H5：http://m.seeapp.com/see/static/detail/index.html?tid=10222。在Fiddler里能看到他捕捉到了连接到这个网站的所有请求。现在选择一个请求，是他所需要的js文件：detail.js，在右边的AutoResponder里选择add Rule，制定一系列规则，就能让Fiddler修改返回的这个js的文件了，再次刷新页面，此时页面所引用的js文件就是Fiddler修改过的js文件。那么这个规则是什么呢？就是指向我们本机的js文件。说白了就是开发环境的js。这样我们在本机的js文件里修改，马上就能反映在线上了。回到前面的问题，为什么要这么麻烦用Fiddler呢，因为在线上api接口都对上了，没有跨域问题。当然跨域问题也可以在服务端加上：Access-Control-Allow-Origin: *。不过服务端那边不能修改，所以我这边只能自力更生了。此外用Fiddler还有个好处，方便手机调试。具体方法如下： 在Fiddler里设置好各种文件的对应规则后，打开Fiddler允许外部设备连接的功能，设置好端口号。 让测试的手机端和PC端在同一个局域网下，设置手机端的HTTP代理服务器为PC端的IP地址，设置好端口号。 这样一来，手机发送的请求也会通过Fiddler，接受的请求也会通过Fiddler，所以手机端浏览到的页面就和PC端一样了。不需要把修改好的文件放上服务器再在手机端刷新 可以再延伸一下，由于Fiddler也能知道手机端发送的请求，所以一些App调用的后台请求接口也可以知道了；也可以修改请求的各种文件，比如还是js文件，然后加点代码啥的→_→，这样一些游戏可以写个小外挂出来哈哈哈哈（感谢贤哥）；Fiddler还能直接修改HOST文件，不用在系统文件那里修改。 js结构$(function (){...})在jQuery中，这个代表当DOM加载完成后要执行的函数，等价于$(document).ready()。每个不同的页面加载不同的js，每个js文件的结构大体如下：12345678$(function () &#123; var reply = new (function () &#123;...&#125;); var theme = new (function () &#123;...&#125;); setTimeout(function () &#123; reply.init(); theme.init(); &#125;,300)&#125;) 这是前辈的写法，感觉很新颖：把每个功能模块都通过匿名函数用类来实现，在最后统一进行初始化。虽然之前我也是用了类似的写法，但是每个类都是一个对象，在对象里面定义方法和变量觉得有点拘束；而这种匿名函数的写法就很自然了：123456789101112131415161718var reply = new (function () &#123; var t = this; //公共变量 t.user = ''; t.avater = ''; //私有变量 var _user = ''; t.init = function () &#123; t.setUser(t.getUser()); &#125; t.setUser = function (user) &#123; t.user = user; &#125;&#125;); 里面就很自由，定义私有变量/方法或者公共变量/方法都很方便。另外，虽然在整个运行的时候各个类可以互相调用，但是由于写在了DOM加载完成的匿名函数中，在执行外部（浏览器中）是访问不到这些变量的。要想暴露出来可以window.fun = fun。当然啦，还是有其他的写法也能实现这样的效果，现在比较喜欢这种。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"Ajax","slug":"Ajax","permalink":"http://weibo.com/biousco/tags/Ajax/"},{"name":"表单提交","slug":"表单提交","permalink":"http://weibo.com/biousco/tags/表单提交/"}]},{"title":"数据库入门-2","slug":"数据库入门-2","date":"2015-07-14T12:34:39.000Z","updated":"2015-08-26T13:41:44.000Z","comments":true,"path":"2015/07/14/数据库入门-2/","link":"","permalink":"http://weibo.com/biousco/2015/07/14/数据库入门-2/","excerpt":"Intermediate SQLJoin连接1234567891011-- join 连接 做笛卡儿积，然后筛选掉不符合条件的行-- join 要跟着 on 写连接的条件，不删除重复的列，删除有空值对应不上的行select * from instructor inner join teaches on instructor.ID = teaches.ID;select * from instructor, teaches where instructor.ID = teaches.ID;-- 这两句等价-- 作用：当某一项属性为空值-- 四种连接：inner join/left outer join/right outer join/full outer join-- outer join-- left outer join: 保留左边的表的所有行，右边没有的使用NULL-- right outer join: 保留右边的表所有行，左边没有的使用NULL-- full outer join: 保留左右两边的表的所有行，没有的值使用NULL","text":"Intermediate SQLJoin连接1234567891011-- join 连接 做笛卡儿积，然后筛选掉不符合条件的行-- join 要跟着 on 写连接的条件，不删除重复的列，删除有空值对应不上的行select * from instructor inner join teaches on instructor.ID = teaches.ID;select * from instructor, teaches where instructor.ID = teaches.ID;-- 这两句等价-- 作用：当某一项属性为空值-- 四种连接：inner join/left outer join/right outer join/full outer join-- outer join-- left outer join: 保留左边的表的所有行，右边没有的使用NULL-- right outer join: 保留右边的表所有行，左边没有的使用NULL-- full outer join: 保留左右两边的表的所有行，没有的值使用NULL View视图 视图提供一种机制向一些特定的用户来隐藏真实的数据 视图是虚拟的，并不创建真实的关系而是数据库引擎通过使用 SQL 语句来重建数据。因此视图总是显示最新的数据123456-- 视图create view departments_total_salary(dept_name, total_salary) as select dept_name, sum (salary) from instructor group by dept_name;-- 可以通过其他视图来创建视图-- 为了防止更新出错，大部分数据操作工具只允许在简单的视图上进行更新（插入约束，不被允许查看的值不允许为空，此时插入数据会失败） Transaction事务 包括一系列的查询和更新语句 Commit work（提交事务）和Rollback work（回滚事务） 后面详细说明 Integrity Constraints完整性约束 完整性约束保护数据库不被意外破坏 单个关系上的完整性约束 not null primary key unique check(P),where P is a predicate Referential Integrity参照完整性 Cascading Actions in Referential Integrity级联操作中的参照完整性 通过外码实现12345678create table course ( course_id char(5) primary key, title varchar(20), dept_name varchar(20) references department)；create table course ( dept_name varchar(20), foreign key (dept_name) references department on delete cascade on update cascade )","categories":[{"name":"计算机本科知识","slug":"计算机本科知识","permalink":"http://weibo.com/biousco/categories/计算机本科知识/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://weibo.com/biousco/tags/数据库/"}]},{"title":"数据库入门-1","slug":"数据库入门-1","date":"2015-07-13T08:28:40.000Z","updated":"2015-07-13T08:42:07.000Z","comments":true,"path":"2015/07/13/数据库入门-1/","link":"","permalink":"http://weibo.com/biousco/2015/07/13/数据库入门-1/","excerpt":"关系代数学 选择select（$\\sigma$） 选择符合所给的谓词条件的元组 $$\\sigma_{p} (r) = \\left \\{ t|t\\in r\\; and \\; p(t) \\right \\}$$ p是条件谓词 $$\\sigma_{deptname=”Physics”}(instructor)$$ 投影project（$\\prod$） 选择表中对应属性名的元组 $$\\prod_{A1,A2,A3…,Ak}(r)$$ A是属性名 $$\\prod_{deptname,salary}(instructor)$$","text":"关系代数学 选择select（$\\sigma$） 选择符合所给的谓词条件的元组 $$\\sigma_{p} (r) = \\left \\{ t|t\\in r\\; and \\; p(t) \\right \\}$$ p是条件谓词 $$\\sigma_{deptname=”Physics”}(instructor)$$ 投影project（$\\prod$） 选择表中对应属性名的元组 $$\\prod_{A1,A2,A3…,Ak}(r)$$ A是属性名 $$\\prod_{deptname,salary}(instructor)$$ 取并集union（$\\cup$） 减法set difference（-） 笛卡儿积Cartesian-Product（X） 重命名Rename 取交集Set-Intersection（$\\bigcap $） 自然连接Natural-Join（$\\triangleright\\! \\triangleleft $） SQL查询语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109create table Student (Sno char(5) not null, Sname varchar(20) unique, Ssex char(1));drop table student;delete from student;alter table student add time Datetime;alter table drop time;-- SQLServer不支持natural joinselect * from instructor natural join teaches.select name, course_id from instructor, teaches where instructor.ID = teaches.ID;-- natural join 默认选择具有相同值的属性列进行连接 删掉重复的列select name from instructor where name like '%char%' escape 'c';--order byselect distinct name from instructor order by nameselect distinct name from instructor order by name desc-- betweenselect name from instructor where salary between 900000 and 10000000select name from instructor where salary not between 900000 and 10000000-- union 相当于并集(select course_id from section where semester = 'Fall' and year = 2009)union(select course_id from section where semester = 'Spring' and year = 2010)-- intersect 相当于交集(select course_id from section where semester = 'Fall' and year = 2009)intersect(select course_id from section where semester = 'Spring' and year = 2010)-- except 相当于减法(select course_id from section where semester = 'Fall' and year = 2009)except(select course_id from section where semester = 'Spring' and year = 2010)-- union intersect except 默认自动删除重复的行 加上all 取消删除 但是SQLServer不支持all这种写法-- is null也是操作符select name from instructor where salary is null-- 聚合函数avg() min() max() sum() count()-- select 中出现聚集函数之外的属性必须在group by中也出现select dept_name, avg (salary) from instructor group by dept_name;-- having 中也可以出现where，但不能是select中的属性select dept_name, avg (salary) from instructor where ID = 'Biology' group by dept_name having avg (salary) &gt; 42000;-- Subqueries嵌套子查询-- in 和 not in/exis 和 not exis-- in 和 intersect 有相同的效果select distinct course_id from section where semester = 'Fall' and year= 2009and course_id in(select course_id from section where semester = 'Spring' and year= 2010);-- 等价(select course_id from section where semester = 'Fall' and year = 2009)intersect(select course_id from section where semester = 'Spring' and year = 2010)--Find courses offered in Fall 2009 but not in Spring 2010select distinct course_i from sectionwhere semester = ’Fall’ and year= 2009 and course_id not in(select course_id from section where semester = ’Spring’ and year= 2010);--查询与‘柳橙’在同一个系学习的学生。select id,name,dept from studentwhere dept in(select dept from student where name = '柳橙')-- exist 有点搞不懂 exist或者not exist是把主查询的字段传到后边的查询中作为条件，返回值是TRUE或者FALSE。EXISTS TRUE，那么就是查询条件成立，结果会显示出来。NOT EXISTS TRUE，则为FALSE，查询连接条件不成立。select course_id from section as Swhere semester = 'Fall' and year = 2009and exists(select * from section as Twhere semester = 'Spring' and year= 2010 and S.course_id= T.course_id)-- not exist 和 except 一起使用-- Find all students who have taken all courses offered in the Biology department.select distinct S.ID, S.name from student as Swhere not exists ((select course_id from course where dept_name = 'Biology')except(select T.course_id from takes as T where S.ID = T.ID));-- with 新建临时的表给下面的查询使用-- Find all departments where the total salary is greater than the average of the total salary at all departments.with dept_total (dept_name, value) as (select dept_name, sum(salary) from instructor group by dept_name), dept_total_avg(value) as (select avg(value) from dept_total) select dept_name from dept_total, dept_total_avg where dept_total.value &gt;= dept_total_avg.value-- delete/update/insertdelete from instructor where dept_name = 'Finance';update instructor set salary = salary * 0.1 where salary &gt; 10000;insert into course values (’CS-437’, ’Database Systems’, ’Comp. Sci.’, 4);","categories":[{"name":"计算机本科知识","slug":"计算机本科知识","permalink":"http://weibo.com/biousco/categories/计算机本科知识/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://weibo.com/biousco/tags/数据库/"},{"name":"SQLServer","slug":"SQLServer","permalink":"http://weibo.com/biousco/tags/SQLServer/"},{"name":"SQL","slug":"SQL","permalink":"http://weibo.com/biousco/tags/SQL/"}]},{"title":"计算机网络-运输层","slug":"计算机网络-运输层","date":"2015-07-11T13:49:25.000Z","updated":"2015-07-11T13:53:22.000Z","comments":true,"path":"2015/07/11/计算机网络-运输层/","link":"","permalink":"http://weibo.com/biousco/2015/07/11/计算机网络-运输层/","excerpt":"三个重要问题：滑动窗口、流量控制、拥塞控制运输层为相互通信的应用进程提供逻辑通信 运输层协议 复用：发送方不同的应用进程都可以使用同一个运输层协议传输数据 分用：接收方的运输层在剥去报文的首部后能把这些数据正确交付目的应用进程 对数据部分进行差错检测 运输层的两个主要协议 用户数据报协议UDP 传输控制协议TCP UDP传送数据前不需要建立连接，不给出确认，不可靠交付 TCP提供面向连接的服务，传送前建立连接，结束后释放连接，不广播，不多播，可靠交付。用在：电子邮件，远程终端接入（TELNET），万维网，文件传送 运输层的端口 运输层使用协议端口号来识别进程 报文中的头部都有源端口和目的端口 服务器端的端口号：0~1023：常用端口号；1024~49151：登记端口号 客户端的端口号：49152~65535：短暂端口号","text":"三个重要问题：滑动窗口、流量控制、拥塞控制运输层为相互通信的应用进程提供逻辑通信 运输层协议 复用：发送方不同的应用进程都可以使用同一个运输层协议传输数据 分用：接收方的运输层在剥去报文的首部后能把这些数据正确交付目的应用进程 对数据部分进行差错检测 运输层的两个主要协议 用户数据报协议UDP 传输控制协议TCP UDP传送数据前不需要建立连接，不给出确认，不可靠交付 TCP提供面向连接的服务，传送前建立连接，结束后释放连接，不广播，不多播，可靠交付。用在：电子邮件，远程终端接入（TELNET），万维网，文件传送 运输层的端口 运输层使用协议端口号来识别进程 报文中的头部都有源端口和目的端口 服务器端的端口号：0~1023：常用端口号；1024~49151：登记端口号 客户端的端口号：49152~65535：短暂端口号 用户数据报协议UDPUDP概述 特点：无连接，尽最大努力交付，面向报文，没有拥塞控制，支持一对一，一对多，多对一和多对多的交互通信，首部开销小 面向报文：UDP对应用层交下来的报文不合并也不拆分。应用程序必须选择合适大小的报文，否则会IP分片 UDP首部格式 数据字段和首部字段，8个字节 源端口/目的端口/长度（UDP用户数据报的长度）/校验和 如果目的端口号不正确，丢弃报文 控制传输协议TCP概述TCP最主要特点 面向连接 每一条TCP只能有两个端点，都是点对点的 提供可靠交付服务：无差错不丢失不重复按序到达 全双工通信 面向字节流 TCP根据对方的窗口值和当前网络拥塞的程度决定一个报文段有多少字节 TCP的连接 端点就是套接字（socket）：端口号拼接到IP地址 每一条TCP连接唯一地被通信两端的两个套接字所确定 可靠传输的工作原理停止等待协议 每发送完一个分组就停止发送，等待对方的确认。收到确认后再发送下一个分组 出现差错 接收方检测出差错，丢弃分组 发送方超过一段时间没有收到确认，就重传前面发送过的分组。这就是超时重传 每发送完一个分组就设置一个超时计时器 发送完分组后会暂时保留已发送的分组的副本 分组和确认分组都有一个编号 超时计时器设置的重传时间应当比数据在分组传输的评价往返时间更长一点 即使受到重复的分组也要发送确认；收到重复的确认分组就要丢弃 这种可靠传输协议成为自动重传请求ARQ 为了提高效率，不再发送完分组就等待确认，采用流水线传输，连续发送多个分组 使用流水线分组就用连续ARQ协议和滑动窗口协议 连续ARQ协议 发送方维持发送窗口：位于发送窗口内的5个分组都可以连续发送出去，不需要等待对方的确认 按分组序号从小到大发送 每收到一个确认，就把发送窗口向前滑动一个分组的位置 接收方使用累积确认，收到几个分组后，对按序到达的最后一个分组发送确认 TCP可靠传输的实现以字节为单位的滑动窗口 TCP的滑动窗口以字节为单位 确认报文段包含：窗口，确认号。发送号根据这个构造自己的发送窗口 发送窗口一般只会向前移动（收到了新的确认）或者不动（没有收到新的确认） 向后收缩是因为对方通知的窗口缩小了，但标准不赞成这么做 有三个指针，ACK,SND,ACK+Window-1，表示已发送/已确认和已发送/未确认和未发送/允许发送和未发送/不允许发送 接受窗口类似。接受方只能对按序收到的数据中的最高序号给出确认，发送的确认号就是期望收到的序号 接受到数据后，接受窗口将数据交付主机，接受窗口向前移动，给发送方发送确认。 如果发送窗口的序号用完，但没有收到确认，那么必须停止发送 发送方的发送窗口根据接收方的接受窗口设置，还会受到网络状态的影响 不按序到达的数据会临时存放在接受窗口中 接收方必须要有累积确认的功能，减小传输开销 超时重传时间的选择 TCP最复杂的问题之一 报文段的往返时间RTT：报文段发出的时间和收到相应的确认的时间之差 加权平均往返时间RTTs：新的RTTs = （1 - α）x（旧的RTTs） + α x （新的RTT样本）α为1/8 超时重传时间RTO：RTO = RTTs + 4 x RTTdRTTd是RTT的偏差的加权平均值：新的RTTd = （1 - β）x（旧的RTTd） + β x |RTTs - 新的RTT样本|β为0.25 计算RTTs时，只要报文段重传了，就不采用其往返时间样本 报文重传一次，新的重传时间为2倍的旧的重传时间，当不再发生报文段的重传时，才使用公式计算时间；这叫Karn算法 选择确认SACK 能否只传送缺少的数据而不重传已经正确到达的数据？ 可以，使用SACK。在TCP首部加上允许SACK的选项 TCP的流量控制利用滑动窗口实现流量控制 流量控制：让发送方的发送速率不要太快，让接收方来得及接收 TCP的拥塞控制拥塞控制的原理 **防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载 拥塞控制方法慢开始和拥塞避免发送方维持一个拥塞窗口cwnd，发送方让自己的发送窗口等于拥塞窗口。网络没有拥塞，窗口增大一点，否则减小，减少注入到网络中的分组数 慢开始：由小到大逐渐增大发送窗口（拥塞窗口），每收到一个新的报文段的确认后，拥塞窗口增加至多一个报文段的数值 每经过一个传输轮次，拥塞窗口就会加倍（1-&gt;1;2-&gt;2;4-&gt;4） 为了防止拥塞窗口cwnd增长过快，设置一个慢开始门限ssthresh 未超过门限，使用慢开始，超过使用拥塞避免，相等时都可以 拥塞避免：每经过一个RTTcwnd增加1而不是加倍 只要出现拥塞，门限设置为出现拥塞时的发送方窗口值的一半，cwnd设置为1，慢开始 这两种算法就是AIMD：加法增大，乘法减小 拥塞判断：没有按时收到确认","categories":[{"name":"计算机本科知识","slug":"计算机本科知识","permalink":"http://weibo.com/biousco/categories/计算机本科知识/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://weibo.com/biousco/tags/计算机网络/"},{"name":"运输层","slug":"运输层","permalink":"http://weibo.com/biousco/tags/运输层/"}]},{"title":"计算机网络-网络层-2","slug":"计算机网络-网络层-2","date":"2015-07-06T12:40:36.000Z","updated":"2015-07-11T13:50:53.000Z","comments":true,"path":"2015/07/06/计算机网络-网络层-2/","link":"","permalink":"http://weibo.com/biousco/2015/07/06/计算机网络-网络层-2/","excerpt":"因特网的路由选择协议路由选择协议 理想路由算法 算法是正确的，完整的 在计算上简单 自适应性 稳定性 公平的 最佳的 分层次的路由选择协议 因特网采用自适应，分布式路由选择协议 两大类：内部网关协议IGP和外部网关协议EGP IGP(Interior Gateway Protocol)：包括RIP和OSPF等 EGP(External Gateway Protocol)：目前使用BGP 内部网关协议RIP（Routing Information Protocal）工作原理 路由信息协议，基于距离向量的路由选择协议，优点是简单 从一路由器到直接连接的网络的距离定义为1，距离也称为跳数 一条路径最多包含15个路由器，16代表不可达，因此用于小型互联网 只选择最短路由，哪怕有一条高速但多路由器的路由 分布式路由选择协议，不断地和其他路由器交换信息 协议特点 仅和相邻路由器交换信息 交换的信息是当前本路由知道的全部信息（路由表） 按固定的时间间隔交换信息（30秒） 距离向量算法对于每一个相邻路由器发过来的RIP报文，进行下列步骤： 对地址为X的路由器发来的RIP报文，先修改报文的所有项目：“下一跳”改为X，所有距离加一。每个项目有三个数据：到达目的网络N，距离d，下一跳路由器是X 对修改后的每一个项目 如果原来的路由表没有目的网络N，加入路由表 否则如果有目的网络，下一跳地址也是X，更新路由表 否则如果有目的网络，下一跳不是X，查看距离，更新路由表 RIP协议使得从每一个路由器到每一个目的网络的路由都是最短的","text":"因特网的路由选择协议路由选择协议 理想路由算法 算法是正确的，完整的 在计算上简单 自适应性 稳定性 公平的 最佳的 分层次的路由选择协议 因特网采用自适应，分布式路由选择协议 两大类：内部网关协议IGP和外部网关协议EGP IGP(Interior Gateway Protocol)：包括RIP和OSPF等 EGP(External Gateway Protocol)：目前使用BGP 内部网关协议RIP（Routing Information Protocal）工作原理 路由信息协议，基于距离向量的路由选择协议，优点是简单 从一路由器到直接连接的网络的距离定义为1，距离也称为跳数 一条路径最多包含15个路由器，16代表不可达，因此用于小型互联网 只选择最短路由，哪怕有一条高速但多路由器的路由 分布式路由选择协议，不断地和其他路由器交换信息 协议特点 仅和相邻路由器交换信息 交换的信息是当前本路由知道的全部信息（路由表） 按固定的时间间隔交换信息（30秒） 距离向量算法对于每一个相邻路由器发过来的RIP报文，进行下列步骤： 对地址为X的路由器发来的RIP报文，先修改报文的所有项目：“下一跳”改为X，所有距离加一。每个项目有三个数据：到达目的网络N，距离d，下一跳路由器是X 对修改后的每一个项目 如果原来的路由表没有目的网络N，加入路由表 否则如果有目的网络，下一跳地址也是X，更新路由表 否则如果有目的网络，下一跳不是X，查看距离，更新路由表 RIP协议使得从每一个路由器到每一个目的网络的路由都是最短的 RIP协议的报文格式 RIP2是新版本，改进性能，支持CIDR和变长子网掩码，多播 使用运输层的用户数据报UDP进行传送（UDP的端口520） 报文由首部和路由组成 首部4字节，包括命令，版本，和一个0保证四字节对齐 路由部分由若干个路由信息组成，20字节。包含地址族标识符，路由标记，后面是网络地址，子网掩码，下一跳路由地址，距离。重复出现最多25个 问题：网络出现故障时，需要较长时间才能传送到所有路由器（栗子很有趣） 特点：好消息传的快，坏消息传得慢 优点：实现简单，开销较小 缺点：限制网络规模；随着规模扩大，开销增加 规模小的网络适合 内部网关协议OSPF（Open Shortest Path First）协议基本特点 开放最短路径优先 使用分布式的链路状态协议 与RIP的不同之处： 用洪泛法（flooding）向本自治系统中的所有路由器发送信息 发送的信息是与本路由器相邻的所有路由器的链路状态。链路状态还包括“度量”（metric） 只有当链路状态发生变化时，才使用洪泛法发送信息 所有路由器都能建立链路状态数据库，也就是全网的拓扑结构图 每一个路由器使用链路状态数据库中的数据构造自己的路由表（迪杰斯特拉算法） OSPF会将一个自治系统划分为若干个更小的范围，叫做区域，每个区域有32位的标识符 划分区域的好处是洪泛法交换信息的范围局限于一个区域，减少通信量 OSPF使用层次结构的划分 区域边界路由器 主干路由器 自治系统边界路由器 使用IP数据报传送，很短 特点 允许管理员给每条路由指定代价 如果有多条代价相同的路径，可以将通信量分配给这几条路径。即负载均衡 所有在OSPF路由器之间交换的分组都有鉴别的功能 支持可变长的子网划分和CIDR 每一个链路状态都有一个32位的序号，增长速率不超过5秒1次。 只要一个路由器的链路状态发生变化，就用洪泛法向全网更新链路状态 每30分钟刷新一次数据库的链路状态 五种分组类型 问候分组，发现和维持邻站的可达性 数据库描述分组，给邻站自己的链路状态数据库中的链路状态项目 链路状态请求分组，向对方请求链路状态项目 链路状态更新分组，洪泛法，最复杂，最核心的部分 链路状态确认分组 外部网关协议BGP 使用原因 因特网规模太大，使得AS之间路由选择太难 AS之间的路由选择必须考虑有关策略 每一个自治系统的管理员要选择至少一个路由器作为“BGP发言人”。两个BGP发言人通过一个共享网络连接在一起，发言人一般是BGP边界路由器 要交换路由信息，先建立TCP连接，在此连接上交换BGP报文以建立BGP会话 使用TCP连接能提供可靠的服务，简化了路由选择协议 使用TCP连接交换路由信息的两个BGP发言人，彼此成为对方的邻站或对等站 每一个BGP发言人处理必须运行BGP协议外，还必须运行内部网关协议 交换的信息是到达某个网络所要经过的一系列自治系统 BGP支持无分类域间路由选择CIDR，因此路由表包括网络前缀，下一跳路由器，以及到达该面对网络所要经过的自治系统序列 四种报文 OPEN报文：建立关系，通信初始化 UPDATE报文，报告路由信息，列出要撤销的路由 KEEPALIVE报文，周期性证实邻站连通性 NOTIFICATION报文，发送检测到的差错 报文过程 先发送OPEN报文 如果接受，用KEEPALIVE相应 然后周期性地交换KEEPALIVE报文 UPDATE报文可以撤销通知过的路由，也可以增加新的路由；撤销可以多条，增加只能一条 能解决“坏消息传播得慢” 路由器的构成路由器的结构 多个输入端口和多个输出端口的专用计算机 任务是转发分组 两部分结构：路由选择和分组转发 路由选择 核心构件是路由选择处理机 任务是根据所选定的路由选择协议构造路由表，定期和相邻路由器交换路由信息而不断更新和维护路由表 分组转发 由交换结构，输入端口和输出端口组成 交换结构：根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去 输入输出各有三个模块：物理层，数据链路层，网络层 网络层中有缓冲区","categories":[{"name":"计算机本科知识","slug":"计算机本科知识","permalink":"http://weibo.com/biousco/categories/计算机本科知识/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://weibo.com/biousco/tags/计算机网络/"},{"name":"网络层","slug":"网络层","permalink":"http://weibo.com/biousco/tags/网络层/"}]},{"title":"计算机网络-网络层-1","slug":"计算机网络-网络层-1","date":"2015-07-06T12:40:30.000Z","updated":"2015-07-12T12:55:46.000Z","comments":true,"path":"2015/07/06/计算机网络-网络层-1/","link":"","permalink":"http://weibo.com/biousco/2015/07/06/计算机网络-网络层-1/","excerpt":"网络层提供的两种服务 电信网：面向连接，可靠传输，虚电路 因特网：网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务","text":"网络层提供的两种服务 电信网：面向连接，可靠传输，虚电路 因特网：网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务 网际协议IP 是TCP/IP体系中最重要的协议之一 配套使用另外三个协议： 地址解析协议ARP 网际控制报文协议ICMP 网际组管理协议IGMP IP使用ARP，ICMP和IGMP使用IP 虚拟互联网络 中间设备 物理层：转发器 数据链路层：网桥或桥接器 网络层：路由器 网络层以上：网关 利用IP协议使性能各异的网络在网络层上看起来好像是一个统一的网络 分类的IP地址IP地址及其表示方法 编址方法的三个阶段 分类的IP地址 子网的划分 构成超网 分类IP地址 由两个固定长度的字段组成：网络号和主机号 一个IP地址在整个因特网范围内是唯一的 由ICANN进行分配，32位标识符 A，B，C类地址分别是1，2，3字节长，网络号字段的最前面有1~3位的类别位，数值分别是0，10，110 一共4个字节长 D类地址用于多播，前四位是1110；E类地址保留为今后所用，前四位是1111 现在已经用无分类IP地址，不使用这种方法了 IP地址不仅仅指明一个主机，还指明主机所连接到的网络 点分十进制记法：每八位插入一个点，把二进制换为十进制 IP地址指派范围 特殊IP地址 IP地址特点 IP地址管理机构只分配网络号 路由器仅根据网络号转发分组，减少路由表的空间和查表时间 主机连接到两个网络以上时，就具有两个相应的IP地址 用转发器或网桥连接起来的若干个局域网仍为一个网络 路由器有两个或两个以上的IP地址 IP地址与硬件地址 IP地址放在IP数据报的首部，硬件地址放在MAC帧的首部 数据链路层看不见数据报的IP地址 路由器只根据目的站的IP地址的网络号进行路由选择 IP数据报的源地址和目的地址一直不改变 MAC帧在不同网络传送时，首部中的源地址和目的地址要发生变化，但IP层却不知道 地址解析协议ARP 知道一个机器的IP地址来找出硬件地址 解决方法是：在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，这个映射表经常动态更新 每个主机都有ARP高速缓存（ARP cache），里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表 具体过程： 主机A向本局域网的B发送数据报时，在ARP cache中看有没有B的IP地址，有的话查出硬件地址，改写MAC帧的源地址和目的地址，发送这个MAC帧 如果没有（B刚入网，A刚加电，高速缓存是空的），运行ARP，找出硬件地址 ARP运行 ARP进程在本局域网广播发送ARP请求分组，包含的信息：主机的IP地址和硬件地址，需要知道某个IP地址的硬件地址 局域网内所有主机都接受到，如果其他主机的IP地址和请求分组请求的IP地址不一样，就不理睬 如果IP地址和请求的IP地址一致，接受这个请求分组，并向源主机发送相应分组，包含信息：IP地址和硬件地址。这是一个单播 源主机接收到响应分组后，向高速缓存中写入映射 目的主机也会把源主机中的请求分组中的映射写入高速缓存 每一个映射项目都有生存时间，10~20分钟 ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题 不在同一个局域网上的是通过路由器的转发表，找出下一跳的路由器，然后才用ARP找出下一跳的路由器的硬件地址 为何需要IP地址和ARP来找出硬件地址？直接硬件地址转发不好吗？ 世界上有各种网络，使用不同的硬件地址 由于1，主机和用户需要非常复杂的硬件地址转换工作，不可能 IP数据报的格式 以4个字节为单位进行描述 由首部和数据两部分组成。首部前一部分是固定长度，20字节；后面是可选字段，长度可变 IP数据报首部的固定本分中的各字段 版本：4位，IP协议的版本（IPv4或IPv6） 首部长度：4位，单位是32位字（4字节），所以最小值是5（IP首部长度为20字节），最多15，60字节。最常用就是5，（0101） 区分服务：8位，使用区分服务才用 总长度：16位，首部和数据之和的长度 由于数据链路层的最大传送单元MTU的限制，如果传送的数据报长度超过MTU，那么必须分片 IP数据报越短，路由器转发越快 IP数据报越长，传输效率越高 分片后总长度代表分片后每一个分片的首部长度与该分片的数据长度的总和 标识(identification)：16位，使分片后的各数据报片能正确地重装，存放着IP软件在存储器中的计数器的值，计数器每产生一个数据报就加1 标志(flag)：3位，两位有意义 最低位是MF（More Fragment）。MF=1代表还有分片，MF=0代表这是数据包片中的最后一个 中间一位是DF（Dont’t Fragment）。不能分片，DF=0时才允许分片 片偏移：13位，较长的分组在分片后，某片原分组中的相对位置。以8个字节为单位 计算：先确定首部长度（一般是20字节），然后划分数据长度 片偏移 = 数据开始的字节号 / 8 要修改有关字段的值：总长度，MF，DF，片偏移 如果某个报片经过某个网络还需要分片，片偏移计算公式仍然不变 生存时间：8位，TTL，数据报在网络中的寿命。防止无法交付的数据报无限制地在因特网中兜圈子。以前是以秒作为单位，TTL为0时丢弃；如今是跳数限制，表明可以经过多少个路由器，最多255。设置为1代表只能在局域网中传送。为0时被路由器丢弃。 协议：8位，指出此数据报携带的数据是何种协议。IP是4，TCP是6，UDP是17，IPv6是41 首部检验和：16位，只检验数据报首部，不包括数据部分；不使用CRC，另外一种算法： 首部分为16位字的序列，检验和字段置为0 反码运算把16位字相加后，得到的和的反码写入检验和字段 接收方做同样的事，（但这时检验和不是0），如果16位字相加后的反码是0说明没有差错，否则丢弃 源地址：32位 目的地址：32位 IP层转发分组的流程 分组在互联网上转发分组时，是从一个路由器转发到下一个路由器 IP数据报最终一定可以找到目的主机所在目的网络上的转发器 只有到达最后一个路由器时，才向目的主机进行直接交付 分组转发算法 从数据报首部提取目的主机IP地址D，得出网络地址N 如果N就在与路由器相连的某个网络地址，直接交付（ARP转换为硬件地址，封装MAC帧，发送帧），否则简介交付 如果有目的地址为D的特定主机路由，就传送数据报给路由指明的下一跳路由器 如果有到N的路由，就传送数据报给路由指明的下一跳路由器 如果有默认路由，就传送数据报给路由指明的默认路由器 报告转发出错 划分子网和构造超网划分子网 为何划分 IP地址空间利用率有时候很低 给每一个物理网络分配一个网络号会使路由表变得太大使网络性能变坏 两级IP地址不够灵活 划分子网思路 单位可以将物理网络划分为若干个子网，对外仍然表现为一个网络 划分的方法是从网络的主机号借用若干位作为子网号IP地址 ::= { &lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt; } 路由器仍然根据IP数据报的目的网络号找到路由器，但路由器接收到后，按照目的网络号和子网号找到目的子网，再将IP数据报交给主机 子网掩码 不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位与运算，就能得出网络地址 如果一个网络不划分子网，那么子网掩码就使用默认子网掩码 默认子网掩码就是分类地址中的网络号全为255，其余为0：A类：255.0.0.0，转为二进制就是11111111|00000000|00000000|00000000。C类就是255.255.255.0 子网划分有多种方法，确定好子网号的位数就能求出子网掩码和子网数，每个子网的主机数：（B类地址为例，使用固定长度子网） 子网号位数为2，说明子网掩码是：11111111|11111111|11000000|00000000 也就是255.255.192.0 子网数是11这两位取所有的取值，00 01 10 11 由于不能有全0和全1的情况，所以子网数为2，也就是2^n-2种子网 子网的主机数：000000|00000000这里取最大值减去2，16382 现在全1和全0的子网号也可以使用 划分子网增加了灵活性，却减少了能够连接在网络上的主机总数 同样的IP地址和不同的子网掩码可以得出相同的网络地址 使用子网时分组的转发 使用子网划分后，路由表必须包含：目的网络地址，子网掩码，下一跳地址 和之前的分组转发算法不同的是：分析转发表中的地址时，用各网络的子网掩码和目的IP地址逐位与操作，看是否与网络地址匹配 无分类编址CIDR（构成超网）网络前缀 由变长子网掩码VLSM研究而来，正式名称是无分类域间路由选择CIDR 消除了A,B,C类地址和子网划分的概念 32位地址划分为网络前缀和主机号，还使用斜线记法，斜线后面是网络前缀所占的位数128.14.35.7/20 = 10000000 00001110 00100011 00000111前20位是网络前缀 网络前缀都相同的连续IP地址组成CIDR地址块 求最大地址和最小地址：主机号都置0和置1之间的范围 CIDR使用32位的地址掩码，也可以称为子网掩码，斜线后面的数字就是地址掩码中1的个数 路由聚合：由于一个CIDR地址块中有很多地址，所以在路由表中利用CIDR地址块查找目的网络，地址的聚合称为路由聚合，也叫构成超网 能有效分配IPv4的资源，一般地址块包含多个C类地址 最长前缀匹配 路由表项目改变：由网络前缀和下一跳地址组成 由于查找路由表会有多个结果，选择的时候是从匹配结果中选择具有最长网络前缀的路由，即最长前缀匹配 将目的IP地址和路由表中的项目的掩码逐位相与，查看哪个匹配最长 二叉线索查找路由表 把路由表存放在二叉线索中，自上而下按层次进行查找 搜索到叶节点时将目的地址和该叶子节点的子网掩码进行按位与运算看是否匹配 为了提高技术还是用了压缩技术","categories":[{"name":"计算机本科知识","slug":"计算机本科知识","permalink":"http://weibo.com/biousco/categories/计算机本科知识/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://weibo.com/biousco/tags/计算机网络/"},{"name":"网络层","slug":"网络层","permalink":"http://weibo.com/biousco/tags/网络层/"}]},{"title":"计算机网络-数据链路层","slug":"计算机网络-数据链路层","date":"2015-07-06T12:37:16.000Z","updated":"2015-07-13T04:11:37.000Z","comments":true,"path":"2015/07/06/计算机网络-数据链路层/","link":"","permalink":"http://weibo.com/biousco/2015/07/06/计算机网络-数据链路层/","excerpt":"引言信道类型 点对点信道：一对一方式 广播信道：一对多方式 点对点信道数据链路和帧链路：从一个节点到相邻节点的物理线路，中间没有其他交换节点数据链路：链路的基础上加上通信协议，把实现这些协议的硬件和软件加到链路上网络适配器（网卡）来实现这些协议通信主要步骤： A的数据链路层吧网络层交下来的IP数据报添加首部和尾部封装成帧 发送给B的数据链路层 若B收到的帧无差错，就提取出IP数据报给网络层，否则丢弃 三个基本问题封装成帧，透明传输，差错检测 封装成帧 在数据前后添加首部和尾部，同时根据这个判断帧的开始和结束，即帧定界 帧是数据链路层的数据传送单元 链路层协议规定了数据部分长度上限–MTU（最大传送单元，Maximum Transfer Unit） 如果数据是ASCII码文件，使用帧定界符：SOH（Start Of Header）表示帧首部的开始，EOT（End Of Transmission）表示帧的结束。二进制编码是01和04 数据传输出现差错时通过判断帧定界符来判断是否是一个完整的帧","text":"引言信道类型 点对点信道：一对一方式 广播信道：一对多方式 点对点信道数据链路和帧链路：从一个节点到相邻节点的物理线路，中间没有其他交换节点数据链路：链路的基础上加上通信协议，把实现这些协议的硬件和软件加到链路上网络适配器（网卡）来实现这些协议通信主要步骤： A的数据链路层吧网络层交下来的IP数据报添加首部和尾部封装成帧 发送给B的数据链路层 若B收到的帧无差错，就提取出IP数据报给网络层，否则丢弃 三个基本问题封装成帧，透明传输，差错检测 封装成帧 在数据前后添加首部和尾部，同时根据这个判断帧的开始和结束，即帧定界 帧是数据链路层的数据传送单元 链路层协议规定了数据部分长度上限–MTU（最大传送单元，Maximum Transfer Unit） 如果数据是ASCII码文件，使用帧定界符：SOH（Start Of Header）表示帧首部的开始，EOT（End Of Transmission）表示帧的结束。二进制编码是01和04 数据传输出现差错时通过判断帧定界符来判断是否是一个完整的帧 透明传输 传输的数据中不可以包含帧定界符 非ASCII码文件会出现帧定界符 透明的意思是什么数据都能通过这个数据链路层。某一个实际存在的事物看起来却好像不存在一样，数据看不见那个帧定界符 解决方法：发送时在数据中出现SOH和EOT的前面插入转义字符ESC（十六进制是1B），接受时在送往网络层之前删掉这个转义。如果数据中有也有转义，再插入一个转义 差错检测 CRC计算 FCS是冗余码 除法：数据加上（除数-1）位的0；模2除法，看头部，1就上1，0就上0；减法不同为1，相同为0；取出余数 CRC只保证帧的无差错接受，即接受的帧都是几乎没有差错的 传输差错：比特差错；帧丢失，帧重复，帧失序； CRC实现无比特差错的传输，但不是可靠传输 历史上有帧编号，确认和重传机制，后来因为科技的发达。链路质量提高，取消了，能提高通信效率 点对点协议PPP计算机和ISP进行通信时使用的数据链路层协议 PPP协议的组成 一个将IP数据报封装到串行链路的方法 一个用来建立，配置和测试数据链路连接的链路控制协议LCP 一套网络控制协议NCP PPP协议的帧格式各字段意义首部：4个，尾部：2个F是标识字段，表示一个帧的开始或结束，0x7E，连续两帧只用一个标志字段A是地址字段，C是控制字段。这两个没有意义协议字段两个字节：0x0021代表信息字段是IP数据报信息字段长度可变，不超过1500字节FCS是CRC的帧校验序列F A C 协议 信息部分 FCS F 字节填充 异步传输 转义字符为0x7D，字节填充 因为标志字段是7E，所以一个7E就变成7D和5E 如果出现了7D（转义字符），7D就变成7D和5D 如果有ASCII控制字符（小于0x20），出现0x03变成7D和23 EX：7D 5E FE 27 7D 5D 7D 5D 65 7D 5E =&gt; 7E FE 27 7D 7D 65 7E 好像只要发现有D 5，那么就合并这两个，去掉D5 0比特填充 同步传输，使用SONET/SDH链路 扫描信息字段，连续五个1填入一个0 接收方会把连续的五个1后的0删除 PPP协议的工作状态 4个状态：链路静止，链路建立，鉴别，网络层协议，链路打开 广播信道的数据链路层 双绞线是局域网中的主流传输媒体 共享信道的两个方法：静态划分信道和动态媒体接入控制（随机接入，受控接入） CSMA/CD协议 总线的特点：总线上的所有计算机都能检测都这个数据，也就是广播通讯 以太网采取的措施 无连接的工作方式：不必建立连接就可以发送数据。 以太网采取尽最大努力的交付，不可靠的交付 使用曼彻斯特编码 使用集线器的双绞线以太网，物理上是星形网，逻辑上是总线网 协议要点 多点接入：总线型网络 载波接听：检测总线上有没有其他计算机也在发送。不管是在发送前还是在发送中，每个站都不停检测 碰撞检测：边发送边监听。如果有两个站在同时发送数据，就产生了碰撞 由于电磁波在总线上是以有限的速率传播的，所以数据在总线上会出现碰撞 局域网最多经过两倍的总线端到端的传播时延 一个站不能同时发送和接收，但必须边监听信道，所以进行半双工通信 争用期：碰撞窗口，端到端的往返时间2r，只有经过争用期这段时间还没有碰撞，才能肯定发送不会发生碰撞 截断二进制指数退避 有个k和r。k=Min[重传次数,10]；r=random(0~2k-1)[2的k次方-1] 重传时间是r倍的争用期 争用期是512比特时间。1比特时间就是发送一个比特所需要的时间 强化碰撞 当发生碰撞时，立即停止发送数据，并且发送32bit或64bit的认为干扰信号 让所有用户知道发生碰撞 帧最小间隔是9.6微秒，96比特时间，让接收站缓存来得及清理 广播信道的以太网MAC层的硬件地址 固化在适配器的ROM中的地址 6个字节地址字段 MAC帧格式 五个字段|---6---|--6--|-2--|--46~1500-|-4-||目的地址|源地址|类型|数据数据数据|FCS| 类型字段用来表示上一层用什么协议 当数据字段长度小于46字节时，会插入一个整数字节 实际传送的帧还要多8个字节。7个字节是前同步码，使接收端的适配器在接受MAC帧时能迅速调整时钟频率，使它和发送端的时钟同步（位同步）；最后一个字节是帧开始定界符 以太网传送数据以帧为单位传送，传送帧时，各帧之间有一定的间隙。因此以太网不需要帧结束定界符，也不需要使用字节插入保证透明传输 无效帧： 帧的长度不是整数个字节 FCS查出有错 数据字段不再46~1500字节之间。因此MAC帧长度在64~1518之间 无效帧直接丢弃 拓展以太网物理层 使用光纤和光纤调制解调器，进行电信号和光信号的转换，可以使主机和集线器相连接 使用多个集线器连接成多级星系结构的以太网 一个以太网是一个独立的碰撞域，多个以太网互联后会变成一个碰撞域，这时最大吞吐量只有一个以太网的吞吐量。意思就是某个以太网内的两个站在通信时所传送的数据会通过所有的集线器进行转发，其他以太网内不能通信（会碰撞） 不用以太网技术不能用集线器相连 数据链路层 使用网桥，它根据MAC帧的目的地址对收到的帧进行转发和过滤 两个以太网通过网桥连接起来后便成为更大的以太网，原来的以太网成为网段 网桥依靠转发表来转发帧：查找转发表，如果在不同接口，就转发到不同网段，否则丢弃这个帧 网桥通过内部接口管理软件和网桥协议实体完成操作 网桥好处： 过滤通信量，增大吞吐量。网桥可以使网段成为隔离开的碰撞域 扩大物理范围/提高可靠性 可互联不通物理层，MAC层和不同速率的以太网 网桥缺点： 对接受的帧要存储和查找转发表，然后执行CSMA/CD算法，才转发，增加了时延 没有流量控制，可能导致缓存溢出，帧丢失 用户数不能过多，传播过多会造成广播风暴 网桥转发帧时不改变帧的源地址 透明网桥 以太网上的站点不知道所发送的帧将经过哪几个网桥 是即插即用设备 不需要人工配置转发表 自学习算法 网桥每接收到一个帧，记下源地址和进入网桥的接口 帧的源地址写在转发表的地址中 转发帧时根据收到的帧中的目的地址进行转发 此时目的地址就是前面的源地址 网桥是存储转发方式工作的，先把整个帧接受（集线器和转发器是按比特转发）再进行处理，不管目的地址是什么 丢弃CRC检错/帧长过长/短的帧 转发过程： 在初始化中，网桥接受到一个帧，会记录下源地址以及接口，然后转发到其他所有接口，即使帧的目的地址和源地址在同一个网段 如果在一个网段中有目的地址以及另外一个网桥，另外一个网桥还是会接受到转发的帧，这是为了记录并学习下来 如果转发表中已经包含目的地址的接口，直接舍弃 转发表中还会写入帧进入网桥的时间，为了使转发表能反映网络拓补的最新状态。接口管理软件会在一定时间内删除转发表中的项目 生成树算法 互联在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集，这个子集里不存在回路 避免帧在网络中兜圈子 一定时间会对生成树拓扑进行更新 源路由网桥 发送帧时把详细的路由信息放在帧首部中 能帮助源站确定整个网络可以通过的帧的最大长度 多接口网桥–以太网交换机 以太网交换机的每个接口都直接与一个单个主机或另一个集线器相连 全双工方式，通信时能同时连通多对接口，这样能无碰撞地传输数据 自学习算法，即插即用设备，具有多种速率的接口 大多以存储转发方式转发，一些使用直通方式 虚拟局域网VLAN 由局域网网段组成的与物理位置无关的逻辑组，这些网段有共同的需求 VLAN帧有一个标识符，指明发送这个帧的工作站是哪一个VLAN 利用以太网交换机划分局域网 虚拟局域网上的每个站都能收到同一个虚拟局域网上其他成员发出的广播 在同一个以太网交换机上但不在一个VLAN上的工作站不会接受到其他VLAN发出的信息 虚拟局域网协议在以太网的帧格式中插入4字节的标识符目的地址|源地址|VLAN标记|类型|数据|FCS 2字节的标记类型和2字节的标记控制信息","categories":[{"name":"计算机本科知识","slug":"计算机本科知识","permalink":"http://weibo.com/biousco/categories/计算机本科知识/"}],"tags":[{"name":"数据链路层，计算机网络","slug":"数据链路层，计算机网络","permalink":"http://weibo.com/biousco/tags/数据链路层，计算机网络/"}]},{"title":"前端面试问题-1","slug":"前端面试问题-1","date":"2015-06-11T14:39:37.000Z","updated":"2015-07-12T13:02:39.000Z","comments":true,"path":"2015/06/11/前端面试问题-1/","link":"","permalink":"http://weibo.com/biousco/2015/06/11/前端面试问题-1/","excerpt":"看了一篇文章的一些前端问题，发现好多都不会=。=而且明天有个电话面试，临时抱抱佛脚哈哈哈 关键字：怪异模式 CSS hack SEO 闭包 JS对象实现 浏览器的标准模式与怪异模式的设置与区分方法 由于历史的原因，各个浏览器在对页面的渲染上存在差异，甚至同一浏览器在不同版本中，对页面的渲染也不同。在W3C标准出台以前，浏览器在对页面的渲染上没有统一规范，产生了差异(Quirks mode或者称为Compatibility Mode)；由于W3C标准的推出，浏览器渲染页面有了统一的标准(CSScompat或称为Strict mode也有叫做Standars mode)，这就是二者最简单的区别。 IE（6,7,8）的标准模式和怪异模式差别较大：盒子模型的解释（宽度计算）DTD:文档类型定义（Document Type Definition)浏览器会通过头部声明即DTD来采用相应的渲染模式： 没有doctype声明的或使用HTML4以下的使用怪异模式 有doctype声明的使用标准模式判断使用的模式：window.top.document.compatMode，BackCompat表示怪异模式，CSS1Compat表示标准模式。对于IE8+，使用下面代码强制浏览器使用最新内核的标准模式：&lt;meta http-equiv=&quot; X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt;","text":"看了一篇文章的一些前端问题，发现好多都不会=。=而且明天有个电话面试，临时抱抱佛脚哈哈哈 关键字：怪异模式 CSS hack SEO 闭包 JS对象实现 浏览器的标准模式与怪异模式的设置与区分方法 由于历史的原因，各个浏览器在对页面的渲染上存在差异，甚至同一浏览器在不同版本中，对页面的渲染也不同。在W3C标准出台以前，浏览器在对页面的渲染上没有统一规范，产生了差异(Quirks mode或者称为Compatibility Mode)；由于W3C标准的推出，浏览器渲染页面有了统一的标准(CSScompat或称为Strict mode也有叫做Standars mode)，这就是二者最简单的区别。 IE（6,7,8）的标准模式和怪异模式差别较大：盒子模型的解释（宽度计算）DTD:文档类型定义（Document Type Definition)浏览器会通过头部声明即DTD来采用相应的渲染模式： 没有doctype声明的或使用HTML4以下的使用怪异模式 有doctype声明的使用标准模式判断使用的模式：window.top.document.compatMode，BackCompat表示怪异模式，CSS1Compat表示标准模式。对于IE8+，使用下面代码强制浏览器使用最新内核的标准模式：&lt;meta http-equiv=&quot; X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; CSS hack参考博文：CSS hack技巧大全最经常见到的就是IE6,7,8,和FF的CSS兼容了：1234567.hack &#123; height: 22px; background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/&#125; 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，此时，我们的IE8已经独立识别。不过项目中基本没用过=。=因为可以通过其他方法来实现效果。而且用hack也确实不太好。 SEO方案robots协议参考文章：禁止搜索引擎收录的方法 搜索引擎使用spider程序自动访问互联网上的网页并获取网页信息。spider在访问一个网站时，会首先会检查该网站的根域下是否有一个叫做 robots.txt的纯文本文件，这个文件用于指定spider在您网站上的抓取范围。您可以在您的网站中创建一个robots.txt，在文件中声明 该网站中不想被搜索引擎收录的部分或者指定搜索引擎只收录特定的部分。请注意，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 404页面重置参考页面：原来404页面可以这样做 404页面是网站必备的一个页面，它承载着用户体验与SEO优化的重任。404页面通常为用户访问了网站上不存在或已删除的页面，服务器返回的404错误。如果站长没有设置404页面，会出现死链接，蜘蛛爬行这类网址时，不利于搜索引擎收录。 404页面设置方法 虚拟空间设置方法现在的idc提供商基本都提供404设置的功能，直接上传文件设置即可。 IIS下设置404页面在IIS管理器中右键单击要管理的网站，打开“属性”中的“自定义错误信息”页，为“404”设定相应的错误信息页即可。不过，此处在“消息类型”中一定要选择“文件”或“默认值”，而不要选择“URL”，不然，将导致返回“200”状态码。 Apache下设置404错误页面在.htaccess 文件中加入如下内容即可：ErrorDocument 404 /notfound.php。切记不要使用绝对URL，如果使用绝对URL返回的状态码是“302”+“200”。在设置好以后最好再检查一遍网页的http状态，可以用ranknow这个工具：检测你的站点404设置的是否正确。 关键字 给图片设置title，alt HTML结构优化：h1,h2 HTML头部添加&lt;meta description=&#39;&#39;&gt;和keyword 网站地图百度百科：网站地图 网站地图，又称站点地图，它就是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接（注：不是所有页面）。大多数人在网站上找不到自己所需要的信息时，可能会将网站地图作为一种补救措施。搜索引擎蜘蛛非常喜欢网站地图。 啊啊感觉自己在临时抱佛脚=。=后面再仔细看看 JS面向对象1234567891011121314151617181920212223242526272829function jsClass (privateParam, publicParam) &#123; var privateParam = privateParam; //私有变量 this.publicParam = publicParam; //公共变量 //私有方法 function priMethod () &#123; return \"priMethod()\"; &#125; //特权方法，方法能访问所有成员 this.privilegedMethod = function () &#123; return \"use all Method()!\"; &#125;&#125;//公用方法，不用调用私有变量和方法jsClass.prototype.pubMethod = function () &#123; return \"pubMethod()\";&#125;//调用实例var jsObject = new jsClass(\"priMember\",\"pubMember\");console.log(jsObject.privateParam) //失败 undefinedconsole.log(jsObject.publicParam) //成功console.log(jsObject.pubMethod()) //成功console.log(jsObject.priMethod()) //失败 “对象不支持此属性或方法”console.log(jsObject.privilegedMethod()) //成功 JS跨域访问参考文章：js跨域及解决方案 我们经常会在页面上使用ajax请求访问其他服务器的数据,此时,客户端会出现跨域问题.跨域问题是由于javascript语言安全限制中的同源策略造成的.简单来说,同源策略是指一段脚本只能读取来自同一来源的窗口和文档的属性,这里的同一来源指的是主机名、协议和端口号的组合. 解决方法：在HTML DOM中,Script标签是可以跨域访问服务器上的数据的.因此,可以指定script的src属性为跨域的url,从而实现跨域访问。但这里对返回的数据有个要求,即:服务器返回的数据不能是单纯的如{“Name”:”zhangsan”}。这里引入了JSONP: JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而HTML的script元素是一个例外。利用script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。 客户端：1234567891011121314151617181920$.ajax(&#123; async: false, url: \"http://192.168.0.5/Web/web1.aspx\", type: \"GET\", dataType: 'jsonp', //jsonp的值自定义,如果使用jsoncallback,那么服务器端,要返回一个jsoncallback的值对应的对象. jsonp: 'jsoncallback', //要传递的参数,没有传参时，也一定要写上 data: null, timeout: 5000, //返回Json类型 contentType: \"application/json;utf-8\", //服务器段返回的对象包含name,data属性. success: function (result) &#123; alert(result.date); &#125;, error: function (jqXHR, textStatus, errorThrown) &#123; alert(textStatus); &#125;&#125;); 原生方法是通过创建一个&lt;script&gt;,添加到DOM结构并触发函数。 闭包面试题看到一直在问。终于认真看了一遍：参考文章：javascript深入理解js闭包话说脚本之家这个网站好神奇=、=虽然广告好多代码没有格式化但是好多内容啊。这个图片好形象~1234567891011var name = \"yes\";var object = &#123; name : \"my object\", getName : function () &#123; return function () &#123; return this.name; &#125; &#125;&#125;;alert(object.getName()()); 1234567891011function outFun () &#123; var a = 0; return function () &#123; a++; alert(a); &#125;&#125;var a = outFun();a(); //1a(); //2 出于种种原因，我们有时候需要得到函数内的局部变量。但是，正常情况下，这是办不到的，只有通过闭包才能实现。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"http://weibo.com/biousco/tags/SEO/"},{"name":"面试","slug":"面试","permalink":"http://weibo.com/biousco/tags/面试/"},{"name":"闭包","slug":"闭包","permalink":"http://weibo.com/biousco/tags/闭包/"}]},{"title":"广外隧道口Web后台（1）","slug":"广外隧道口Web后台-1","date":"2015-06-10T14:48:01.000Z","updated":"2015-07-12T13:02:11.000Z","comments":true,"path":"2015/06/10/广外隧道口Web后台-1/","link":"","permalink":"http://weibo.com/biousco/2015/06/10/广外隧道口Web后台-1/","excerpt":"最近在学Node的知识，学没一个星期又有一个项目要做了。哇新的Cmd Markdown更新了苹果的字体看起来好舒服。关键字： 全屏背景 字体图标 data-* 颜色插件 kindeditor项目页面：Submit Activity 全屏背景设计图用了个全屏背景：正常屏幕（1366768)1080P宽屏 (19801080)是的我买了个显示器！好爽！","text":"最近在学Node的知识，学没一个星期又有一个项目要做了。哇新的Cmd Markdown更新了苹果的字体看起来好舒服。关键字： 全屏背景 字体图标 data-* 颜色插件 kindeditor项目页面：Submit Activity 全屏背景设计图用了个全屏背景：正常屏幕（1366768)1080P宽屏 (19801080)是的我买了个显示器！好爽！全屏背景的话可以用backgroud-size: cover;只不过兼容性有点问题，只支持IE9+。具体是切一张2K的背景图，使用的时候在主内容外面加上：123&lt;div class=\"superbg\"&gt; &lt;img src=\"images/bg.jpg\" alt=\"\"&gt;&lt;/div&gt; 设置这个层为fixed，100%显示，然后里面图片的高度的话有不同情况： 这里面有两个高度：.superbg和img 高度如果写成百分比是按照父元素的高度来计算的，所以img写成100%会完整显示图片，高度为父层的高度；如果不写就是默认auto，显示区域会自动截取，好像是从中间开始截取，图片就不完整了。 由于外层用了定位，所以必须明确设置高度，我就一刀切650px了=。=所以最后背景图片会有一定变形，不过看不出来啦哈哈哈。 可以用JS来先获取到里层img的高度，然后设置到外层的高度中，这样图片就不会变形了。不过没有这么做 不过用fixed的话还有其他问题。在正常屏幕下，这个层真的就是fixed的了，内容滚动的时候这个层不滚动，背景不会滚动，达不到设计图想要的下面是纯色的效果，就把这个fixed改成absolute了。还有一点就是设置z-index为负值，后面的内容才不会被遮住。 字体图标阿里巴巴字体图标：iconfont昨天用的时候好像还没有这个阿里巴巴，话说功能和排版和icomoon好像啊~几步打造您自己的图标字体照着这个教程一步步来就可以了。不过设计师用了开源的图标库，有SVG格式，直接导入网站生成字体文件就OK了。其实想用字体图标是因为需要图标变色。本来是做成雪碧图的，改变颜色就不方便。用了字体图标可以加上各种CSS属性，最喜欢的是transition，颜色也有渐变效果了。大小通过font-size。我用的时候先转成inline-block，设置好宽高。 data-*属性不知道为什么网上很多说这个是HTML5特性=。= W3C写着所有浏览器支持，自己在IE7下也成功了。这次用在了字数限制：&lt;input type=&quot;text&quot; data-listen=&quot;true&quot; data-charlimit=&quot;16&quot; placeholder=&quot;活动标题&quot;&gt;1234567891011121314151617181920212223242526272829303132333435363738394041var charListen = &#123; init: function () &#123; _charListen = this; _charListen.config = $(\"input:text[data-listen='true']\"); _charListen.setup(); &#125;, setup: function () &#123; _charListen.config.each(function () &#123; var $this = $(this); var currentlength = 0; $this.bind('keyup keydown', function () &#123; var $this = $(this); var str = ''; var $alerttag = $this.next() var limit = $this.data(\"charlimit\"); str = $this.val(); //显示 $alerttag.css(\"opacity\",\"1\"); //超过长度进行字符串截取 if (str.length &gt; limit) &#123; $this.val(str.substr(0,limit)); &#125; else &#123; //正则匹配前面的数字（当前的输入字数） var temp = $alerttag.text().replace(/^\\d&#123;0,2&#125;/,str.length); $alerttag.text(temp); &#125; &#125;).bind(\"blur\", function () &#123; $(this).next().css(\"opacity\",\"0\"); &#125;) &#125;) &#125;&#125; 初始化的时候把所有input都执行了一遍这个函数。在html里存储数据感觉写JS特别方便~而且可以随时更改。如果纯JS实现的话初始化得到JS里面设置参数，还要判断不同输入框不同限制。字符限制自己想到的就是字符串截取了，网上查了资料也是一样的想法。不过有个bug：因为中文用拼音的关系，输入的时候例如这样：这是广外这是广外zheshiguangwai，其实用户只是想再输入四个汉字，但是因为拼音的关系，会先输入拼音，这样很有可能后面的拼音打不出来因为被截取了=。=这里的正则截取弄了我好长时间=。=。=。=1&lt;span class=\"limit\" &gt;0/16&lt;/span&gt; 在input后面是这个标签，其实我完全可以把会改变的这个0给个标签套起来，不过还是想算了别套太多标签直接正则获取斜杠前面的数字吧。然后是这样：/^\\d{0,2}/以数字开头，获取0~2位。完全和斜杠没关系。。搜索的时候是按照截取某个字符前的内容，然后发现很复杂而且不能用。什么时候再学一下正则吧。 颜色选择器这个果断找了插件来用：iColorPicker翻了一下源码发现竟然很短。。100行不到。好多行都是写CSS样式。主要思路： 在选中的输入框中创建新的div#iColorPicker，主要内容就是一个table，里面有预定好的颜色16*7个，然后再创建一个div#iColorPickerBg,这个是全屏的fixed的div，给这个div绑定点击事件，把创建的div都隐藏掉 接下来是给div#iColorPicker添加各种样式。以上这些在第一个颜色输入框中初始化完成 然后在颜色输入框中添加背景颜色，数值为选中的颜色，再创建a标签，内容是色板的icon，可以定义这个icon的图片路径，在输入框之后添加 第一步中的点击事件是一个函数，传入两个id，一个是输入框的id，一个是色板icon的id。 函数的内容：点击的时候显示div#iColorPicker和div#iColorPickerBg，获取输入框的内容，传入色板中显示的数值并修改背景色。 接下来遍历获取色板中的每个tr元素，绑定鼠标移过事件：每个tr标签都已经带有自己的颜色属性：hx=&#39;f00&#39;代表红色，然后就给各个内容赋值改变背景色；再绑定点击事件：隐藏色板，给内容赋值，返回点击的结点jQuery对象。 当时用的时候发现有一些不方便的地方：默认点击后给输入框添加背景色，太丑了太丑了。把这句话去掉。后来希望点击后旁边的icon图标也能变相应的颜色，所以修改了源码添加了一点东西。这种把源码都搞一遍的感觉真好哈哈哈 kindEditor这又是一个插件：kindEditor。其实没啥好说的，多看看文档就知道怎么弄了：123456789101112131415161718192021222324KindEditor.ready(function(K) &#123; var options = &#123; items : [ 'fontsize', '|', 'image' ], fontSizeTable : [ '16px','14px' ], resizeType : 0, //IE11下失效 pasteType : 1, uploadJson : '../php/upload_json.php', fileManagerJson : '../php/file_manager_json.php', allowFileManager : true, afterChange : function () &#123; this.sync(); $('#contentShow').html($('#editor').val()); &#125; &#125; window.editor = K.create('#editor',options); $('iframe').contents().find('.ke-content').css(\"background-color\",\"#e6e6e6\")&#125;); 然后根据需求，插件里面的字体只显示：小标题和段落，又去翻了这个源码，直接搜索关键字font很快就定位到了，自己加了一点判断，就OK了。对了这里有个jQuery获取不同iframe下的元素的方法：$(&#39;iframe&#39;).contents().find(&#39;.ke-content&#39;)好像哪个面试题问过这个。然后里面也有事件处理啦，就能同步显示输入的内容了。粘贴这个东西，我在网易云音乐里面复制了一些歌词过去，发现自动加载各种样式了。后面这个后台还要再改一下，要确定传过去的内容和图片路径等等东西。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://weibo.com/biousco/tags/JavaScript/"},{"name":"插件","slug":"插件","permalink":"http://weibo.com/biousco/tags/插件/"}]},{"title":"Quanta杯总结-2","slug":"Quanta杯总结-2","date":"2015-05-27T15:17:32.000Z","updated":"2015-07-12T13:01:34.000Z","comments":true,"path":"2015/05/27/Quanta杯总结-2/","link":"","permalink":"http://weibo.com/biousco/2015/05/27/Quanta杯总结-2/","excerpt":"JS交互（后台）这次作品和后台交互还是蛮多的，自己已经不只是再单纯的重构写页面了，这次也花了很多时间在这里导致没有太多时间打重构的代码=。=主要涉及这几个：表单验证，表单提交，Ajax，数据传递。 整体结构参考的博文找不到了。。1234567891011121314151617181920212223242526272829var loginBar = &#123; init: function () &#123; _this = loginBar; _this.config = &#123; $loginBtn: $('#login-btn'), $regisBtn: $('#regis-btn'), $loginOly: $('#login-overlay'), $regisOly: $('#regis-overlay') &#125;; _this.setup(); &#125;, setup: function () &#123; _this.bindEvent(_this.config.$loginBtn, _this.config.$loginOly); _this.bindEvent(_this.config.$regisBtn, _this.config.$regisOly); &#125;, //事件绑定，外部也可以单独调用 bindEvent: function (clickObj, targetObj) &#123; clickObj.click(function () &#123; targetObj.fadeIn(500).click(function (event) &#123; if (event.target == $(this).context) &#123; $(this).fadeOut(500); &#125;; &#125;) &#125;) &#125;&#125;","text":"JS交互（后台）这次作品和后台交互还是蛮多的，自己已经不只是再单纯的重构写页面了，这次也花了很多时间在这里导致没有太多时间打重构的代码=。=主要涉及这几个：表单验证，表单提交，Ajax，数据传递。 整体结构参考的博文找不到了。。1234567891011121314151617181920212223242526272829var loginBar = &#123; init: function () &#123; _this = loginBar; _this.config = &#123; $loginBtn: $('#login-btn'), $regisBtn: $('#regis-btn'), $loginOly: $('#login-overlay'), $regisOly: $('#regis-overlay') &#125;; _this.setup(); &#125;, setup: function () &#123; _this.bindEvent(_this.config.$loginBtn, _this.config.$loginOly); _this.bindEvent(_this.config.$regisBtn, _this.config.$regisOly); &#125;, //事件绑定，外部也可以单独调用 bindEvent: function (clickObj, targetObj) &#123; clickObj.click(function () &#123; targetObj.fadeIn(500).click(function (event) &#123; if (event.target == $(this).context) &#123; $(this).fadeOut(500); &#125;; &#125;) &#125;) &#125;&#125; 这种方法就是每个独立的方法都是一个对象，在对象里面有各种各样的方法可以内部互相调用。在初始化的匿名函数中：_this = loginBar，这个刚开始我觉得很巧妙，通过这个变量让内部来互相调用。不过在后来自己想，发现这个_this是个全局变量，全局变量，全局变量啊！！！所以在控制台中输入_this出来的结果一般都是指向最后使用的匿名函数。刚开始觉得还没什么，后来用到了定时器就蛋疼了。因为定时器里面也用到了这个_this，在不同的匿名函数方法中开了两个定时器，_this的指向就开始混乱了。好吧说一下这种JQ封装的方法：在init()中初始化用到的JQ对象，在setup()中对JQ对象进行事件绑定什么的，或者是作为程序的入口，相应调用其他方法，其他的方法就是具体到细节，处理各种各样的事情。另外也可以把这种模式换一种写法，让外界不能直接调用，但是能返回一个对象还是什么的=。=我忘记了。。下次找回那篇文章再贴上去。 表单验证123456789101112131415161718$(\"#regis-overlay input[name='email']\").blur(function () &#123; var status = _this.checkValidate.checkEmail($(this).attr('value')); if (!status) &#123; $('.validateinfo').text(\"邮箱格式不正确\"); return false; &#125; else &#123; $('.validateinfo').text(\"\"); &#125;&#125;).change(function () &#123; var status = _this.checkValidate.checkEmail($(this).attr('value')); if (!status) &#123; $('.validateinfo').text(\"邮箱格式不正确\"); return false; &#125; else &#123; $('.validateinfo').text(\"\"); &#125;&#125;); 不行让我重构一下。。1234567891011121314151617var commonOperate = function (status, text) &#123; if (!status) &#123; $('.validateinfo').text(text); return false; &#125; else &#123; $('.validateinfo').text(\"\"); &#125;&#125;;//表单提交前验证$(\"#regis-overlay input[name='email']\").blur(function () &#123; var status = _this.checkValidate.checkEmail($(this).attr('value')); commonOperate(status, \"邮箱格式不正确\");&#125;).change(function () &#123; var status = _this.checkValidate.checkEmail($(this).attr('value')); commonOperate(status, \"邮箱格式不正确\");&#125;); 把公用部分提取出来了，因为后面其实还有三个要绑定的输入框。不过这样不同的事件绑定相同的事件处理程序应该有更好的写法吧。看着相同的代码写了两遍好不爽。然后是正则表达式：1234567891011121314151617checkValidate: &#123; checkEmail: function (str) &#123; var re = /^[A-Za-z0-9]+([._\\\\-]*[a-z0-9])*@([A-Za-z0-9]+[A-Z-a-z0-9]*[A-Za-z0-9]+.)&#123;1,63&#125;[A-Za-z0-9]+$/; return re.test(str); &#125;, checkUser: function (str) &#123; var re = /^[A-Za-z].*[0-9a-zA-Z]&#123;5,30&#125;$|^[A-Za-z][0-9].*[A-Za-z]&#123;5,30&#125;$/; return re.test(str); &#125;, checkPassword: function (str) &#123; var re = /^[A-Za-z0-9]+$/; return re.test(str); &#125;&#125; 写得好臭的感觉= =不过多多少少又对正则入门了一些。对于：1234567reurn re.test(str);//if(re.test(str))&#123; return true;&#125; else &#123; return false;&#125; 本来是下面这样写的，然后WebStorm帮我改成了上面这种/(ㄒoㄒ)/~~正则表达式验证：正则表达式验证 表单提交12345678910submitForm: function (btn, tform, turl) &#123; if (btn.attr(\"id\") == 'logS') &#123; btn.click(function () &#123; ///code &#125;) &#125; else &#123; //通用方法 给所有表单使用 btn.click(function () &#123; tform.submit(); &#125;) &#125; 因为在重构的时候所有按钮都用&lt;a&gt;标签来写了，所以后台一直在喊”哇不是吧你怎么这么坑啊submit在哪里啊”…所以写了个方法给他调用，不过要在每个要提交的按钮加个Id咯，还有form也要=。=然后在一些特定的按钮就加了一些判断，普通表单直接提交，像登陆注册这种就做了一层合法性验证。 Ajax这次用了很多。在表单提交啊，聊天视频同步啊，搜索啊，添加信息什么的都用到了。12345678910111213141516171819202122$.ajax(&#123; url: turl, data: $(\"#loginForm\").serialize(), dataType: 'json', type: 'POST', success: function (data) &#123; if (data.status == 1) &#123; tform.submit(); &#125; else if (!data.content.verifyresult) &#123; console.log(data); $('.validateinfo').text(\"验证码错误\"); &#125; else if (!data.content.userresult) &#123; $('.validateinfo').text(\"用户名不存在\"); &#125; else if (!data.content.pwresult) &#123; $('.validateinfo').text(\"密码错误\"); &#125; &#125;, error: function (XMLHttpRequest, textStatus, errorThrown) &#123; console.log(XMLHttpRequest, textStatus, errorThrown); console.log($(\"#loginForm\").serialize()); &#125;&#125;) 这个是登陆用的Ajax。也是第一个写的Ajax。后台在我重构页面的时候一直催我催我”哈哈浩笙快写Ajax啊我后台函数都写好了啊就靠你了啊”…然后出现了不少坑：url问题：因为后台写提交链接是使用了Thinkphp的内置写法：__URL__，__PUBLIC__什么的，如果在这JS里面写，以为这个放在了静态资源那里，所以Thinkphp并不会渲染修改字符串。刚开始就妥协的写法，直接写路径，不久就出现了问题：/../getpauseplay?creatermd5=像这样，是绝对路径，而登陆注册框几乎在每个页面都有，所以不可能每个页面写一个路径。后来就直接给这个方法传递路径参数了，调用写在了HTML里，就能正确渲染后传值给JS这里了。data：刚开始查JQ的文档的时候还弄错了这个参数，用了content…理解成向后台发送的数据了，实际上是： content: 一个以”{字符串:正则表达式}”配对的对象，用来确定jQuery将如何解析响应，给定其内容类型。 改完之后就能传递表单数据了：$(&quot;#loginForm&quot;).serialize() serialize():序列表表格内容为字符串。 datatype : 这个会自动判断，不过当Ajax请求成功但是却不是你要的内容，可以设置为text来查看具体返回了什么。这次后台一律使用json来传递数据。 type ： 默认是get，有时候需要改为post。后台应该说清楚不然我总是请求不成功=。= success ： 函数参数就是请求成功返回的数据了。然后就对数据进行各种调教… error ： 这个前期总是发生=。=基本都是上面提到的问题，然后给我抛出各种错误长长的一串我也不知道是什么意思不过有些数字记下来：AJAX状态值与状态码一般遇到404.或者200但是textStatus返回这个：unexpected token &lt;类似这样的。设置返回内容为文本后发现数据返回的是HTML…然后不断的check。一般有两个原因： 该死的后台用了dump()，返回的数据带了后台测试的输出 请求的地址中没有发送任何内容，会直接返回原页面…写多几个Ajax后面就没什么太多的问题了。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"Ajax","slug":"Ajax","permalink":"http://weibo.com/biousco/tags/Ajax/"},{"name":"表单提交","slug":"表单提交","permalink":"http://weibo.com/biousco/tags/表单提交/"}]},{"title":"Meteor学习笔记-1","slug":"Meteor学习笔记-1","date":"2015-05-26T01:24:30.000Z","updated":"2015-07-12T13:02:58.000Z","comments":true,"path":"2015/05/26/Meteor学习笔记-1/","link":"","permalink":"http://weibo.com/biousco/2015/05/26/Meteor学习笔记-1/","excerpt":"扯淡弄完Quanta杯总得自己找点东西来学呀~去肖老板办公室见了中大的两个做外包的师兄，有个师兄也会前端，看到他用了Meteor,那我自己也来搞一下咯~Hexo的模板渲染遇到Meteor的模板代码会渲染出错！！所以有些代码就不放上去了。 安装 METEOR 还是想直接在Win下搞，选择好安装包后安装，记得要翻墙（也可能是校园网屏蔽了某些网站） 框架是直接安装在C盘下的C:\\Users\\Administrator\\AppData\\Local\\.meteor。把meteor.bat添加到系统变量，然后就可以在任意位置使用命令创建新的应用了：meteor create simple-todos。后来发现用WebStorm打开也可以直接创建Meteor应用，真不愧是前端神器啊，而且还有其他前端应用比如Bootstrap，PhoneGap等等。 指导文档：Installing Meteor","text":"扯淡弄完Quanta杯总得自己找点东西来学呀~去肖老板办公室见了中大的两个做外包的师兄，有个师兄也会前端，看到他用了Meteor,那我自己也来搞一下咯~Hexo的模板渲染遇到Meteor的模板代码会渲染出错！！所以有些代码就不放上去了。 安装 METEOR 还是想直接在Win下搞，选择好安装包后安装，记得要翻墙（也可能是校园网屏蔽了某些网站） 框架是直接安装在C盘下的C:\\Users\\Administrator\\AppData\\Local\\.meteor。把meteor.bat添加到系统变量，然后就可以在任意位置使用命令创建新的应用了：meteor create simple-todos。后来发现用WebStorm打开也可以直接创建Meteor应用，真不愧是前端神器啊，而且还有其他前端应用比如Bootstrap，PhoneGap等等。 指导文档：Installing Meteor ## 学习 ### 用模板定义视图在html文件中定义视图：在应用中对应的会被用模板渲染，使用name来关联：123&lt;template name=\"task\"&gt; &lt;li&gt;&#123;&#123;text&#125;&#125;&lt;/li&gt;&lt;/template&gt; 在JS文件中对应着Template.task在视图中还可以添加逻辑：12345&lt;ul&gt; &#123;&#123;#each tasks&#125;&#125; &#123;&#123;&gt; task &#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/ul&gt; 向模板传递数据：在JS文件中定义helpers：1234567891011// simple-todos.jsif (Meteor.isClient) &#123; // This code only runs on the client Template.body.helpers(&#123; tasks: [ &#123; text: \"This is task 1\" &#125;, &#123; text: \"This is task 2\" &#125;, &#123; text: \"This is task 3\" &#125; ] &#125;);&#125; 这里返回一个数组，数组中有三个对象，此时这个WebApp就是循环输出tasks中的三个对象。对于CSS来说就没有什么特别的了，该怎么写还怎么写。 在collection中存放tasks这里用到的数据库是MongoDB，使用前先了解一下这个非关系型数据库： collection介绍在mongodb中，collection相当于关系型数据库的表，但并不需提前创建，更不需要预先定义字段db.collect1.save({username:’mayj’,mail:’test@abc.com’}) #向collect1中插入一条记录，collection会在第一次插入记录的时候自动创建db.collect1.save({username:’name2’,mail:’name2@abc.com’,age:28}) #插入一条新记录，相对上条记录这次有三个key，类似三个字段db.collect1.find(); #列出collect1中的所有记录 参考文章：mongodb的collection几个功能介绍 在Meteor中创建一个新的collection使用：MyCollection = new Mongo.Collection(&quot;my-collection&quot;);，为了让这个Collection（我叫做集合吧）能在服务器和客户端使用，写在判断客户端还是服务器端的外面。写好之后修改之前的JS，helper中返回集合的数据：1234567891011// simple-todos.jsTasks = new Mongo.Collection(\"tasks\");if (Meteor.isClient) &#123; // This code only runs on the client Template.body.helpers(&#123; tasks: function () &#123; return Tasks.find(&#123;&#125;); &#125; &#125;);&#125; 然后开始向数据库中插入数据。这后面就有点坑了。 安装MongoDB虽然在启动应用的时候是显示了MongoDB启动成功了，可是在执行meteor mongo显示机器上没有MongoDB。所以觉得应该是没有装这个数据库，然后就去下载了：官网：MongoDB刚开始我就一直按最显眼的那些地方的按钮，START啊，BEGIN啊，然后就要我注册了，好吧，注册完一步步点，发现要装个浏览器插件之类的东西，装咯，然后发现自己到了一个网页版的数据库管理系统MMS：额=。=老衲不会用啊。好像和之前装的MySQL管理系统有点像，可是我只需要命令行能调用就行了啊= =然后回到官网看，原来发行的下载链接就在主页下面：好咯，安装完之后发现CMD里还是不能用，再百度。然后是这样的：C:\\Program Files\\MongoDB\\Server\\3.0\\bin我自己的安装在这里，然后把bin复制到E盘，执行下面的命令：mongod.exe dbpath=D:\\mongodb\\data logpath=D:\\mongodb\\log\\mongo.log来开始一个数据库，然后再开一个新的窗口执行：mongo.exe就成了。可以执行各种查询插入操作了。更详细的步骤：在Window平台下安装MongoDB的方法和步骤详解不过这时候在meteor项目下执行meteor mongo还是失败，又晚上12点了，关机睡觉，明天再搞。——————–叫我分割线————————————-起床再试一下OK了。能进入mongodb的shell，这时再执行插入语句，成功，app也显示出来了。","categories":[],"tags":[{"name":"Meteor","slug":"Meteor","permalink":"http://weibo.com/biousco/tags/Meteor/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://weibo.com/biousco/tags/MongoDB/"}]},{"title":"Quanta杯总结-1","slug":"Quanta杯总结-1","date":"2015-05-25T04:20:06.000Z","updated":"2015-05-25T11:25:08.000Z","comments":true,"path":"2015/05/25/Quanta杯总结-1/","link":"","permalink":"http://weibo.com/biousco/2015/05/25/Quanta杯总结-1/","excerpt":"简要地说一下这次的作品吧：时间大概是20天。项目的idea是运营部的人想的，设计师和冬令营的设计师一样，这次我就专注做重构（其实后来写了好多前台和后台的交互），后台找了舍友。我和舍友都是大二才参加Quanta，所以要和大一的一起做作品比赛。具体项目的功能是在线同步聊天看视频。运营说是参考这个网站：letsgaze（可能需要翻墙，而且必须要用Chrome浏览器）。简单的说就是两个人一起看视频，我暂停，你也暂停，我播放，你也播放，看的内容是同步的。同时也可以聊天。上面这个就是主页了。接下来写点东西记录一下做的时候遇到的坑吧。静态页面：Together。其他的页面在根目录下可以找到。","text":"简要地说一下这次的作品吧：时间大概是20天。项目的idea是运营部的人想的，设计师和冬令营的设计师一样，这次我就专注做重构（其实后来写了好多前台和后台的交互），后台找了舍友。我和舍友都是大二才参加Quanta，所以要和大一的一起做作品比赛。具体项目的功能是在线同步聊天看视频。运营说是参考这个网站：letsgaze（可能需要翻墙，而且必须要用Chrome浏览器）。简单的说就是两个人一起看视频，我暂停，你也暂停，我播放，你也播放，看的内容是同步的。同时也可以聊天。上面这个就是主页了。接下来写点东西记录一下做的时候遇到的坑吧。静态页面：Together。其他的页面在根目录下可以找到。 目录结构123456789101112131415E:.├─Admin│ ├─css│ │ └─vendor│ ├─fonts│ │ └─glyphicons│ ├─img│ │ └─icons│ │ └─png│ ├─js│ │ └─vendor│ └─video├─css├─images└─js 页面主要分为前台和后台咯，后台用了Bootstrap框架，做完之后删掉了一些没用的文件。 CSS3动画写了几个动画之后感觉这个就没什么好说的啦，没用到什么太复杂的东西，就切图，写动画效果，把动画相关的都放在一个css里面。这里安利一个腾讯团队做的工具：CSS3动画帧数计算器兼容性的前缀的话用了AutoPrefixer，不过貌似有BUG，在LESS下面使用完后在最后会生成很多个}，要手动删除掉，否则LESS编译的时候会报错。 SEO12&lt;meta name=\"keywords\" content=\"together,在线同步分享，同步视频分享，聊天，视频，同步\"&gt;&lt;meta name=\"description\" content=\"together推出的在线同时共享功能，跨越空间的距离，让相隔千里的你们，分秒不差地一起看视频，一起听音乐……当你们一起欢笑，一起吐槽电影中的bug，一起欣赏某段音乐里的一段旋律时，ta早已在你身边陪伴着你，犹如不曾离开。\"&gt; 头部给搜索引擎用。（话说吐槽电影中的bug是不是有点奇怪=。=）然后是上面用到的动画效果，因为文字是用了特殊字体，所以切图了，但是这样HTML里面没有什么&lt;h1&gt; &lt;h2&gt;标签来给搜索引擎获取内容，所以用了一点小小的技巧：123456789101112131415&lt;div class=\"animate-group\"&gt; &lt;h2&gt; &lt;span class=\"texthide\"&gt;在你身边，不曾离开&lt;/span&gt; &lt;/h2&gt; &lt;div class=\"arrows arrows-top\"&gt;&lt;/div&gt; &lt;h1&gt; &lt;span class=\"texthide\"&gt;TOGETHER&lt;/span&gt; &lt;/h1&gt; &lt;div class=\"arrows arrows-bottom\"&gt;&lt;/div&gt; &lt;h3&gt; &lt;span class=\"texthide\"&gt;在线同步分享&lt;/span&gt; &lt;/h3&gt; &lt;div class=\"computer computer-left\"&gt;&lt;/div&gt; &lt;div class=\"computer computer-right\"&gt;&lt;/div&gt;&lt;/div&gt; 这个是主页中心的几个元素的HTML文件。然后.texthide是这样的：123456789.texthide&#123; /*文本隐藏黑魔法*/ font: 0px/0 a; color: transparent; background-color: transparent; border: 0 none; overflow: hidden;&#125; font: 0px/0 a参考文章：letter-spacing+first-letter实现按钮文字隐藏张鑫旭大神的一篇文章有提到这个东西。都是各种文字隐藏的方法。其他的SEO相关的应该就是标签的语义化吧。该用&lt;h1&gt;啊&lt;p&gt;啊什么的就用这些。 登陆/注册模块登陆注册是个模态框，把点击浮现的这个功能单独写成了一个JS函数：12345678910111213141516171819202122232425262728293031//登陆/注册模块(模态框实现)：点击按钮出现浮动框，点击浮动框之外的部分消失。//不写成匿名函数，让其他模块也可以进行调用var loginBar = &#123; init: function () &#123; _this = loginBar; _this.config = &#123; $loginBtn: $('#login-btn'), $regisBtn: $('#regis-btn'), $loginOly: $('#login-overlay'), $regisOly: $('#regis-overlay') &#125;; _this.setup(); &#125;, setup: function () &#123; _this.bindEvent(_this.config.$loginBtn, _this.config.$loginOly); _this.bindEvent(_this.config.$regisBtn, _this.config.$regisOly); &#125;, //事件绑定，外部也可以单独调用 bindEvent: function (clickObj, targetObj) &#123; clickObj.click(function () &#123; targetObj.fadeIn(500).click(function (event) &#123; if (event.target == $(this).context) &#123; $(this).fadeOut(500); &#125;; &#125;) &#125;) &#125;&#125; 后来发现这样单独出来相当有好处。因为后面也经常用到了这个模块。调用方法也超级简单：1234//初始化绑定默认的登陆注册框loginBar.init();//调用绑定特定的模态框loginBar.bindEvent($(\"#adBtn\"),$(\"#admin-overlay\")); 虽然看起来没有那么语义化=。= LESS这次全部CSS都用LESS来做。用LESS还没真正发挥出他真正的优势吧，还是只用到皮毛。做之前和设计师沟通后设计图都有按照网格来做：所以写LESS的时候就方便很多，尺寸基本都是数格子啦[]~(￣▽￣)~*12345678910111213@global-width: 24px;.logo&#123; position: absolute; width: 4*@global-width; height: 4*@global-width; left: 50%; margin-left: -2*@global-width; img &#123; width: 100%; &#125;&#125; 虽然很想用多点变量=。=可是写样式的时候就基本一口气写完了，后面也懒得去提取公用变量了。下次迭代（如果有的话）重构一下代码咯。 雪碧图百度百科的介绍好像蛮全的：CSS雪碧CSS雪碧好处都有啥！以前自己会思考要是面试官这么问我，我应该就是回答减少请求数吧，然后避免一些图片按钮的闪动。看了介绍才知道原来大小还会减少总大小： 提高页面的加载速度sprite 技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF 图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF 只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 让我想起了在益米主页用到的十几张头像和二维码哈哈哈哈哈，改成雪碧图吧，不然几十个请求数太恐怖了。不过雪碧图还是有些缺点（百度百科），占用内存大？百度了一下在小项目还是没有太多问题的，然后多注意图片的组织，不要浪费太多空白，也不要把图标都挤在一起，导致有时候露出其他图标。自己做雪碧图的时候要多注意使用图标的元素的大小，因为很有可能并不是纯粹的图标那么大，有可能是放在一个2~3倍的容器里面，这点需要注意，否则就要不断的改PSD，保存为PNG，看效果，再改PSD…还有要注意的是定位属性用top和left吧，少用bottom，因为如果修改了雪碧图bottom可能就不是原来的位置了。","categories":[],"tags":[{"name":"SEO","slug":"SEO","permalink":"http://weibo.com/biousco/tags/SEO/"},{"name":"雪碧图","slug":"雪碧图","permalink":"http://weibo.com/biousco/tags/雪碧图/"},{"name":"Together","slug":"Together","permalink":"http://weibo.com/biousco/tags/Together/"},{"name":"Quanta杯","slug":"Quanta杯","permalink":"http://weibo.com/biousco/tags/Quanta杯/"}]},{"title":"益米主页总结(3)","slug":"益米主页总结-3","date":"2015-05-02T12:38:00.000Z","updated":"2015-05-02T12:48:40.000Z","comments":true,"path":"2015/05/02/益米主页总结-3/","link":"","permalink":"http://weibo.com/biousco/2015/05/02/益米主页总结-3/","excerpt":"第一次用上图片有点小激动。。五一小长假又是在学校。现在都是一个学期才回一次家了。 JS-main其实重新去看自己写的JS，有好多地方可以改。更悲催的是，发现JS基本都是用来实现动画效果的=。=1234567var commonAnimatefun = function(id, prevCls, addCls) &#123; var ele = document.getElementById(id); if (ele.className.indexOf(prevCls) &gt; -1) &#123; return; &#125;; ele.className += addCls;&#125; 实现第一部分写的滚动触发JS然后给父元素添加动画类就是这个函数了。之前写的重复的太多，就封装成这个函数，当符合条件就触发。当然，为了避免多次添加类，函数内做一点判断。不过我更想是执行了一遍这个函数就取消执行，不要进入函数判断。写这篇东西的时候自己看着JS好不爽，边写边重新重构代码了：","text":"第一次用上图片有点小激动。。五一小长假又是在学校。现在都是一个学期才回一次家了。 JS-main其实重新去看自己写的JS，有好多地方可以改。更悲催的是，发现JS基本都是用来实现动画效果的=。=1234567var commonAnimatefun = function(id, prevCls, addCls) &#123; var ele = document.getElementById(id); if (ele.className.indexOf(prevCls) &gt; -1) &#123; return; &#125;; ele.className += addCls;&#125; 实现第一部分写的滚动触发JS然后给父元素添加动画类就是这个函数了。之前写的重复的太多，就封装成这个函数，当符合条件就触发。当然，为了避免多次添加类，函数内做一点判断。不过我更想是执行了一遍这个函数就取消执行，不要进入函数判断。写这篇东西的时候自己看着JS好不爽，边写边重新重构代码了：1234567891011121314151617181920212223242526var EMITONG = &#123; header: document.getElementById('module-fixhead'), slideNavBar: document.getElementById('slideNavBar'), timeline: document.getElementById('module-timeline'), team: document.getElementById('module-team'), map: document.getElementById('module-map'), headerNav: document.getElementById('windowScrollTo'), fixedTopShow: function(scrollTop) &#123; commonAnimatefun('module-fixhead', 'animation', ' fixheader-animation'); slideNavBar.style.display = \"block\"; slideNavBarfun(scrollTop); &#125;, fixedTopHide: function() &#123; this.header.className = \"module-fixhead\"; slideNavBar.style.display = \"none\"; &#125;, init: function() &#123; commonAnimatefun('module-header', 'animation', ' header-animation'); windowScrollTo(); addBtn(); var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; if (scrollTop &gt; 0) &#123; EMITONG.fixedTopShow(scrollTop); &#125;; &#125;&#125; 其实就是把模块中的一些公用的元素都放到一起了，其实也不清楚这样是不是真的会更好。。123window.onload = function() &#123; EMITONG.init();&#125; 然后原本长长的onload里面的函数就变成现在这一句了，看起来还蛮有逼格的哈哈哈。重构代码（这应该算是了吧）中有个困惑就是不知道改写之后是不是还能实现原来的效果。。只能反复人肉测试，而且还不知道会不会有隐藏的BUG=。=是不是要学一下单元测试了。主要大改的就是这个地方了。12345678910111213141516171819202122232425262728293031323334var slideNavBarfun = function(scrollTop) &#123; var slideNavBar = EMITONG.slideNavBar; var menuele = EMITONG.headerNav.getElementsByTagName('a'); for (var i = 0, max = menuele.length; i &lt; max; i++) &#123; if (menuele[i].className == \"selected\") &#123; menuele[i].className = \"\"; break; &#125; &#125;; if (scrollTop &lt; 582) &#123; slideNavBar.style.left = \"0\"; slideNavBar.style.width = \"44px\"; menuele[0].className = \"selected\"; &#125; else if (scrollTop &gt;= 582 &amp;&amp; scrollTop &lt; 2598) &#123; slideNavBar.style.left = \"57px\"; slideNavBar.style.width = \"92px\"; menuele[1].className = \"selected\"; &#125; else if (scrollTop &gt;= 2598 &amp;&amp; scrollTop &lt; 3512) &#123; slideNavBar.style.left = \"150px\"; slideNavBar.style.width = \"92px\"; menuele[2].className = \"selected\"; &#125; else if (scrollTop &gt;= 3512 &amp;&amp; scrollTop &lt; 5068) &#123; slideNavBar.style.left = \"243px\"; slideNavBar.style.width = \"92px\"; menuele[3].className = \"selected\"; &#125; else if (scrollTop &gt;= 5068) &#123; slideNavBar.style.left = \"338px\"; slideNavBar.style.width = \"92px\"; menuele[4].className = \"selected\"; &#125;&#125; 不介意我放出这个自认为很蠢得函数吧。。没错，我就是人肉确定到底什么时候滚动到目标！记录那个高度值然后改变底部那个浮动块的位置。。真的觉得好蠢，而且这样后期很不好修改，如果页面添加了元素改变了高度那就必须再动这里的数字了Orz。让我再去参考其他人是怎么写的= =然后自己感觉比较有趣的是这一段：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var onscrollTimer = null;window.onscroll = function() &#123; var TargetArray = null; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; if (scrollTop &gt; 0) &#123; EMITONG.fixedTopShow(scrollTop); &#125; else &#123; EMITONG.fixedTopHide(); &#125; //函数节流 if (onscrollTimer) &#123; clearTimeout(onscrollTimer); &#125; //当滚动到某个部分时执行函数 onscrollTimer = setTimeout(function() &#123; var clientHeight = document.documentElement.clientHeight; for (var key in TargetArray) &#123; if (TargetArray[key] &lt; 500 &amp;&amp; TargetArray[key] &gt; -500) &#123; switch (key) &#123; case 'timeline': &#123; timelinefun(); delete TargetArray.timeline; break; &#125; case 'team': &#123; teamfun(); delete TargetArray.team; break; &#125; case 'map': &#123; commonAnimatefun(\"module-map\", 'animation', ' map-animation'); delete TargetArray.map; break; &#125; &#125; &#125;; &#125; &#125;, 100);&#125; 就是把当前需要动画的部分都包装成一个对象，里面存放着动画块和用户的距离，当达到范围（这里是-500到500px）时，判断是哪一个到达了，然后执行动画。不过这个会在浏览器滚动的时候触发，虽然用了节流函数但是还是感觉很不好，应该有更好的算法吧=。=","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"益米主页总结(2)","slug":"益米主页总结-2","date":"2015-05-01T14:16:16.000Z","updated":"2015-05-01T14:26:02.000Z","comments":true,"path":"2015/05/01/益米主页总结-2/","link":"","permalink":"http://weibo.com/biousco/2015/05/01/益米主页总结-2/","excerpt":"你们知道弄了一整天才把博客重新弄好是什么心情吗。。给笔记本换了固态硬盘格了C盘D盘什么软件都要重装。折腾了好久才知道原来HEXO升级为3.0了。之前2.7用的好好的现在弄了好久真的是心好累啊心好累啊。不过算是弄好了，自己把public文件夹手动deploy【再见】。好了记一下主页里用到的JS吧。最终页面：益米，让校园生活轻松自在 JS-base不知道为什么我自己就是不喜欢用jQuery。就是喜欢自己写长长的JS代码。所以把自己之前写过的函数都收集起来真的是太有必要了： 判断是否在数组内12345678function is_inArray (array,target) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (array[i] == target) &#123; return i; &#125; &#125; return -1;&#125; 其实我觉得写得还好。。不过来看看zepto.js的：123$.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i)&#125;","text":"你们知道弄了一整天才把博客重新弄好是什么心情吗。。给笔记本换了固态硬盘格了C盘D盘什么软件都要重装。折腾了好久才知道原来HEXO升级为3.0了。之前2.7用的好好的现在弄了好久真的是心好累啊心好累啊。不过算是弄好了，自己把public文件夹手动deploy【再见】。好了记一下主页里用到的JS吧。最终页面：益米，让校园生活轻松自在 JS-base不知道为什么我自己就是不喜欢用jQuery。就是喜欢自己写长长的JS代码。所以把自己之前写过的函数都收集起来真的是太有必要了： 判断是否在数组内12345678function is_inArray (array,target) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (array[i] == target) &#123; return i; &#125; &#125; return -1;&#125; 其实我觉得写得还好。。不过来看看zepto.js的：123$.inArray = function(elem, array, i)&#123; return emptyArray.indexOf.call(array, elem, i)&#125; 先来了解这个call()函数：这是每个函数非继承而来的方法，还有一个是apply()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apple()接受两个参数：一个是在其中运行函数的作用域，另一个是参数数组。call()方法和apply()方法的区别在于接受参数的方式不同，第一个参数是this值，变化的是其余参数都直接传递给函数。具体参考《JavaScript高级程序设计》P117。这里写个例子：1234567891011window.color = \"red\";var o = &#123;color: \"blue\" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue 函数执行的环境不一样了，之前是在window下，现在是在o下。 使用call()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。 12345678910window.color = \"red\";var o = &#123;color: \"blue\" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redo.sayColor = sayColor;o.sayColor(); //blue 对比这两种写法，发现前面那种好很多了。然后是数组的index()方法：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。我之前一直以为这个方法只是在字符串里面使用。。用在查找类名。。擦原来系统已经提供了这个方法我还在自己写。对了，回到我写的那个方法。for (var i = 0; i &lt; array.length; i++)最好不要这么写，因为如果数组是DOM节点的集合，每次都需要获取一遍长度，比较消耗资源，所以改写成：for(var i = 0,var max = array.length; i &lt; max; i++) 移除元素的某个类先不要脸的放上自己写的：123456function removeClassName (target,clsName) &#123; var allcls = target.className; if (allcls.indexOf(clsName)) &#123; target.className = allcls.replace(clsName,\" \"); &#125;&#125; zepto.js版：1234567891011removeClass: function(name)&#123; return this.each(function(idx)&#123; if (!('className' in this)) return if (name === undefined) return className(this, '') classList = className(this) funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass)&#123; classList = classList.replace(classRE(klass), \" \") &#125;) className(this, classList.trim()) &#125;)&#125;, 看我慢慢读懂他在做些什么…第4行有个函数className:12345678// access className property while respecting SVGAnimatedStringfunction className(node, value)&#123; var klass = node.className || '', svg = klass &amp;&amp; klass.baseVal !== undefined if (value === undefined) return svg ? klass.baseVal : klass svg ? (klass.baseVal = value) : (node.className = value)&#125; 哇擦后面他在干什么。。应该是在respecting SVGAnimatedString所以第四行就是如果传入的类名为空，则设置该元素的类为空（移除所有类）。还有个funcArg()，一看就觉得是来获得函数参数的：123function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg&#125; 好像不是呢哈哈哈。。。在这里是返回了原来的name。（name有可能是函数，这个会比较复杂）然后对返回的字符串进行正则表达式匹配：/\\s+/g。\\s代表空格，+代表一个或者多个。所以这样就把类名通过空格分开来存放到数组里面了。然后又有一个新函数：1234function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))&#125; 这里的正则表达式：&#39;(^|\\\\s)&#39;代表以空格或者什么都没有开始，&#39;(\\\\s|$)&#39;代表以空格或什么都没有结束。连起来就是：className可以匹配，className也可以匹配。所以就是设置类名。。。回到原来的函数，就是找到那个类名，然后换回” “。最后是删除字符串前后的空格符trim()赋值给元素的类。和String.prototype.trim()一样。啊终于看了个七七八八了。。 函数节流123456789/* 函数节流throttle */function throttle (method, context) &#123; if (method.tId) &#123; clearTimeout(method.tId); &#125;; method.tId = setTimeout(function () &#123; method.call(context); &#125;, 150);&#125; 这个东西用在window.onsize()或者window.onscroll()之前就在想我擦网页滚动一下就执行函数会不会太消耗性能了，后来就发现了这个东西，不过最后没有这么用，而是：12345678910window.onscroll = function() &#123; if (onscrollTimer) &#123; clearTimeout(onscrollTimer); &#125; onscrollTimer = setTimeout(function() &#123; //code &#125;, 100);&#125; 每隔0.1s触发一次。实际运行效果很OK。 事件函数前面有篇文章写了，这次也用到了。兼容性良好。。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"Zepto","slug":"Zepto","permalink":"http://weibo.com/biousco/tags/Zepto/"}]},{"title":"益米主页总结(1)","slug":"益米主页总结-1","date":"2015-04-30T14:56:04.000Z","updated":"2015-07-12T12:59:33.000Z","comments":true,"path":"2015/04/30/益米主页总结-1/","link":"","permalink":"http://weibo.com/biousco/2015/04/30/益米主页总结-1/","excerpt":"在做益米的主页时，又学到了很多新知识：CSS3动画，SEO，JS事件处理等等。设计师很给力，我也在努力重构出他想要的效果。最终页面：益米，让校园生活轻松自在 开始设计师是做好一个模块就丢给我。所以我刚开始也是一个模块一个模块的重构。做完5个模块后总设计图就发给我了。然后就是直接把HTML和LESS拼接在一起。大概的样子就出来了。不过第一次这么做也出现了一些问题，记录一下： 模块命名最好在项目开始的时候就定义好各种基本模块的名字，比如：1&lt;div class=\"module-container\"&gt;&lt;/div&gt; 然后确定好容器的宽度，以及在总页面中是怎么呈现。后来定义的是这样：1.module-container &#123;width: 1110px;margin: 0 auto;&#125; 实际中这个并不是最外层的容器。需要另外一个div来包裹，设置宽度啊背景啊什么的：1.w100p &#123;width: 100%;min-width: 1200px;background-color: #EDF4F9;&#125; 然后秉承着padding和宽度分离的原则，在w100p类之下再设置一个内边距，来控制内容在一整个区块中的上下距离：1.p100 &#123;padding: 100px 0;&#125; 其实我没有量设计图的距离…就让内容看起来是居中的。不过让内容垂直居中其实有很多办法，以后再讲。 CSS3 动画动画都单独放在一个CSS里面。","text":"在做益米的主页时，又学到了很多新知识：CSS3动画，SEO，JS事件处理等等。设计师很给力，我也在努力重构出他想要的效果。最终页面：益米，让校园生活轻松自在 开始设计师是做好一个模块就丢给我。所以我刚开始也是一个模块一个模块的重构。做完5个模块后总设计图就发给我了。然后就是直接把HTML和LESS拼接在一起。大概的样子就出来了。不过第一次这么做也出现了一些问题，记录一下： 模块命名最好在项目开始的时候就定义好各种基本模块的名字，比如：1&lt;div class=\"module-container\"&gt;&lt;/div&gt; 然后确定好容器的宽度，以及在总页面中是怎么呈现。后来定义的是这样：1.module-container &#123;width: 1110px;margin: 0 auto;&#125; 实际中这个并不是最外层的容器。需要另外一个div来包裹，设置宽度啊背景啊什么的：1.w100p &#123;width: 100%;min-width: 1200px;background-color: #EDF4F9;&#125; 然后秉承着padding和宽度分离的原则，在w100p类之下再设置一个内边距，来控制内容在一整个区块中的上下距离：1.p100 &#123;padding: 100px 0;&#125; 其实我没有量设计图的距离…就让内容看起来是居中的。不过让内容垂直居中其实有很多办法，以后再讲。 CSS3 动画动画都单独放在一个CSS里面。 CSS3相关属性页面上所有的动画基本就是用这几个属性：transform,transition,animation。 transform定义物体的变形：比如缩放scale,位置translate3D,旋转rotate等等 transition定义变形时的过渡：最重要的就是时间函数了，动画过渡的效果就靠这个属性：transition-timing-function。此外还有其他的，定义过渡的属性，延迟时间，持续时间。简写：transition:all 0.5s ease-in-out 1s代表所有属性都进行过渡，持续0.5秒，1s后执行，过渡效果是先快后慢。时间函数有内置的，也可以自己定义，自己定义是用贝塞尔曲线（PS中也用到了贝塞尔曲线）然后从网上搜了一下，一些比较有趣的函数就是这样了：cubic-bezier(0.52, 1.64, 0.37, 0.66)百度百科的介绍：贝塞尔曲线。详细的说明：CSS3:transform与transition背后的数学原理 animation就是自己定义整个动画的流程了。更加自由不过也相对复杂一点： 1234567891011@-webkit-keyframes hvr-buzz &#123; 50% &#123; -webkit-transform: translateX(3px) rotate(2deg); transform: translateX(3px) rotate(2deg); &#125; 100% &#123; -webkit-transform: translateX(-3px) rotate(-2deg); transform: translateX(-3px) rotate(-2deg); &#125;&#125; 这是比较简单的例子。了解了上面的transform这个也不难理解。 不过要做到完美的动画还是需要写很多很多很多东西的，如果贪方便可以百度CSS3动画框架，有很多方便的工具方便开发，可是生成的代码真的太多太多了。。这次在主页里大部分是自定义的动画，也只是用到了简单的几个属性，不过设计师和老板很喜欢的样子哈哈哈。 接下来要说说怎么组织代码。 代码组织这次用到的动画的触发有这几种：鼠标移上去触发动画，页面滚动到目标位置触发动画，页面加载完成触发动画。鼠标移上元素触发处理方式是使用css中的hover，当元素hover的时候改变原有的属性：1234.hvr-buzz:hover, .hvr-buzz:focus, .hvr-buzz:active&#123; -webkit-transform: translate3D(0,-20px,0); transform: translate3D(0,-20px,0);&#125; 当包含类hvr-buzz的元素被鼠标调戏的时候，这个元素会向上移动20像素。当然这样看好像这个元素就是生硬的移动上去了，其实不是，这个元素还定义了下面的属性：transition-timing-function: cubic-bezier(0.47, 2.02, 0.31, -0.36);这个时间函数让元素属性改变的时候非常”活泼”。具体效果可以上官网看。页面滚动到目标位置触发这个涉及到JS。后面写JS再具体写下来。JS主要是判断当前页面滚动的位置，当滚动到目标位置后，给父元素添加动画类。这个我是从小米的官网上学到的。在没有看小米的官网之前，我先自己写了个时间轴的动画，然后动画一出来，哇，很酷，很炫，很*，但是一看页面的代码，几乎所有包含动画的元素都加上了类，简直不能忍。后来看到了小米，发现卧槽动画的元素根本没有做DOM的操作啊！为什么！原来是把DOM操作都转移到一个父节点上了。。具体的说，就是先把一个部分的模块包装起来，最后肯定有个父节点，然后给父节点添加类名，比如：.map-animation然后CSS这样定义：12345678910111213/*module-map*/.map-animation .target&#123; -webkit-transform: translate3D(0,0,0); transform: translate3D(0,0,0); opacity: 1;&#125;.map-animation .target:hover&#123; -webkit-transform: translate3D(0,-10px,0); transform: translate3D(0,-10px,0);&#125; 当父元素添加了这个类，子元素也会自动应用这些样式了，从而触发动画。这样可以避免像之前单独定义一个动画类，然后涉及到JS的就进行大量的DOM操作。用这个方法只需要给一个父节点添加类名，然后动画也会自然出现，节省客户端资源。页面加载完成触发这个其实和第二种同理啦~ 动画制作动画效果简单的几个效果：初始元素设置透明度为0，这样元素一开始是隐藏的，如果需要有移动的效果的话，使用translate3D来设置位置；动画完成的时候透明度变为1，位置变为0（即本来应该在的位置）。配合transition的时间函数，可以完成简单动画效果了。另外控制元素一个接一个的出现是使用：transition-delay，给每个元素设置不同的延迟时间，这样元素就会延迟触发动画，有个顺序出来。123456789.item-1&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0s&#125;;.item-2&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.05s&#125;;.item-3&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.1s&#125;;.item-4&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.15s&#125;;.item-5&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.2s&#125;;.item-6&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.25s&#125;;.item-7&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.3s&#125;;.item-8&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.35s&#125;;.item-9&#123;transition:all 0.3s cubic-bezier(0.15,0.73,0.37,1.2) 0.4s&#125;; 额，这里可以单独写出来的。也可以使用JS来控制。（最好不要了，只不过我第一次做的时候第一个动画就是用JS来控制的，使用计时器） 改进如果使用hover来触发动画，有时候会有很鬼畜的效果出来。。就是当使用translate3D改变时，鼠标刚移动进去目标元素，元素会开始动画，这时候如果随着元素移动或者鼠标已经在元素比较里面的位置还好，如果不幸的，刚好在元素边缘并且鼠标没有移动，那么由于元素已经移动了，元素就会不在鼠标的范围内，相当于元素不hover了，所以元素开始不hover的动画，也就是回到原来的位置。可是！回到原来的位置的时候鼠标还在那里！相当于又hover了！因此。。如果用户发现了这个有趣的BUG，继续玩，会发现如果鼠标在边缘慢慢玩会更鬼畜。。。嗯。。我已经玩过了。。解决办法：不要直接在hover元素上加动画。在hover的子元素上加动画。相当于加一层套，鼠标移动进去套套的时候，子元素发生动画，父元素属性并不变，所以不会发生上面的情况。不好的地方就是增加了DOM节点，有时候动画触发范围略不一样。不过这比触发鬼畜效果要好多了。。动画框架的解决办法是使用:before元素，在:before元素上添加动画。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"CSS3动画","slug":"CSS3动画","permalink":"http://weibo.com/biousco/tags/CSS3动画/"}]},{"title":"微信浏览器跳转相关","slug":"微信浏览器跳转相关","date":"2015-04-10T02:07:36.000Z","updated":"2015-05-01T08:54:01.000Z","comments":true,"path":"2015/04/10/微信浏览器跳转相关/","link":"","permalink":"http://weibo.com/biousco/2015/04/10/微信浏览器跳转相关/","excerpt":"在做益米的下载页的时候发现微信浏览器有些地方需要注意。 链接跳转跳转苹果App Store：第一次是设置链接为https://appsto.re/cn/z3aa6.i发现在微信里这个链接不能跳转，查了资料后发现有一种方法：微信中打开app store连接。意思就是微信会内部把链接重定向，判断是App Store就阻止掉。所以在页面里面改写链接，改成在他们域名下，再使用JS进行跳转。具体方法是前面加上http://mp.weixin.qq.com/mp/再重定向：redirect?url=后面再把原来的链接里的冒号改成%3A，斜杠改为%2F。所以链接变成了：http://mp.weixin.qq.com/mp/redirect?url=http%3A%2F%2Fappsto.re%2Fcn%2Fz3aa6.i 尝试之后发现这个方法已经失效了。 无奈之下使用引导用户使用safari打开： 引导跳转制作遮罩层：12345&lt;div id=\"popweixin\"&gt; &lt;div class=\"tip\"&gt; &lt;img src=\"images/weixinpopup.png\" alt=\"\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324#popweixin&#123; width: 100%; height: 100%; overflow: hidden; position: fixed; z-index: 1000; background: rgba(0,0,0,0.5); top: 0; left: 0; display: none;&#125;#popweixin .tip &#123; width: 100%; background: #FFF; z-index: 1001;&#125;#popweixin img &#123; width: 100%;&#125;","text":"在做益米的下载页的时候发现微信浏览器有些地方需要注意。 链接跳转跳转苹果App Store：第一次是设置链接为https://appsto.re/cn/z3aa6.i发现在微信里这个链接不能跳转，查了资料后发现有一种方法：微信中打开app store连接。意思就是微信会内部把链接重定向，判断是App Store就阻止掉。所以在页面里面改写链接，改成在他们域名下，再使用JS进行跳转。具体方法是前面加上http://mp.weixin.qq.com/mp/再重定向：redirect?url=后面再把原来的链接里的冒号改成%3A，斜杠改为%2F。所以链接变成了：http://mp.weixin.qq.com/mp/redirect?url=http%3A%2F%2Fappsto.re%2Fcn%2Fz3aa6.i 尝试之后发现这个方法已经失效了。 无奈之下使用引导用户使用safari打开： 引导跳转制作遮罩层：12345&lt;div id=\"popweixin\"&gt; &lt;div class=\"tip\"&gt; &lt;img src=\"images/weixinpopup.png\" alt=\"\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324#popweixin&#123; width: 100%; height: 100%; overflow: hidden; position: fixed; z-index: 1000; background: rgba(0,0,0,0.5); top: 0; left: 0; display: none;&#125;#popweixin .tip &#123; width: 100%; background: #FFF; z-index: 1001;&#125;#popweixin img &#123; width: 100%;&#125; 然后进行事件绑定：123456789101112var href = document.getElementById('iphonehref');var href2 = document.getElementById('iphonehref2');href.addEventListener(\"click\",function (event) &#123; if (is_weixn()) &#123; event.preventDefault(); document.getElementById(\"popweixin\").style.display = \"block\"; document.getElementById('popweixin').onclick = function () &#123; this.style.display = \"none\"; &#125; &#125;&#125;,false); 确定是否是在微信内打开使用这个函数：12345678function is_weixn() &#123; var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == \"micromessenger\") &#123; return true; &#125; else &#123; return false; &#125;&#125; 然后自己比较坑爹的事情是，第一次是这么用的：if (is_weixn) 然后就不管是不是微信打开都是有遮罩层。 简直想抽死自己 is_weixn是一个函数，所以if(is_weixn)就是判断是否有一个变量。所以就一直为真。 if (is_weixn())才会执行这个函数返回结果。 然后就需要判断是电脑端还是手机端了： 欸好像不对 只要是微信端才绑定函数吧。。 我了个大草 判断终端类型：1234567891011121314var Terminal = &#123; // 辨别移动终端类型 platform: function() &#123; var u = navigator.userAgent; return &#123; // android终端或者uc浏览器 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, // 是否为iPhone或者QQHD浏览器 iPhone: u.indexOf('iPhone') &gt; -1, // 是否iPad iPad: u.indexOf('iPad') &gt; -1 &#125;; &#125; (),&#125;; 都是使用navigator的userAgent。和判断微信大同小异。这里使用的是indexOf()，返回值大于-1说明有指定的字符串。哇这个返回值写法有点酷炫学一下好了。然后是微信使用的方法：match()使用的是正则表达式。正则表达式：1var expression = / pattern / flags; flags: g(全局模式) i(不区分大小写) m(多行模式) 下一次详细讲。 然后是match() 接受正则表达式或者RegExp对象，返回数组，数组存放结果。 但是测试后发现直接按照例子的写法也是可以的：ua.match(/MicroMessenger/i)==&quot;micromessenger&quot; 不知道为什么不过里面的match必须是类似于/*/ 不能使用变量； 接下来又是事件绑定 微信里面为了用户体验，点击apple按钮的时候不要进行网络的加载，否则必须等加载完成用户才可以点击菜单使用浏览器打开，所以阻止了a标签的默认跳转行为：event.preventDefault(); 然后就是遮罩层的显示和隐藏了。 另外在浏览器打开后，https://appsto.re/cn/z3aa6.i这个链接会再次跳转到itunes:https://itunes.apple.com/cn/app/yi-mi/id973082073?l=en&amp;mt=8","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"微信 JS","slug":"微信-JS","permalink":"http://weibo.com/biousco/tags/微信-JS/"}]},{"title":"JavaScipt事件(2)","slug":"JavaScipt事件-2","date":"2015-04-07T03:16:40.000Z","updated":"2015-05-01T08:54:09.000Z","comments":true,"path":"2015/04/07/JavaScipt事件-2/","link":"","permalink":"http://weibo.com/biousco/2015/04/07/JavaScipt事件-2/","excerpt":"跨浏览器的事件处理程序1234567891011121314151617181920var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, removeHandler: function (element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;,&#125; 顺序 DOM2级方法：false表示在冒泡阶段调用 IE8下的方法执行顺序 DOM0级最不提倡的方法（现代浏览器不执行）","text":"跨浏览器的事件处理程序1234567891011121314151617181920var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, removeHandler: function (element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;,&#125; 顺序 DOM2级方法：false表示在冒泡阶段调用 IE8下的方法执行顺序 DOM0级最不提倡的方法（现代浏览器不执行） 缺点：不考虑所有浏览器的问题：IE中的作用域，多次使用时事件调用的顺序，DOM0级只支持一个事件处理程序 事件对象DOM中的事件对象 使用DOM0级或者DOM2级方法，浏览器都会传入一个event对象到事件处理程序中HTML DOM Event 对象 在事件处理程序内部，this始终等于currentTarget的值，而target只包含事件的实际目标。如果事件处理程序在按钮的父节点中，target是实际处理的目标，this和currentTarget是父节点。 在需要通过一个函数处理多个事件时，利用type属性来区分，使用swtich。 要阻止特定事件的默认行为，使用preventDefault()。比如链接的默认行为是单击时调到Href指定的链接。（cancelable为true的事件才能使用） 要阻止事件在DOM中的传播，即取消进一步的事件捕获或冒泡使用stopPropagation()。 要确定事件当前处于事件流的哪个阶段，使用eventPhase属性：1代表事件捕获阶段，2代表事件处理程序处于目标对象上（实际上这是在冒泡阶段），3是指在冒泡阶段调用的事件处理程序。123456789101112var btn = document.getElementById('mybtn');btn.onclick = function (event) &#123; alert(event.eventPhase);//2&#125;document.body.addEventListener(\"click\", function (event) &#123; alert(event.eventPhase);//1&#125;,true);document.body.onclick = function (event) &#123; alert(event.eventPhase);//3&#125; 弹出顺序为：1 2 3；首先是body中捕获阶段会弹出1；接着是处于目标状态上的事件处理程序；最后是冒泡阶段，在body中，显示3。 IE中的事件对象访问IE中的event对象有几种方式，取决于指定事件处理程序的方法。DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。即event = window.event。IE事件处理方法添加事件处理程序时，就是直接的event对象传入函数中。HTML特性指定的事件处理程序能直接使用event的变量访问event对象HTML DOM Event 对象。之前说过，this在事件处理程序中的指向随着方法的不同而不同，因此使用event.srcElement比较保险。此外，returnValue属性相当于DOM中的preventDefault()方法，设置为false阻止默认行为。而cancelBubble属性与stopPropagation()方法作用相同，阻止事件冒泡。这两种属性用在window.event中。 ##跨浏览器的事件对象123456789101112131415161718192021222324252627282930313233343536373839404142434445var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, getEvent: function (event) &#123; return event ? event : window.event; &#125;, getTarget: function (event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function (element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, stopPropagation: function (event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 都很好理解，不详细说了。 参考书目：《JavaScript高级程序设计》","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"JavaScript事件(1)","slug":"JavaScript事件-1","date":"2015-03-28T01:46:16.000Z","updated":"2015-05-01T08:54:15.000Z","comments":true,"path":"2015/03/28/JavaScript事件-1/","link":"","permalink":"http://weibo.com/biousco/2015/03/28/JavaScript事件-1/","excerpt":"本来以为页面做的差不多了。后来发现移动端和PC端一样有好多坑要填=。=干了几天感觉恶补了JS什么的。这次主要总结一下JS中的事件。 事件流事件流描述的是从页面中接受事件的顺序。 事件冒泡IE的事件流，事件开始时由最具体的元素接收，逐级向上传播到较为不具体的结点。还是很好理解的。。比如：1234567&lt;!DCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;ddd&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单击&lt;div&gt;元素，Click事件就会从&lt;div&gt;到&lt;body&gt;到&lt;html&gt;到document。就像冒泡一样。所有浏览器都支持，IE5.5之前会跳过&lt;html&gt;。现代浏览器冒泡到window对象。 事件捕获顺序和冒泡相反，由Netscape Communicator团队提出，现代浏览器也支持这种事件流模型。”DOM2级事件”规范要求事件从document对象开始传播，但是现代浏览器从window对象开始。 DOM事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。事件捕获阶段为截获事件提供了机会；然后是实际的目标接收到事件；最后的冒泡阶段可以在这个阶段对事件做出相应。就像先事件捕获（不包括目标div）然后在处于目标阶段，事件在div上发生，然后开始冒泡。规范要求捕获阶段不会涉及事件目标，但是现代浏览器会在捕获阶段触发事件对象上的事件。因此有两个机会在目标对象上操作事件。兼容性：IE8及之前不支持。","text":"本来以为页面做的差不多了。后来发现移动端和PC端一样有好多坑要填=。=干了几天感觉恶补了JS什么的。这次主要总结一下JS中的事件。 事件流事件流描述的是从页面中接受事件的顺序。 事件冒泡IE的事件流，事件开始时由最具体的元素接收，逐级向上传播到较为不具体的结点。还是很好理解的。。比如：1234567&lt;!DCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;ddd&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单击&lt;div&gt;元素，Click事件就会从&lt;div&gt;到&lt;body&gt;到&lt;html&gt;到document。就像冒泡一样。所有浏览器都支持，IE5.5之前会跳过&lt;html&gt;。现代浏览器冒泡到window对象。 事件捕获顺序和冒泡相反，由Netscape Communicator团队提出，现代浏览器也支持这种事件流模型。”DOM2级事件”规范要求事件从document对象开始传播，但是现代浏览器从window对象开始。 DOM事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。事件捕获阶段为截获事件提供了机会；然后是实际的目标接收到事件；最后的冒泡阶段可以在这个阶段对事件做出相应。就像先事件捕获（不包括目标div）然后在处于目标阶段，事件在div上发生，然后开始冒泡。规范要求捕获阶段不会涉及事件目标，但是现代浏览器会在捕获阶段触发事件对象上的事件。因此有两个机会在目标对象上操作事件。兼容性：IE8及之前不支持。 事件处理程序相应某个事件的函数就是事件处理程序（事件侦听器）。名字以”on”开头。 HTML事件处理程序&lt;input type=&quot;button&quot; value=&quot;Click me&quot; onclick=&quot;alert(&#39;Clicked&#39;)&quot; /&gt;某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定，这个特性的值是能够执行的JavaScript代码。不能使用未转义的HTML语法字符：&amp; “” &lt; &gt;。可以改写：&amp;quot代替双引号。也可以调用函数：onclick=&quot;showMessage()代码执行时有权利访问全局作用域中的任何代码。使用这种方法会创建一个封装着元素属性值的函数。包含一个局部变量event（事件对象）。通过这个变量可以直接访问事件对象。比如：onclick=&quot;alert(event.type)&quot;会输出”click”。在这个函数内部，this为事件的目标元素。另外，这个动态创建的函数可以访问document及该元素本身的成员。这个函数内部实现是通过with()来延长作用域。如果当前元素是表单输入元素，作用域还会包含表单元素的入口：123456789function () &#123; with(document)&#123; with(this.form)&#123; with(this)&#123; //元素属性值 &#125; &#125; &#125;&#125; 所以可以直接访问其他表单的字段：username.value。这种方式的缺点： 用户在点击按钮触发事件的时候函数还未解析完成，会导致错误。因此需要放在try-catch块中。 HTML代码和JavaScript代码紧密耦合。 DOM0级事件处理程序传统的通过JavaScript指定事件处理程序的方式，将一个函数赋值给一个事件处理程序属性。具有简单，跨浏览器的优势。1234var btn = document.getElementById('mybtn');btn.onclick = function () &#123; alert(this.id);&#125; 先取得一个对象的引用，再指定事件处理程序。在这些代码运行之前不会指定事件处理程序，所以如果代码在按钮后面，一段时间内是不会触发事件的。这种方法事件处理程序被认为是元素的方法，在元素的作用域中运行，this指向当前元素。这种方式添加的事件处理程序会在冒泡阶段处理。删除：btn.onclick = null; DOM2级事件处理程序定义了两个方法：addEventListener()和removeEventListener()。所有DOM结点都包含这两种方法，接受三个参数：要处理的事件名称，事件处理函数，是否在捕获阶段调用事件处理函数的布尔值（当为false时，在冒泡阶段调用）。1234var btn = document.getElementById('mybtn');btn.addEventListener(\"click\",function () &#123; alert(this.id);&#125;,false); 这种方法的好处是可以添加多个时间处理程序，并且按照添加的顺序触发。移除事件处理程序只能用removeEventListener()，并且传入的参数要和添加的参数相同。所以一般是这样：123456var btn = document.getElementById('mybtn');var handler = function () &#123; alert(this.id);&#125;btn.addEventListener(\"click\",handler,false);btn.removeEventListener(\"click\",handler,false); 大多数情况下在冒泡阶段处理，保证兼容性。 IE事件处理程序两个方法：attachEvent()和detachEvent()。接受两个参数：事件处理名称和事件处理函数。因为IE8-只支持冒泡，所以这种方式添加的事件处理程序都会被添加到冒泡阶段。1234var btn = document.getElementById('mybtn');btn.attachEvent(\"onclick\",function () &#123; alert(\"Clicked\");&#125;) 这种方法和DOM0级方法的区别在于事件处理程序的作用域。这里的方法会在全局作用域内运行，所以this等于window。这种方法也可以添加多个事件处理程序，但按照相反的添加顺序执行。 参考书目：《JavaScript高级程序设计》","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"JS-OJ(1)","slug":"JS-OJ-1","date":"2015-03-22T01:39:52.000Z","updated":"2015-05-01T08:55:20.000Z","comments":true,"path":"2015/03/22/JS-OJ-1/","link":"","permalink":"http://weibo.com/biousco/2015/03/22/JS-OJ-1/","excerpt":"最近在做LeetCode有各种语言。刚好有JavaScript。做做算法的同时也能熟悉JS。 Number of 1 Bits Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 1234567891011var hammingWeight = function(n) &#123; var bits = n.toString(2); var pos = bits.indexOf(\"1\"); var i = 0; while(pos &gt; -1) &#123; i++; pos = bits.indexOf(\"1\",pos+1); &#125; return i; &#125;; 求汉明重量。就是找出一个二进制的数字中有多少个1。直接用最暴力的方法就是转化之后一个个数出来。Number类型的toString()方法返回字符串形式的数值，传递一个表示基数的参数能返回对应进制。String类型的indexOf()从字符串中搜索给定的子字符串，返回位置。第二个参数表示从字符串中的哪个位置开始搜索。上面的方法就是遍历一个字符串的感觉了看C的解法都是右移啊，与运算啊什么的。1234567891011var hammingWeight = function(n) &#123; var re = 0; while(0 !== n) &#123; n = n&amp;(n-1); ++re; &#125; return re;&#125;; 可是这个解法用的时间比我前面的解法还要多几毫秒。然后用上面的位运算换成C语言来写。结果吓尿了哈哈：JS用了170msc用了1ms…根本不是一个重量级啊…Number of 1 Bits","text":"最近在做LeetCode有各种语言。刚好有JavaScript。做做算法的同时也能熟悉JS。 Number of 1 Bits Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 1234567891011var hammingWeight = function(n) &#123; var bits = n.toString(2); var pos = bits.indexOf(\"1\"); var i = 0; while(pos &gt; -1) &#123; i++; pos = bits.indexOf(\"1\",pos+1); &#125; return i; &#125;; 求汉明重量。就是找出一个二进制的数字中有多少个1。直接用最暴力的方法就是转化之后一个个数出来。Number类型的toString()方法返回字符串形式的数值，传递一个表示基数的参数能返回对应进制。String类型的indexOf()从字符串中搜索给定的子字符串，返回位置。第二个参数表示从字符串中的哪个位置开始搜索。上面的方法就是遍历一个字符串的感觉了看C的解法都是右移啊，与运算啊什么的。1234567891011var hammingWeight = function(n) &#123; var re = 0; while(0 !== n) &#123; n = n&amp;(n-1); ++re; &#125; return re;&#125;; 可是这个解法用的时间比我前面的解法还要多几毫秒。然后用上面的位运算换成C语言来写。结果吓尿了哈哈：JS用了170msc用了1ms…根本不是一个重量级啊…Number of 1 Bits Reverse Bits Reverse bits of a given 32 bits unsigned integer.For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000). 123456789101112131415161718192021/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; - a positive integer */var reverseBits = function(n) &#123;var bits = n.toString(2);var length = bits.length;var newbits = \"\";for(var i = bits.length;i&lt;32;i++)&#123; bits = \"0\".concat(bits);&#125;length = bits.length; while(length--)&#123; newbits = newbits.concat(bits[length]);&#125; return parseInt(newbits,2);&#125;; 没找到直接把数字类型中转换为32位的方法。直接手动写成了。。原来弱类型的语言有这个坏处。以前一直觉得弱类型好好，不用考虑太多。太年轻啦。然后是字符串的转置（后面还有一种方法），最后再转成数字。parseInt(),第二个参数是以此为基数转化字符串。和toString()有点类似呢。。Reverse Bits Rotate Array Rotate an array of n elements to the right by k steps.For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) &#123; k = k%nums.length;var Reverse = function(arr,begin,end)&#123; for(;begin&lt;end;begin++,end--)&#123; arr[begin] ^= arr[end]; arr[end] ^= arr[begin]; arr[begin] ^= arr[end]; &#125;&#125;;Reverse(nums,0,nums.length-k-1);Reverse(nums,nums.length-k,nums.length-1);Reverse(nums,0,nums.length-1);&#125;; 传说中的无空间交换数字大法。。。一个数字异或两次等于他本身。 123a = a ^ b;b = a ^ b;a = a ^ b; 看起来逼格很高的样子。。然后就是ba = (a*b*)* *是转置的意思。嗯就是这样，编程珠玑的解法。Rotate Array Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!.Note: Your solution should be in logarithmic time complexity. 123456789101112/** * @param &#123;number&#125; n * @return &#123;number&#125; */var trailingZeroes = function(n) &#123; var count = 0; while(n)&#123; count += Math.floor(n/5); n /= 5; &#125; return count;&#125;; 这些简单的题目解法也是好简洁啊。不过想了很久都不知道怎么做。还是看了一下答案。尾数为0只能是25；所以可以把n!分解为2^n5^m;因此0的个数是min(n,m);又因为在阶乘里，必然有n&gt;m；所以求出n!里有多少个5就好了。Factorial Trailing Zeroes","categories":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/categories/JS/"}],"tags":[{"name":"JS 算法","slug":"JS-算法","permalink":"http://weibo.com/biousco/tags/JS-算法/"}]},{"title":"重构练习-1","slug":"重构练习-1","date":"2015-03-16T12:01:59.000Z","updated":"2015-05-01T08:55:37.000Z","comments":true,"path":"2015/03/16/重构练习-1/","link":"","permalink":"http://weibo.com/biousco/2015/03/16/重构练习-1/","excerpt":"前面太自大了。。怎么能叫前端呢。还只是重构一只呀。 Rating星星的CSS基本实现html:1234567&lt;div class=\"rating right\"&gt; &lt;i class=\"fa fa-star hover\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star hover\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star hover\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star\"&gt;&lt;/i&gt;&lt;/div&gt; less:123456789101112131415161718192021.rating&#123; unicode-bidi: bidi-override; direction: rtl; text-align: center; i&#123; color: #E4E4E4; cursor: pointer; position: relative; &#125;&#125;.rating &gt; i:hover,.rating &gt; i:hover ~ i&#123; color: transparent;&#125;.rating &gt; i:hover:before,.rating &gt; i:hover ~ i:before&#123; content: '\\f005'; color: #FFDF56;&#125;","text":"前面太自大了。。怎么能叫前端呢。还只是重构一只呀。 Rating星星的CSS基本实现html:1234567&lt;div class=\"rating right\"&gt; &lt;i class=\"fa fa-star hover\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star hover\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star hover\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star\"&gt;&lt;/i&gt; &lt;i class=\"fa fa-star\"&gt;&lt;/i&gt;&lt;/div&gt; less:123456789101112131415161718192021.rating&#123; unicode-bidi: bidi-override; direction: rtl; text-align: center; i&#123; color: #E4E4E4; cursor: pointer; position: relative; &#125;&#125;.rating &gt; i:hover,.rating &gt; i:hover ~ i&#123; color: transparent;&#125;.rating &gt; i:hover:before,.rating &gt; i:hover ~ i:before&#123; content: '\\f005'; color: #FFDF56;&#125; 首先是一个css属性：unicode-bidi: bidi-override;CSS unicode-bidi 属性 定义unicode-bidi 属性设置文本的方向。 可能的值normal元素不会对双向算法打开附加的一层嵌套。对于行内元素，顺序的隐式重排会跨元素边界进行。embed如果是一个行内元素，这个值对于双向算法会打开附件的一层嵌套。这个嵌套层的方向由 direction 属性指定。会在元素内部隐式地完成顺序重排。这对应于在元素开始处增加一个 LRE（对于 direction:ltr ：U+202A）或 RLE（对于 direction:rtl ：U+202B），并在元素的最后增加一个 PDF（U+202C）。bidi-override这会为行内元素创建一个覆盖。对于块级元素，将为不在另一块中的行内后代创建一个覆盖。这说明，顺序重排在元素内部严格按照 direction 属性进行；忽略了双向算法的隐式部分。这对应于在元素开始处增加一个 LRO（对于 direction:ltr ：U+202D）或 RLO（对于 direction:rtl ：U+202E），并在元素最后增加一个 PDF（U+202C）。 啊我看不懂。第二个：direction: rtl;设置方向，rtl是right to left的意思。第三个：~选择器：CSS3 element1~element2 选择器例如：p~ul是为所有相同的父元素中位于 p 元素之后的所有 ul 元素设置样式；这里还用了Font-Awesome 实现原理：先写好基本的HTML结构，以及CSS，包括鼠标移上去的时候变成黄色。然后CSS里面是没有选择某个元素之前的所有元素的选择器，只有向后选择，就是那个~。但是我们变色是需要将前面的星星也变成黄色。所以我们需要改变文本的方向：direction: rtl;，改变之后就能实现对前面的i元素也变色的效果了。不过这么做只是鼠标移上去的时候前面变色，要实现点击的时候固定颜色，还是要用到JS的：123456789101112131415161718192021222324252627(function (window,namespace) &#123; var rating_wrap,star; function clear () &#123; for (var i = 0; i &lt; star.length; i++) &#123; removeClass(star[i],'hover'); &#125; &#125; function paint (index) &#123; clear(); for (var j = star.length - 1; j &gt;= index; j--) &#123; star[j].className += ' hover'; &#125; &#125; window[namespace] = function (ratingId) &#123; rating_wrap = getId(ratingId); star = rating_wrap.getElementsByTagName('i'); for (var i = star.length - 1 ; i &gt;= 0 ; i--) &#123; star[i].index = i; addEvent(star[i],'click',function () &#123; paint(this.index); &#125;); &#125; &#125;;&#125;)(window,'Rating'); 我已经完全爱上这种写法了。。当然做出来还需要给后台传值。 参考资料：Star Ratings With Very Little CSS实际效果：Shop_Detail 重构一些笔记 最外层设置min-width 为了防止背景色背景图消失什么的，也可以避免在内层容器设置背景 使用雪碧图来绘制图标 好处多多：CSS雪碧 解决了用CSS3的兼容性，圆角什么的~ 图标小移动使用雪碧图实现 .ico:hover{background-position: 0 -10px}像这样，可以实现黑白然后变色的效果，可以加上transition。 不使用浮动小技巧：一个设置padding-right，剩下一个使用绝对定位. 应用在一些小范围的地方，右边一般是一个小小的图片。此外还可以应用在列表项前的个性小图标，但是不是使用绝对定位，而是使用padding-left 见第九条 &lt;em&gt; 标签告诉浏览器把其中的文本表示为强调的内容。对于所有浏览器来说，这意味着要把这段文字用斜体来显示。 在用的时候可以一开始就先重置这一类标签：font-style:normal;font-weight:normal这样可以利用这些内联标签来设置小图标，或者是文字效果。 雪碧图：两个位置 background-position 两个属性值分别代表水平距离和纵向距离，使用负数。其余背景使用transparent透明，一般像这样：background:url(../img/a.png) no-repeat scroll 0 -15px transparent; 使用padding-left 来放雪碧图，margin-left控制左右距离 IE7下面不支持a标签的Inherited。定义颜色还是直接定义吧。注意IE8下要写HTML5的兼容代码(Js) 给ul加上类，设置外边距和宽度，在li中设置高度，在a中设置内边距横向列表最后一个没有边距的时候，可以取巧使用mr30这样单独的类来达到效果 令table充满容器。自动调整每个单元格的大小 float:left会使得元素变成块级元素 对图像用vertical-aligin:middle 消除一些奇怪的距离。 不要把高度和padding设在一起啊啊啊啊啊 设计师会标出设计图里面的默认padding什么的，可以预先设计一个类比如.p20``.p_20表示padding:20px``padding:0 20px之类的。 为什么我就是没遇到这种设计师呢啊啊啊啊啊每次量距离好想哭啊。 直接接触外层大容器的小容器不要使用margin-top会影响外层，没有间隔效果 解决办法：overflow:hidden或者设置父容器的padding border，随便一个为1像素。或者用padding-top代替。 使用浮动设置宽度 对a使用inline-block可以使得不会整块都有cursor:pointer.但如果要换行就需要使用br.否则就用block 使用span作为容器放置图片时，可以使用tac来使之居中 但是需要设置span 为inline-block 设置宽度 横向图文混杂小块可以用dl dt(img) dd(h p)。 多个这样的东西可以多个dl。 这次笔记是在这个页面：你我贷兼容性到IE6啊简直业界良心（其实就是我以前没有好好按规范打。。。。。）","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"重构","slug":"重构","permalink":"http://weibo.com/biousco/tags/重构/"}]},{"title":"兼容性小结(1)","slug":"兼容性小结-1","date":"2015-03-16T11:41:05.000Z","updated":"2015-05-01T08:56:53.000Z","comments":true,"path":"2015/03/16/兼容性小结-1/","link":"","permalink":"http://weibo.com/biousco/2015/03/16/兼容性小结-1/","excerpt":"开学了。我又忘记更博了。啊~ 这次记录了一些兼容性的东西： RM8005: IE6 IE7 IE8(Q)行内元素后相邻的浮动元素在某些情况下会折行放置在之前行内元素所在行框的底部。 W3C CSS 2.1 规范文档里对于浮动元素与非浮动行内元素相邻时的情况有如下解释。以下是关键段落：A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float. If there’s a line box, the top of the floated box is aligned with the top of the current line box. 由上面的描述可以得到以下结论：如果一个元素浮动前是一个行内元素，则该元素浮动后，顶部应与其之前所在的行框顶部对齐。 此问题的触发条件:同一个父容器内有多个行内元素；某些为非浮动元素，某些为浮动元素（可以是左浮动或右浮动）；浮动的子元素不都是位于非浮动的子元素之前。","text":"开学了。我又忘记更博了。啊~ 这次记录了一些兼容性的东西： RM8005: IE6 IE7 IE8(Q)行内元素后相邻的浮动元素在某些情况下会折行放置在之前行内元素所在行框的底部。 W3C CSS 2.1 规范文档里对于浮动元素与非浮动行内元素相邻时的情况有如下解释。以下是关键段落：A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float. If there’s a line box, the top of the floated box is aligned with the top of the current line box. 由上面的描述可以得到以下结论：如果一个元素浮动前是一个行内元素，则该元素浮动后，顶部应与其之前所在的行框顶部对齐。 此问题的触发条件:同一个父容器内有多个行内元素；某些为非浮动元素，某些为浮动元素（可以是左浮动或右浮动）；浮动的子元素不都是位于非浮动的子元素之前。 解决方案依具体情况可以使用三种方法：使用绝对定位模拟右浮动、使用 IE hack 专门在IE6 IE7 中设置负的上外边距、将右浮动的 SPAN 元素调整到所有非浮动 SPAN 元素之前。 使用绝对定位（position:absolute）模拟右浮动（float:right）。 但这样做的代价是必须为父容器 DIV 元素设置 ‘postion:relative’，这么做仍然会破坏原文档结构。所以我们并不推荐此方法。 使用 IE hack 专门在IE6 IE7 中设置负的上外边距（margin-top:-XXXpx）。 既然此 Bug 为IE6 IE7 专有，则只需要在 IE6 IE7下为右浮动元素设置一个负的上外边距即可，其他浏览器保持原样式。所以可以考虑使用只有 IE6 IE7支持的 hack 方式：在 CSS 特性前加星号 ‘‘。如 margin:-23px 5px 0 0，这样既可消除 IE6 IE7 中的 Bug，但是这么做是利用了浏览器的 Bug，并没有消除 Bug。在能有个更好的解决方法的时候，不推荐使用 CSS hack 来解决问题。 调整SPAN元素的位置。 通过上面总结的 Bug 触发条件，我们可以考虑直接调整父容器中 SPAN 子元素的位置来回避 IE6 IE7 中此 Bug，即将右浮动的 SPAN 元素调整到所有非浮动 SPAN 元素之前。 RM8005: IE6 IE7 IE8(Q) 中行内元素后相邻的浮动元素在某些情况下会折行放置在之前行内元素所在行框的底部 RD8008IE6 IE7(Q) IE8(Q) 绝对定位元素无法根据其四个方向的偏移量自动计算其尺寸 问题描述IE6 及 IE7/8 的混杂模式下，非替换绝度定位元素当指定了 ‘left’ 及 ‘right’，而 ‘width’ 为默认值 “auto” 。此时浏览器无法正确地计算出 ‘width’ 的值，对于高度的计算也是如此。 解决方案若能为非替换绝对定位元素设定固定的宽度及高度，则尽量不使用此方式自动计算绝对定位元素的 ‘width’ 及 ‘height’；若无法避免使用此方式，则可以通过判断浏览器，仅在 IE6 中使用 CSS Expression 控制绝对定位元素的宽度及高度。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; #d &#123; background-color: black; position: absolute; left: 10px; right: 10px; top: 10px; bottom: 10px; color: white; _width: expression( parseInt(this.offsetParent.currentStyle.width) - parseInt(this.currentStyle.left) - parseInt(this.currentStyle.right) ); _height: expression( parseInt(this.offsetParent.currentStyle.height) - parseInt(this.currentStyle.top) - parseInt(this.currentStyle.bottom) ); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"background-color:gray;width:100px;height:100px;position:relative\"&gt; &lt;div id=\"d\"&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; RD8008: IE6 IE7(Q) IE8(Q) 绝对定位元素无法根据其四个方向的偏移量自动计算其尺寸 一个很好的网站：W3Help内容包括几乎所有的兼容性问题。以及各种浏览器标准，HTML/CSS规范。 IE8+兼容性小结 DOCTYPE 使用meta标签调节浏览器的渲染方式 Media Query 实现CSS3的某些特性 识别HTML5元素 关于max-width 嵌套inline-block下padding元素重叠 last-child background-size: cover IE8+兼容经验小结","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://weibo.com/biousco/tags/兼容性/"}]},{"title":"移动端重构小节(2)","slug":"移动端重构小节-2","date":"2015-03-04T14:57:55.000Z","updated":"2015-05-01T08:55:50.000Z","comments":true,"path":"2015/03/04/移动端重构小节-2/","link":"","permalink":"http://weibo.com/biousco/2015/03/04/移动端重构小节-2/","excerpt":"话说这个寒假还是学了不少东西的哈哈。不过做项目的时候还是感觉自己能力很不足很不足很不足（重要的事情说三遍）要多学习多学习多学习。其实做项目提升还是很大的。 看到什么就写什么。 媒体查询做移动端和PC端会用到的东西。这也是高大上的（对我来说）响应式布局。CSS3 @media 查询仔细再看一遍才发现有些地方误解了。语法：123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 之前用的是@media all and (max-width:640px)以为前面的all是所有的尺寸=。=其实前面的是媒体类型，后面的是媒体功能。媒体类型主要使用：all print screen speech。看来一般用all了。媒体功能就很多了，这里不写。一般是定义大小和分辨率。兼容性：IE9以下需要引入JS文件：Respond.js。放到底部，并且要http协议才能用。当然会有一点延迟啦。写在媒体查询之外的样式会应用在全网页。后面做一个项目的时候用响应式设计，刚开始做的是移动端，设计师切好图我就直接写了。然后发现一个坑爹的事情，导致我拿到PC端的设计图时内心几乎是崩溃的。以后最好提前和设计师沟通，不然就是在给自己挖好多好多的坑（啊）。反正以后我重构不会让设计师帮我切图了。做这个的时候多分组吧。把内容区块包好。在不同的大小下一般是用浮动来控制内容的位置。","text":"话说这个寒假还是学了不少东西的哈哈。不过做项目的时候还是感觉自己能力很不足很不足很不足（重要的事情说三遍）要多学习多学习多学习。其实做项目提升还是很大的。 看到什么就写什么。 媒体查询做移动端和PC端会用到的东西。这也是高大上的（对我来说）响应式布局。CSS3 @media 查询仔细再看一遍才发现有些地方误解了。语法：123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 之前用的是@media all and (max-width:640px)以为前面的all是所有的尺寸=。=其实前面的是媒体类型，后面的是媒体功能。媒体类型主要使用：all print screen speech。看来一般用all了。媒体功能就很多了，这里不写。一般是定义大小和分辨率。兼容性：IE9以下需要引入JS文件：Respond.js。放到底部，并且要http协议才能用。当然会有一点延迟啦。写在媒体查询之外的样式会应用在全网页。后面做一个项目的时候用响应式设计，刚开始做的是移动端，设计师切好图我就直接写了。然后发现一个坑爹的事情，导致我拿到PC端的设计图时内心几乎是崩溃的。以后最好提前和设计师沟通，不然就是在给自己挖好多好多的坑（啊）。反正以后我重构不会让设计师帮我切图了。做这个的时候多分组吧。把内容区块包好。在不同的大小下一般是用浮动来控制内容的位置。 图片移动端上的一个像素并不是电脑上的一个像素。一般是两个。所以在使用图片的时候，拿到640的设计图切成360的图片来使用时，在高分辨率的屏幕上看起来是很模糊的。所以图片一般还是原来的640下的大小，使用的时候规定一半的尺寸。这样在手机上看起来就会很清晰。图片可以两种办法来引用： 直接用&lt;img&gt;标签。缺点是不能在不同分辨率下换图片。不过定好大小兼容性就比较好。 使用&lt;div&gt;标签，用CSS设置背景图片来设置图片路径。偏向用这种，可以在媒体查询的时候换图片。但是在使用的时候可能会用到一个属性：backgroud-size这个属性在IE9以下有兼容性问题。在做后面的页面时这两种都一起用了。不过还是根据情况的不同有取舍。 背景图片backgroud-size: 100px 100px这样做就和直接用&lt;img&gt;定义长宽效果一样了。设置的大小比背景图片的尺寸小可以让背景很清晰。当最终效果比父容器大时会隐藏掉超出的部分。 background-size:100% auto让背景图片以容器的宽为基准显示，能完全显示图片。auto不写就是默认值。当背景图片的宽比容器的宽更长的时候，宽自动等比例压缩，高也会变小，有可能出现不能完全覆盖容器的情况。和contain效果一样。 background-size:100% 100% 让背景图片以以父元素的百分比来设置背景图像的宽度和高度。容器比例和背景图片不一样时会变形。但是。有时候为了尽可能的让不同大小的屏幕都有设计图那样类似的背景位置效果，设置background-size为100% 45%之类的可以达到。根据需要还可以加上：background-position:0 0来确定显示的位置。也是用在雪碧图里。 background-size:cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。会隐藏掉超出的部分。 这些情况都用需要定容器的宽和高。不过这个属性有兼容性问题。比较蛋疼。简单但是麻烦的办法是，切图的时候刚好切成容器的宽和高。测试地址：css_background-size 展示图片有种接近全屏的图片，可以用上面的方法，也可以单独写一个&lt;img&gt;设置成宽100%，在父容器高度确定具体大小，超出的部分就隐藏。我用的是高宽都是100%，这样会随着屏幕的宽变大，图片变宽，高度也变高，图片不会变形。不过这样就不适合那些定好高度的容器了。就是上面写的那种，需要隐藏掉。 并排按钮第一次做的时候是固定了按钮的宽和高，用具体的数值。但是拉伸屏幕的时候就悲剧了。而且开始是用浮动，都是向左，设定外边距。后来就换了一种方式，先用媒体查询，一般分界线是640PX，按钮用百分比设定长宽，一个向左一个向右浮动。（欸那三个按钮怎么办 da she ji shi）。找到具体的案例再看看。 ##JS和动画其实一般的动画还是很简单的，无非就是点击变色，做单选效果，切换标签。前面用的知识就足够解决了。还有就是一些数据先处理好放在隐藏的input标签内再发送给后台。不用&lt;input type=&quot;submit&quot;&gt;使用&lt;a&gt;标签可以很方便的控制按钮的样式，在提交的时候写JS处理函数就好了：&lt;a href=&quot;#&quot; class=&quot;submit-btn&quot; onclick=&quot;submit_select()&quot;&gt;提交&lt;/a&gt;12345678function submit_select () &#123; var input = document.getElementById('input'); var strings = getselect_String(); input.value = strings; console.log(strings); var form = document.getElementById('form'); form.submit();&#125; 其实还是很简单的。不过在做TAB切换的时候发现后台有一些要求，用到了ajax:123$.get('http://localhost/mobile1/form_content.php?date='+date,function(data,status)&#123; $(\".content_list\")[0].innerHTML=data;&#125;) 其实就是把TAB切换的每个TAB的内容都分别从服务器获取再放到HTML里面。做这个的时候应该开wamp来测试。本地会有同源策略阻止访问。另外还用到了一个滚动的JS插件：iScroll 5。教程很多可是都是4的呵呵。不过也差不多了。使用的时候加载需要一些时间，滑动在电脑上感觉很好但是手机上就有点。。估计是我没有优化好的原因。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://weibo.com/biousco/categories/移动端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"移动端","slug":"移动端","permalink":"http://weibo.com/biousco/tags/移动端/"}]},{"title":"移动端重构小结(1)","slug":"移动端重构小结-1","date":"2015-03-04T13:43:26.000Z","updated":"2015-05-01T08:55:47.000Z","comments":true,"path":"2015/03/04/移动端重构小结-1/","link":"","permalink":"http://weibo.com/biousco/2015/03/04/移动端重构小结-1/","excerpt":"前言：我是大懒虫Orz。一个月没有更新了=。=检讨一下。主要是在做一个移动端的app网页还有完成QT的作业还有过年还有益米的事情。真的要好好总结一下才能提升自己！ 初始化meta标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;移动端的页面一定会用到的meta标签。相关概念： meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持 主要参数有下面几个： maximum-scale：用户可以缩放的最大值 minimum-scale：用户可以缩放的最小值 initial-scale：viewport的默认缩放大小 width：固定viewport的宽度 height：固定viewport的高度 user-scalable：是否允许用户缩放 前三个参数都是缩放相关的，它们的值是viewport的缩放大小，他们仅仅改变缩放大小，并不是改变viewport的实际大小。 之后就是width和height，修改这俩东西就和我们在PC上访问网页时候用鼠标拖动浏览器来改变大小一样。或者说是浏览器（页面区域）在屏幕上的默认大小。可以是具体的数值，也可以用“device-width”和“device-height”把它设置成浏览器屏幕的大小。比如要把页面宽度固定到浏览器的屏幕上，防止出现横向滚动条就可以使用 最后一个是指定是否允许用户自己缩放，也就是用户通过两个手指触屏来缩放的方式。默认都是允许的值为1，如果要禁止可以把它的值设置为0。就像下面这样 参考：移动端的meta viewport 更详细的文章：移动前端开发之viewport的深入理解","text":"前言：我是大懒虫Orz。一个月没有更新了=。=检讨一下。主要是在做一个移动端的app网页还有完成QT的作业还有过年还有益米的事情。真的要好好总结一下才能提升自己！ 初始化meta标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;移动端的页面一定会用到的meta标签。相关概念： meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持 主要参数有下面几个： maximum-scale：用户可以缩放的最大值 minimum-scale：用户可以缩放的最小值 initial-scale：viewport的默认缩放大小 width：固定viewport的宽度 height：固定viewport的高度 user-scalable：是否允许用户缩放 前三个参数都是缩放相关的，它们的值是viewport的缩放大小，他们仅仅改变缩放大小，并不是改变viewport的实际大小。 之后就是width和height，修改这俩东西就和我们在PC上访问网页时候用鼠标拖动浏览器来改变大小一样。或者说是浏览器（页面区域）在屏幕上的默认大小。可以是具体的数值，也可以用“device-width”和“device-height”把它设置成浏览器屏幕的大小。比如要把页面宽度固定到浏览器的屏幕上，防止出现横向滚动条就可以使用 最后一个是指定是否允许用户自己缩放，也就是用户通过两个手指触屏来缩放的方式。默认都是允许的值为1，如果要禁止可以把它的值设置为0。就像下面这样 参考：移动端的meta viewport 更详细的文章：移动前端开发之viewport的深入理解 css做这个小项目的时候参考了其他的移动端网页。（第一次做很没底）看到微店是固定的宽度：Woody的书屋body{max-width:640px}并居中。然后我就模仿了。在看它的HTML中顺便下载了它的css文件，base.css 里面都是一些基础样式，用处体现在写HTML的时候就顺便写了基本的布局CSS，像.margin-auto``txt_l什么的都是根据字面意思都能知道用上的CSS。不过其实这样感觉有点破坏了HTML的纯洁性呢~还是比较偏向用有语义的类名。而且这样很容易把类名写的很长很长：&lt;section class=&quot;main-content margin_auto clear-fix&quot;&gt;好吧这个还是算短的。 font-awesome网页中用到挺多的图标，心想用图片太累赘了，找了一下就用上了字体图标。Font Awesome Icons效果很好，虽然有些图标和设计图不太一样不过。嗯，我就用了！用法还是很简单的，&lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt;代表向左的箭头，通用类名是fa； 然后是各个图标的类名，在官网上查找就好。大部分基础的都有；要调整大小用fa-lg也可以更大。第一次用的时候把他包在a标签里面，然后发现居中就很蛋疼了。其实所有的图标居中都比较蛋疼。。用text-align:center可以水平居中，但是垂直居中就不行了。因为高度都不一样，vertical-align:middle也不行。某些实在不行的就用绝对定位了。在后面用到的一个感觉比较好的：1234567891011121314.link a &#123; color: #FFF; float: left; display: block; height: 20px; width: 20px; line-height: 20px; text-align: center; border-radius: 50%; background-color: #323232; padding: 7px; margin-right: 9px; box-shadow: 1px 1px 2px rgba(255, 255, 255, 0.07), inset 1px 1px 1px rgba(78, 78, 78, 0.26);&#125; 直接用a标签包住，能居中。 LESS发现上面写的CSS怎么这么看起来好工整~原来是LESS生成的。写LESS和CSS其实差不多。不过现在好喜欢用LESS哈，写起来有逻辑，而且方便。先装一个东西叫koala一只树袋熊~上手后就可以直接写LESS自动编译成CSS。LESS有几个特性：变量，函数，混入。主要也是用到这几个。 变量变量用的比较少。估计我还没养成好习惯吧，很多的padding可以重用但是我不知道或者我太懒了就直接再写一遍=。= 函数函数我用来处理兼容性了：123456789.linear-gradient(@direction,@color-bottom,@color-top)&#123; background-image: -webkit-linear-gradient(@direction, @color-bottom,@color-top); background-image: -moz-linear-gradient(@direction, @color-bottom,@color-top); background-image: -ms-linear-gradient(@direction, @color-bottom,@color-top); background-image: linear-gradient(@direction, @color-bottom,@color-top); @startcolor : argb(@color-bottom); @endcolor : argb(@color-top); filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=@startcolor, endColorstr=@endcolor,GradientType=0 ); &#125; 上面这个是渐变（比较简单和单一的线性渐变）。最后一个是兼容IE8以下的滤镜。用到了LESS的内置函数：argb()；方便地转换颜色格式~滤镜要用到#AARRBBGG格式的颜色，内置函数可以直接互相转化（颜色好像是一种变量类型） 混入很重要的一个概念，也是我为什么好喜欢用LESS的原因：12345678910111213141516171819202122232425262728.pageheader nav &#123; top: 70px; left: 202px; background: url(../images/nav-bg.png) repeat; border-top: 1px solid #1D1D1D; border-bottom: 2px solid #161616; li&#123; float: left; border-left: 1px solid #1D1D1D; a&#123; font: normal 14px/14px \"OpenSansRegular\"; display: block; height: 17px; padding: 15px 22px; color: #FFF; font-size: 14px; line-height: 14px; text-align: center; border-left: 1px solid #404040; border-top: 1px solid #404040; border-right: 1px solid #404040; &#125; &#125; li:last-child a&#123; border-right: none; &#125;&#125; 逻辑很清楚，而且不需要写很多长长的类名来选择。可以直接写类名来使用调用其它的类所含有的样式。像第二点中的函数：.linear-gradient(top,#fe1f1f,#da1010);这是使用方法。传入参数，用类名来调用。不过混入远不止这么简单，这里只是皮毛，以后再认真看看。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"移动端","slug":"移动端","permalink":"http://weibo.com/biousco/tags/移动端/"}]},{"title":"JS-动画框架","slug":"JS-动画框架","date":"2015-02-02T14:24:31.000Z","updated":"2015-05-01T08:56:12.000Z","comments":true,"path":"2015/02/02/JS-动画框架/","link":"","permalink":"http://weibo.com/biousco/2015/02/02/JS-动画框架/","excerpt":"慕课网教程地址：JS动画效果 速度动画本门教程的基础。实现的是分享按钮的移出。首先要知道一个东西：定时器 HTML DOM setInterval() 方法定义和用法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。语法setInterval(code,millisec[,&quot;lang&quot;])–W3Cschool 网页中的JS就是不断的执行改变属性的函数，比如距离，透明度来达到动画的效果:timer = setInterval(function (){},30)后面的就是时间啦，每隔多少秒重复执行前面的（匿名）函数。用clearInterval(timer)来结束计时器。最基本的代码：1234567891011121314151617181920212223242526272829window.onload = function () &#123; var oDiv = document.getElementById('div1'); oDiv.onmouseover = function () &#123; startMove(0); &#125; oDiv.onmouseout = function () &#123; startMove(-200); &#125;&#125;var timer = null;function startMove (iTarget) &#123; clearInterval(timer); var oDiv = document.getElementById('div1'); timer = setInterval(function () &#123; var speed = 0; if (oDiv.offsetLeft &gt; iTarget) &#123; speed = -10; &#125;else&#123; speed = 10; &#125; if (oDiv.offsetLeft == iTarget) &#123; clearInterval(timer); &#125; else&#123; oDiv.style.left = oDiv.offsetLeft+speed+'px'; &#125; &#125;,30)&#125; 首先是鼠标一入一出的时候执行函数。 当函数的开头没有clearInterval(timer)时，每次移入DIV就会触发一次定时器：timer = setInterval()，旧的定时器还没关闭，新的定时器就开始工作了，就会造成叠加，速度就会不是匀速运动而是越来越快（鼠标放在上面越久） 下面的逻辑就通过对动画的分析能知道应该怎么写。","text":"慕课网教程地址：JS动画效果 速度动画本门教程的基础。实现的是分享按钮的移出。首先要知道一个东西：定时器 HTML DOM setInterval() 方法定义和用法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。语法setInterval(code,millisec[,&quot;lang&quot;])–W3Cschool 网页中的JS就是不断的执行改变属性的函数，比如距离，透明度来达到动画的效果:timer = setInterval(function (){},30)后面的就是时间啦，每隔多少秒重复执行前面的（匿名）函数。用clearInterval(timer)来结束计时器。最基本的代码：1234567891011121314151617181920212223242526272829window.onload = function () &#123; var oDiv = document.getElementById('div1'); oDiv.onmouseover = function () &#123; startMove(0); &#125; oDiv.onmouseout = function () &#123; startMove(-200); &#125;&#125;var timer = null;function startMove (iTarget) &#123; clearInterval(timer); var oDiv = document.getElementById('div1'); timer = setInterval(function () &#123; var speed = 0; if (oDiv.offsetLeft &gt; iTarget) &#123; speed = -10; &#125;else&#123; speed = 10; &#125; if (oDiv.offsetLeft == iTarget) &#123; clearInterval(timer); &#125; else&#123; oDiv.style.left = oDiv.offsetLeft+speed+'px'; &#125; &#125;,30)&#125; 首先是鼠标一入一出的时候执行函数。 当函数的开头没有clearInterval(timer)时，每次移入DIV就会触发一次定时器：timer = setInterval()，旧的定时器还没关闭，新的定时器就开始工作了，就会造成叠加，速度就会不是匀速运动而是越来越快（鼠标放在上面越久） 下面的逻辑就通过对动画的分析能知道应该怎么写。 obj.style.left和obj.offsetLeft的区别obj.style.left 返回的属性是String类型，obj.offsetLeft 返回的属性是int类型；此外offsetLeft是指：当前对象的外边框到它上层对象的内边框之间的距离 意思就是会包括padding border margin。后面使用的时候会有些不方便。这两个东西用的时候是这样的：obj.style.left = obj.offsetLeft + 10 + &#39;px&#39;;看，最后把他转化为字符串。 透明度动画12filter: alpha(opacity:30);opacity: 0.3; css里面写透明度是这样的。那么在JS里需要稍微处理一下：12obj.style.filter = 'alpha(opacity:'+obj.alpha+')';obj.style.opacity = obj.alpha/100; 另外由于JS没有像之前那样obj.offsetWidth这样的属性可以获取来比较当前透明度和目标透明度，所以可以先自定义一个透明度来进行比较。 缓冲动画123456var speedX = iTarget-oDiv.offsetLeft;var speed = (speedX)*(speedX)*0.001;if (speedX&lt;0) &#123; var speed = -speed;&#125;;speed = speed&gt;0?Math.ceil(speed):Math.floor(speed); 其实就是需要改变速度曲线啦~var speedX = iTarget-oDiv.offsetLeft;var speed = (speedX)*(speedX)*0.001;这是我自己尝试的一个函数，二次函数。教程中是用一次函数：var speed = (iTarget-oDiv.offsetLeft)/8显然教程的比较方便计算哈哈。不过实现的效果也是差不多，注意系数。另外我这个是二次函数，所以速度的正负需要处理。如果是一次函数就不需要。 然后为了避免小数点的产生（px没有小数），用两个函数：Math.ceil()和Math.floor()前面是向上取整，后面是向下取整。 而且这样写还有个好处，那就是当用整数时，如果没有刚刚好整除，达到相应的目标值时，会不停的抖抖抖抖。但是这样写会保证最后是1px慢慢加，一定可以达到目标值。 ##多物体运动1234567891011 var aLi = document.getElementsByTagName('li');for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].timer = null; aLi[i].alpha = 30; aLi[i].onmouseover = function () &#123; startMove(this,400); &#125; aLi[i].onmouseout = function () &#123; startMove(this,200); &#125;&#125;; 循环给每一个标签都绑定事件 给每一个标签都加上自己的定时器。避免用同一个定时器混淆动画。 绑定事件需要使用this表示给当前的标签执行动画。有点不太明白=。= 获取样式12345678function getStyle (obj,attr) &#123; if (obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj,false)[attr]; &#125;&#125; 自定义的一个函数，用于获取obj的CSS属性值。前者的currentStyle是给IE用的，后者的getComputedStyle(obj,false))是给FF用的。返回的属性值是String类型，需要用parseInt()转化为数字类型。这个是为了解决offsetWidth的一个好像是bug的bug。 任意属性值使代码更为通用，结合前面的getStyle()把运动函数修改一下：1234567891011121314151617181920212223function startMove (obj,attr,iTarget) &#123; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; var oattr = 0; if (attr == 'opacity') &#123; oattr = Math.round(parseFloat(getStyle(obj,attr))*100); &#125; else &#123; oattr = parseInt(getStyle(obj,attr)); &#125; var speed = (iTarget-oattr)/8; speed = speed &gt;0?Math.ceil(speed):Math.floor(speed); if (oattr == iTarget) &#123; clearInterval(obj.timer); &#125;else&#123; if ( attr == 'opacity') &#123; obj.style.filter = 'alpha(opacity:' + (oattr + speed) + ')'; obj.style.opacity = Math.round((oattr + speed)/100); &#125; else &#123; obj.style[attr] = oattr + speed + 'px'; &#125; &#125; &#125;,30);&#125; 增加传递的参数，属性值； 判断是否是透明度，然后使用getStyle()进行处理，还有有小数的时候使用Math.round()进行四舍五入； obj.style.attr 可以写成obj.style[attr]； 链式动画使用函数回调来实现（感觉好有逼格呀~）1function startMove (obj,attr,iTarget,fn) 123456if (oattr == iTarget) &#123; clearInterval(obj.timer); if (fn) &#123; fn(); &#125;; &#125; 改一下传递的参数； 使用的时候直接写匿名函数：1234567Li1.onmouseover = function () &#123; startMove(Li1,'width',400,function () &#123; startMove(Li1,'height',400,function () &#123; startMove(Li1,'opacity',100); &#125;) &#125;)&#125; 太棒啦！！ 同时运动涉及到JSON.12345var json = &#123;a:12,b:13&#125;;for(var i in json)&#123; //alert(i);//弹出的是name; alert(json[i]);&#125; 有点像数组，前面是name，后面是Key；12345678910111213141516171819202122232425262728293031function startMove (obj,json,fn) &#123; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; var flag = true; for(var attr in json)&#123; var oattr = 0; if (attr == 'opacity') &#123; oattr = Math.round(parseFloat(getStyle(obj,attr))*100); &#125; else &#123; oattr = parseInt(getStyle(obj,attr)); &#125; var speed = (json[attr]-oattr)/8; speed = speed &gt;0?Math.ceil(speed):Math.floor(speed); if (oattr != json[attr]) &#123; flag = false; if ( attr == 'opacity') &#123; obj.style.filter = 'alpha(opacity:' + (oattr + speed) + ')'; obj.style.opacity = (oattr + speed)/100; &#125; else &#123; obj.style[attr] = oattr + speed + 'px'; &#125; &#125; if (flag) &#123; clearInterval(obj.timer); if (fn) &#123; fn(); &#125;; &#125; &#125; &#125;,30)&#125; 传递JSON格式的内容，使用的时候像这样：startMove(Li1,{width:300,height:400,opacity:100}); 函数改变：遍历JSON，每个属性都进行动画。不过其实还是顺序执行啦~只是速度太快看不出来而已，微观上还是顺序执行，宏观上就是同时执行了。 为了避免某个属性完成目标而停止计时器，需要设置一个flag。当所有的动完都执行完毕后才开始停止计时器，再进行下一个函数。flag的位置要放好，视频中放错了。 小结嗯，学到不少知识呢。我要睡觉了.为什么MD用~~~~~会消失呢。好像也是默认字符之一。。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"},{"name":"慕课网","slug":"慕课网","permalink":"http://weibo.com/biousco/tags/慕课网/"}]},{"title":"前端练习-大讲堂(2)","slug":"前端练习-大讲堂-2","date":"2015-02-02T04:07:20.000Z","updated":"2015-05-01T08:55:55.000Z","comments":true,"path":"2015/02/02/前端练习-大讲堂-2/","link":"","permalink":"http://weibo.com/biousco/2015/02/02/前端练习-大讲堂-2/","excerpt":"中午了=。= 等爸爸回来吃饭~先写点东西。 全局定义清除浮动：在HTML里加上.clear-fix1234567891011.clear-fix:after&#123; content: \"\"; display: table; clear: both;&#125;.clear-fix &#123; *zoom: 1;&#125; 为了IE6/7/8兼容性，解决:after不支持的问题，加上zoom:1; 兼容IE6、IE7、IE8浏览器，经常会遇到一些问题，可以使用zoom:1来解决，有如下作用：触发IE浏览器的haslayout解决ie下的浮动，margin重叠等一些问题。 出处：CSS中zoom:1的作用 ，小标签大作用","text":"中午了=。= 等爸爸回来吃饭~先写点东西。 全局定义清除浮动：在HTML里加上.clear-fix1234567891011.clear-fix:after&#123; content: \"\"; display: table; clear: both;&#125;.clear-fix &#123; *zoom: 1;&#125; 为了IE6/7/8兼容性，解决:after不支持的问题，加上zoom:1; 兼容IE6、IE7、IE8浏览器，经常会遇到一些问题，可以使用zoom:1来解决，有如下作用：触发IE浏览器的haslayout解决ie下的浮动，margin重叠等一些问题。 出处：CSS中zoom:1的作用 ，小标签大作用这里又涉及到IE的haslayout属性： 什么是hasLayout？hasLayout是IE特有的一个属性。很多的ie下的css bug都与其息息相关。在ie中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。下列元素默认 hasLayout=true&lt;table&gt; &lt;td&gt; &lt;body&gt; &lt;img&gt; &lt;hr&gt; &lt;input&gt; &lt;select&gt;&lt;textarea&gt; &lt;button&gt; &lt;iframe&gt; &lt;embed&gt; &lt;object&gt; &lt;applet&gt; &lt;marquee&gt;很多情况下，我们把 hasLayout的状态改成true， 就可以解决很大部分ie下显示的bug。 hasLayout属性不能直接设定，你只能通过设定一些特定的css属性来触发并改变 hasLayout 状态。下面列出可以触发hasLayout的一些CSS属性值。 display启动haslayout的值:inline-block取消hasLayout的值:其他值 width/height启动hasLayout的值：除了auto以外的值取消hasLayout的值：auto position启动hasLayout的值：absolute取消hasLayout的值：static float启动hasLayout的值：left或right取消hasLayout的值：none zoom启动hasLayout的值：有值取消hasLayout的值：narmal或者空值（zoom是微软IE专有属性，可以触发hasLayout但不会影响页面的显示效果。zoom: 1常用来除错，不过 ie 5对这个属性不支持。） writing-mode: tb-rl 这也是微软专有的属性。 ie7还有一些额外的属性可以触发该属性（不完全列表）：min-height: (任何值)max-height: (任何值除了none)min-width: (任何值)max-width:(任何值除了none)overflow: (任何值除了visible)overflow-x: (任何值除了visible)overflow-y: (任何值除了visible)position: fixed因元素hasLayout而导致的问题其实一般都很容易发现：往往是内容出现错位甚至完全不可见。 一般如果是因为layout而引起的显示不符期望效果的话，在ff下会表现正常，而在ie下会出现错误。这个时候可以尝试触发父容器及其中的子容器的haslayout属性，通常可以通过加上zoom: 1;来调试。直到找到了产生问题的元素，再进行针对性的修正。最好的办法是对这个元素设置尺寸属性。但是，有时不便指定尺寸属性的情况下，就只能寻找替代方案了。对于ie7 ，最好的办法是设置最小高度属性为0；这个技术是无害的，因为0本来就是这个属性的初始值。而且没有必要对其他浏览器隐藏这个属性。而对于ie6和更早版本中触发一个元素hasLayout的方法是在overflow属性是visible的情况下设置这个元素的高度属性为1%，然后对其他浏览器隐藏这个设置。这种技术就是著名的Holly hack。 认识hasLayout——IE浏览器css bug的一大罪恶根源 一些兼容性后面再写。 banner背景图片那里使用了定位：background: url(../images/corner-to-start.png) no-repeat 100% 0%; 使用百分比定位图片的位置：第一个是水平位置，第二个是垂直位置，左上角是0%,0%,右下角是100%,100%；也可以用像素值。banner下面的一些像日程表的东西：用CSS画出来再放数据，不需要放图片。在解决border显示的问题时想用margin-right: -1px。可耻的失败了=。= 后来还是弱弱的定义了不同的宽度~~。重构的时候要带笔和纸算一下，设计图是多少就是多少，不然距离不对又要重新调一遍。 悬挂对齐图片里有一些是悬挂对齐，解决办法是设置margin-left和text-indent。注意在用的时候不要半角和全角一起用，统一好后一个字符就是1em了。向左悬挂3个字符就是margin-left: 3em; text-indent: -3em;另外还有空格距离：使用的属性是word-spacing，字母之间的距离：letter-spacing。 背景渐变1234background-color: #5CBA5C;background-image: -webkit-linear-gradient(bottom, #51A34F, #61C360);background-image: -moz-linear-gradient(bottom, #51A34F, #61C360);background-image: -ms-linear-gradient(bottom, #51A34F, #61C360); 就是这个，解决兼容性要写一些前缀。另外解决IE老版本的问题也定义一下背景颜色，不然就是空白了。基本的语法其实有很多。不过都大同小异。现在只用到简单的线性渐变，其实也可以做出很丰富的效果来哒。再说CSS3渐变——线性渐变 footer为了让一个块居中，记得定义宽度。。。。 兼容性调试工具可以用IE11的开发者工具，可以选择文档模式，有5 7 8 9。作业要求是7开始。不过刚开始是从Chrome开始测试：啊记不清了。好像是搜索框那里错位了。解决办法是定义好宽度。再向右浮动。IE9：一开始就错位了( ╯□╰ ) 解决办法都是定义好宽度和高度，把头部的高度都定义了一遍，然后就没什么问题了。IE8：错位的块定义宽度。有些是利用nth-child()选择器的就直接加个类改个CSS定义样式，也解决了。好像从这里开始原来的清除浮动不能用了，就给.clear-fix加上zoom:1;也解决了问题；另外CSS3的圆角阴影渐变什么的就开始不能显示出来。可以链接一些外部文件来解决这个问题。IE7：到现在还是有个问题：在头部右边的搜索栏的下拉菜单总是错位，而且上面的p标签和form标签多了好多距离，margin-top失效。百度了解决办法用了zoom;height:1%也不能解决。。。先放在这里了。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"前端练习-大讲堂(1)","slug":"前端练习-大讲堂-1","date":"2015-02-01T13:24:58.000Z","updated":"2015-05-01T08:56:24.000Z","comments":true,"path":"2015/02/01/前端练习-大讲堂-1/","link":"","permalink":"http://weibo.com/biousco/2015/02/01/前端练习-大讲堂-1/","excerpt":"本来参加的实习因为各种原因现在还没有设计图发下来= = 所以先打点其他的作业练手练手。大概用了两天的下午重构，以及一个多小时弄兼容性=。= 虽然最后IE7还是没解决好。先写下这些东西了。 设计图其实可以在网上找到原型的~给成长加点料-腾讯大讲堂只不过现在排版什么都更新了。重构后地址：DJT.QQ.COM HTML&amp;CSS&amp;JS这次尝试用了HTML5的标签，发现还有很多地方不熟悉。基本的标签有 header footer article section nav 嗯 这几个用的比较多。摘抄一些网上的经验： HTML对IE6/7/8的兼容 在JS中创造HTML5的标签：123456(function()&#123; var element=['header','footer','article','aside','section','nav','menu','hgroup','details','dialog','figure','figcaption']; for (var i = 0; i &lt; element.length; i++) &#123; document.createElement(element[i]); &#125;; &#125;)();","text":"本来参加的实习因为各种原因现在还没有设计图发下来= = 所以先打点其他的作业练手练手。大概用了两天的下午重构，以及一个多小时弄兼容性=。= 虽然最后IE7还是没解决好。先写下这些东西了。 设计图其实可以在网上找到原型的~给成长加点料-腾讯大讲堂只不过现在排版什么都更新了。重构后地址：DJT.QQ.COM HTML&amp;CSS&amp;JS这次尝试用了HTML5的标签，发现还有很多地方不熟悉。基本的标签有 header footer article section nav 嗯 这几个用的比较多。摘抄一些网上的经验： HTML对IE6/7/8的兼容 在JS中创造HTML5的标签：123456(function()&#123; var element=['header','footer','article','aside','section','nav','menu','hgroup','details','dialog','figure','figcaption']; for (var i = 0; i &lt; element.length; i++) &#123; document.createElement(element[i]); &#125;; &#125;)(); 顺便说一句，这是JS匿名函数的封装方法； 创建一个自调用匿名函数，设计参数window，并传入window对象。而这个过程的目的则是，使得自身的代码不会被其他代码污染，同时也可以不污染其他代码。 测试中发现这样写会自动调用，不用写window.onload = function (){}。百度了一下这种写法叫自执行的匿名函数。 什么是自执行的匿名函数?它是指形如这样的函数: (function {// code})(); 疑问为什么(function {// code})();可以被执行, 而function {// code}();却会报错? 分析(1). 首先, 要清楚两者的区别: (function {// code})是表达式, function {// code}是函数声明. (2). 其次, js”预编译”的特点: js在&quot;预编译&quot;阶段, 会解释函数声明, 但却会忽略表式. (3). 当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错; 当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行. 出处：JS自执行的匿名函数 有点扯远了。。接下来，是在CSS中声明这些新的标签为块级元素，默认是内联的：1header,section,nav,footer,article,aside&#123;display: block;&#125; 这样可以解决IE9以前浏览器不能识别HTML5标签的问题。 h1~h6标签 在一个网页中可以适当使用h1 h2 h3 h4标签，有利于网页的重点部分突出，同时也利于搜索引擎排名，但切记滥用多用H1 H2 H3 H4标签，适当使用即可，一切从用户体验出发来使用。如果需要控制这些标题标签的大小、背景、宽度、高度、CSS加粗与否都可以通过DIV CSS来实现对其样式重新定义。 使用CSS样式初始化H1 H2 H3 H4标签代码：H1,h2,h3,h4{font-size:12px; font-weight:normal}我们初始化了字体大小设置为12px，去除了H1 H2 H3 H4文字加粗样式。根据范例可扩展运用。 出处：HTML之h1 h2 h3 h4标签知识经验篇 二级菜单虽然之前学过视频的教程，可是自己真正打起来全忘光了=。= 错漏百出改了好久之后还是回去看了看教程的代码，修改后变成下面：1234567891011121314151617&lt;nav&gt; &lt;ul id=\"speech\" class=\"clear-fix\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;讲座&lt;/a&gt; &lt;img src=\"images/arrow1.png\" alt=\"\" id=\"arrow\"&gt; &lt;ul class=\"subul\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;我想买冬夏脉动啊冻干粉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;吱吱吱&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;我就是想测试一下&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;阅读&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;创意榜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;论坛&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.head-nav nav&#123; margin-top: 30px; font-size: 16px;&#125;#arrow&#123; visibility: hidden; margin-top: 16px; margin-right: 5px;&#125;.head-nav nav ul li&#123; margin-right: 30px; border-radius: 5px; text-align: center; position: relative; transition: all 0.3s ease-in-out;&#125;.head-nav nav ul li a&#123; float: left; padding: 10px;&#125;.subul&#123; visibility: hidden; position: absolute; left: -10px; top: 41px; border-radius: 5px; margin-left: 10px; opacity: 0; transition: all 0.3s ease-in-out;&#125;#speech .subul li&#123; display: block; margin: 0; float: none; border-radius: 0; background-color: #0169B0; text-align: left;&#125;#speech .subul a &#123; padding: 10px; width: 100px; display: block; float: none;&#125;#speech&gt;li:nth-child(2)&#123; border-radius: 5px 5px 0 0;&#125;#speech .subul li:first-child &#123; border-radius: 0 5px 0 0;&#125;#speech .subul li:last-child &#123; border-radius: 0 0 5px 5px;&#125;nav ul li:hover .subul,nav ul li:hover #arrow&#123; visibility: visible; opacity: 1;&#125; 卧槽有点不忍直视=。=简化掉一些hover和CSS3的选择器。一些选择器：#speech&gt;li:nth-child(2) #speech .subul li:first-child当然还有奇数和偶数的：#speech&gt;li:nth-child(odd)这是奇数，偶数是even，还有属性选择器：[class*=section1]{}记住中括号，还有，是先写。是指包含，^是指开头包含，$是指结尾包含，结尾包含必须加转义字符。[id $=\\-1]其实一级菜单的三角形小图标是可以用border属性画出来的（但是我太懒了），就用了图片。基本的HTML结构不会怎么变化，重要的是CSS。我决定要背下来了~一级菜单ul：清除浮动；一级菜单li：包裹&lt;a/&gt;标签，定义margin-right,text-align,position:relative,动画也加上。一级菜单 a：float: left; padding；二级菜单ul：重点呢… 确定好定位的距离。卧槽我这里可以不用margin-left和left的=。= 那就是确定这几个：visibility position top12345678visibility: hidden;position: absolute;left: -10px;top: 41px;border-radius: 5px;margin-left: 10px;opacity: 0;transition: all 0.3s ease-in-out; 二级菜单li：这里写的是display: block; /*不对啊li本来就是块级元素了*/float: none;二级菜单 a：设置padding width display:block; float:none; 先写这么多 睡觉(￣o￣) . z Z","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"CSS基础补充(1)","slug":"CSS基础补充-1","date":"2015-01-30T06:35:11.000Z","updated":"2015-05-01T08:57:37.000Z","comments":true,"path":"2015/01/30/CSS基础补充-1/","link":"","permalink":"http://weibo.com/biousco/2015/01/30/CSS基础补充-1/","excerpt":"在给别人讲解一些重构的内容的时候，发现自己还有好多基础没有补上=。= 平时都是打完页面就没有想太多东西，或者解决了问题没有总结。 于是乎看了一些文章，在这里记录一下。 盒子模型 内边距外边距不会遮挡后面的元素 在 CSS 中，width 和 height指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 外边距可以是负值，而且在很多情况下都要使用负值的外边距。 在文档流中，元素的最终边界是由margin决定的，margin为负的时候就相当于元素的边界向里收，文档流认的只是这个边界，不会管你实际的尺寸是多少。 margin百分比：相对于父元素 避免浏览器变小浮动乱跑：在所有盒子外面包裹一个container,确定宽度并使他居中 注意padding和width不要一起用。当设置width为100%的时候，会得到浏览器窗口的大小，但是padding却是另外计算的，所以会出现水平滚动条，多出来的padding撑出屏幕。","text":"在给别人讲解一些重构的内容的时候，发现自己还有好多基础没有补上=。= 平时都是打完页面就没有想太多东西，或者解决了问题没有总结。 于是乎看了一些文章，在这里记录一下。 盒子模型 内边距外边距不会遮挡后面的元素 在 CSS 中，width 和 height指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 外边距可以是负值，而且在很多情况下都要使用负值的外边距。 在文档流中，元素的最终边界是由margin决定的，margin为负的时候就相当于元素的边界向里收，文档流认的只是这个边界，不会管你实际的尺寸是多少。 margin百分比：相对于父元素 避免浏览器变小浮动乱跑：在所有盒子外面包裹一个container,确定宽度并使他居中 注意padding和width不要一起用。当设置width为100%的时候，会得到浏览器窗口的大小，但是padding却是另外计算的，所以会出现水平滚动条，多出来的padding撑出屏幕。 相对定位与绝对定位相对定位 当position设置为relative时，它们表示各个边界与原来位置的距离。当子块使用相对定位以后，它发生了偏移，即使移动到了父盒子的外面，父盒子也不会变大，就好像子盒子没有变化一样。 使用相对定位的盒子，会相对于它原本的位置，通过偏移指定的距离，到达新的位置。而该相对定位的盒子则仍然位于标准流中，它对父块, 兄弟子块没有任何影响。 绝对定位 对于绝对定位的描述为：使用绝对定位的盒子以它的“最近”的一个“已经定位”的“祖先元素”为基准进行偏移。如果没有已经定位的祖先元素，那么会以浏览器窗口为基准进行定位。再有，绝对定位的框从标准流中脱离，这意味着它们对其后的兄弟盒子的定位没有任何影响，其他的盒子就好像这个盒子不存在一样。 如果设置了绝对定位，而没有设置偏移属性，那么它仍然保持原有的位置。 用相对定位布局块级元素 仅使用margin属性布局相对定位元素的情况用margin-bottom属性和margin-top属性设置负值可以改变文档流中所占空间的高度，会影响文档流中的其它元素位置。 混合使用left、right、top和bottom属性与margin属性布局相对定位元素的情况此情况，它们的值会产生累加的效果。在CSS2.1中所有的浏览器都使用外边距边界来完成 偏移计算。从数学的角度理解为偏移属性值和外边距属性值累加。###用绝对定位布局块级元素 仅使用margin属性布局绝对定位元素的情况此情况，margin-bottom 和margin-right的值不再对文档流中的元素产生影响，因为该元素已经脱离了文档流。另外，不管它的祖先元素有没有定位，都是以文档流中原来所在的位置上偏移参照物。 总结： 1、相对定位的元素不会脱离文档流，占用文档流的空间，Left; Right; Top和Bottom属性与margin属性混合使用会产生累加效果。2、绝对定位的元素脱离文档流，偏移不影响文档流中的其它元素，Left; Right; Top和Bottom属性与margin属性混合使用，偏移方向相同值累加，方向相反margin属性值无效。3、绝对定位的元素以最近的定位祖先元素为参照物。 负外边距###负边距在普通文档流中的作用和效果在文档流中，元素的最终边界是由margin决定的，margin为负的时候就相当于元素的边界向里收，文档流认的只是这个边界，不会管你实际的尺寸是多少。 就是负的边距好像能减小元素在文档流中的尺寸一样，但事实上，它的尺寸大小并没变，只是文档流在计算元素位置的时候，会认为负边距把元素的尺寸减小了，因为位置也就发生变化了。 上和下的负边距对元素高度的影响:影响元素在文档流中的位置 左和右的负边距对元素宽度的影响:增加宽度 用处：12ul&#123; height:210px; overflow:hidden; margin-right:-20px;&#125;/*一个负的margin-right,相当于把ul的宽度增加了20px*/li&#123; height:100px; width:100px; background:#09F; float:left; margin-right:20px; margin-bottom:10px;&#125; 负边距对浮动元素的影响负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。就是某个元素虽然是写在了后面，但可以通过负边距让它在浏览器显示的时候是在前面的。这个以后可以再慢慢讲。 负边距对绝对定位元素的影响利用绝对定位来居中缺点：要知道居中元素的高度和宽度； 负margin在页面布局中的应用左右列固定，中间列自适应布局 下面代码示例。有点不太明白 去除列表右边框 在ul里面设置一个margin-right: -(length of border-right);，使列表向右移动一个border-right或者margin-right的距离，隐藏掉。 负边距+定位：水平垂直居中 确定所需内容的大小，例如为100*100,设置margin-top: -50px; margin-left: -50px，即设置为大小的一半，利用绝对定位，设置top: 50%; left: 50%;就能使定位点在屏幕中间，实现居中。 去除列表最后一个li元素的border-bottom 设置父元素overflow: hidden,在li里面添加margin-bottom: 1px 多列等高下面代码示例。 多列等高 等高布局有几种不同的方法，但目前为止我认为浏览器兼容最好最简便的应该是padding补偿法。首先把列的padding-bottom设为一个足够大的值，再把列的margin-bottom设一个与前面的padding-bottom的正值相抵消的负值，父容器设置超出隐藏，这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到它里面最高那列的高度，其他比这列矮的列则会用它们的padding-bottom来补偿这部分高度差。因为背景是可以用在padding占用的空间里的，而且边框也是跟随padding变化的，所以就成功的完成了一个障眼法。在这里，等高布局是为了维护边框线条的完整性，在有些地方则可能是为了维护背景的完整性，达到整体一致不缺失的效果。 代码参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body,p&#123;margin: 0;padding: 0;&#125; #wrap &#123; overflow: hidden; width: 580px; margin: 0 auto; &#125; .left,.center,.right&#123; margin-bottom: -500px; padding-bottom: 500px; &#125; .left &#123; float: left; width: 140px; background-color: #777; &#125; .center &#123; float: left; width: 300px; background-color: #888; &#125; .right &#123; float: right; width: 140px; background-color: #999; &#125; p &#123; color: #FFF; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;div class=\"left\"&gt; &lt;p style=\"height:10px\"&gt; bottom设为一个足够大的值，再把列的margin-bottom设一个与前面的padding-bottom的正值相抵消的负值，父容器设置超出隐藏，这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到它里面最高那列的高度，其他比这列矮的列则会用它们的padding-bottom来补偿这部分高度差。因为背景是可以用在padding占用的空间里的，而且边框也是跟随padding变化的，所以就成功的完成了一个障眼法。 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"center\"&gt; &lt;p style=\"height:100px\"&gt; bottom设为一个足够大的值，再把列的margin-bottom设一个与前面的padding-bottom的正值相抵消的负值，父容器设置超出隐藏，这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到它里面最高那列的高度，其他比这列矮的列则会用它们的padding-bottom来补偿这部分高度差。因为背景是可以用在padding占用的空间里的，而且边框也是跟随padding变化的，所以就成功的完成了一个障眼法。 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p style=\"height:300px\"&gt; bottom设为一个足够大的值，再把列的margin-bottom设一个与前面的padding-bottom的正值相抵消的负值，父容器设置超出隐藏，这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到它里面最高那列的高度，其他比这列矮的列则会用它们的padding-bottom来补偿这部分高度差。因为背景是可以用在padding占用的空间里的，而且边框也是跟随padding变化的，所以就成功的完成了一个障眼法。 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 左右列固定，中间列自适应布局 此例适用于左右栏宽度固定，中间栏宽度自适应的布局。由于网页的主体部分一般在中间，很多网页都需要中间列优先加载，而这种布局刚好满足此需求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; min-width: 600px; &#125; .main&#123; float: left; width: 100%; &#125; .mainbody &#123; margin: 0 210px; background-color: #888; height: 200px; &#125; .left,.right &#123; float: left; width: 200px; height: 200px; background: #F60; &#125; .left &#123; margin-left: -100%; &#125; .right&#123; margin-left: -200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"main\"&gt; &lt;div class=\"mainbody\"&gt; Main &lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 参考文章：CSS布局奇淫巧计之-强大的负边距负margin在页面布局中的应用多列等高应用CSS中的绝对定位与相对定位","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"}]},{"title":"下拉菜单(2)","slug":"下拉菜单-2","date":"2015-01-27T12:31:21.000Z","updated":"2015-05-01T08:58:49.000Z","comments":true,"path":"2015/01/27/下拉菜单-2/","link":"","permalink":"http://weibo.com/biousco/2015/01/27/下拉菜单-2/","excerpt":"你知道我这几天都在干嘛吗^_^今天下午买的手柄到了！！！好开熏。","text":"你知道我这几天都在干嘛吗^_^今天下午买的手柄到了！！！好开熏。 1. 带动画效果的下拉菜单js版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .top-nav&#123;font-size: 14px; font-weight: bold; list-style: none; &#125; .top-nav li &#123;float: left; margin-right: 1px; &#125; .top-nav li a&#123;line-height: 34px; text-decoration: none; background-color: #3f240e; color: #fff; display: block; width: 80px; text-align: center; &#125; /*二级菜单*/ .top-nav ul &#123;list-style: none; display: none; padding: 0; position: absolute; height: 0; overflow: hidden;&#125; .top-nav li a:hover &#123; background-color: #e54; &#125; .note &#123;background-color: #e54; display: block;&#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var Lis = document.getElementsByTagName(&apos;li&apos;); for (var i = 0; i &lt; Lis.length; i++) &#123; Lis[i].onmouseover = function () &#123; var u = this.getElementsByTagName(&apos;ul&apos;)[0]; if (u != undefined) &#123; u.style.display = &quot;block&quot;; ChangeH(u.id,1); &#125;; &#125; Lis[i].onmouseleave = function () &#123; var u = this.getElementsByTagName(&apos;ul&apos;)[0]; if (u != undefined) &#123; ChangeH(u.id,-1); &#125;; &#125; &#125;; &#125; function ChangeH (id,count) &#123; var ulList = document.getElementById(id); var h = ulList.offsetHeight; h += count; if (count &gt; 0) &#123; if (h &lt;= 34) &#123; ulList.style.height = h + &quot;px&quot;; setTimeout(&quot;ChangeH(&apos;&quot; + id + &quot;&apos;,1)&quot;,10); &#125; else &#123; return ; &#125; &#125; else &#123; if (h &gt; 0) &#123; ulList.style.height = h + &quot;px&quot;; setTimeout(&quot;ChangeH(&apos;&quot; + id + &quot;&apos;,-1)&quot;,10); &#125; else &#123; ulList.style.display = &quot;none&quot;; return ; &#125; &#125; &#125; // function AddH (id) &#123; // var ulList = document.getElementById(id); // var h = ulList.offsetHeight; // h += 1; // if (h&lt;=42) &#123; // ulList.style.height = h + &quot;px&quot;; // setTimeout(&quot;AddH(&apos;&quot; + id + &quot;&apos;)&quot;,10); // &#125; else &#123; // return; // &#125; // &#125; // function SubH (id) &#123; // var ulList = document.getElementById(id); // var h = ulList.offsetHeight; // h -= 1; // if (h &gt; 0) &#123; // ulList.style.height = h + &quot;px&quot;; // setTimeout(&quot;SubH(&apos;&quot; + id + &quot;&apos;)&quot;,10); // &#125; else &#123; // ulList.style.display = &quot;none&quot;; // return ; // &#125; // &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;top-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;span class=&quot;note&quot;&gt;首页&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;课程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;学习中心+&lt;/a&gt; &lt;ul id=&quot;munUL&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;前端+&lt;/a&gt;&lt;!-- &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;jquery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;手机+&lt;/a&gt;&lt;!-- &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;IOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;WP&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;ANDROID&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;后台&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;这是什么&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; jquery版123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;jquery-2.1.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function () &#123; $(&apos;.top-nav li&apos;).mousemove(function() &#123; $(this).find(&apos;ul&apos;).stop(true).slideDown(&apos;1000&apos;); &#125;); $(&apos;.top-nav li&apos;).stop(true,true).mouseleave(function() &#123; $(this).find(&apos;ul&apos;).stop(true).slideUp(&apos;1000&apos;); &#125;); &#125;); &lt;/script&gt; 对不起我就是这么懒哈哈哈从实际的效果来看，为了防止手贱一直去滑动那个菜单触发效果往动画栈里一直塞，需要添加一个.stop()函数来停止动画，当鼠标移走时清空动画栈。 高级一点的菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .navlist &#123; position: absolute; top: 10px; &#125; a &#123; text-decoration: none; color: #FFF; &#125; .navlist a &#123; margin-left: 60px; color: #666; &#125; .expand &#123; height: 0px; background-color: #333d4d; overflow: hidden; position: relative; top: 30px; width: 100%; &#125; .expdiv &#123; height: 130px; width: 500%; &#125; .expdiv-list &#123; width: 20%; text-align: center; float: left; line-height: 110px; color: #FFF; &#125; .expand .close-btn &#123; width: 120px; height: 20px; background: url(images/broswer_home.png) no-repeat -13px -117px; position: absolute; left: 50%; bottom: -2px; margin-left: -60px; cursor: pointer; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src = \"jquery-2.1.1.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('#menuList').on('click', 'a', function() &#123; if ($(this).hasClass('btn-active')) &#123; $('#expandZone #clostBtn').click(); return false; &#125;; var curIndex = $(this).index(),mlValue = \"-\" + curIndex * 100 + \"%\"; if ($(\"#expandZone\").hasClass('active')) &#123; $('#expandZone .expdiv').animate(&#123;marginLeft: mlValue&#125;); &#125; else &#123; $('#expandZone .expdiv').css(&#123;marginLeft: mlValue&#125;); $('#expandZone').animate(&#123;height: \"130px\"&#125;).addClass('active'); &#125; $(this).addClass('btn-active').siblings().removeClass('btn-active'); return false; &#125;); $(\"#expandZone #close-btn\").on('click', function() &#123; $(\"#expandZone\").animate(&#123;height: \"0px\"&#125;, function () &#123; $(this).removeClass('active'); $('#menuList .btn-active').removeClass('btn-active'); &#125;); return false; &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"menuList\" class=\"navlist\"&gt; &lt;a href=\"\"&gt;首页&lt;/a&gt; &lt;a href=\"\"&gt;课程大厅&lt;/a&gt; &lt;a href=\"\"&gt;学习中心&lt;/a&gt; &lt;a href=\"\"&gt;这是什么&lt;/a&gt; &lt;a href=\"\"&gt;关于我们&lt;/a&gt; &lt;/div&gt; &lt;div id=\"expandZone\" class=\"expand\"&gt; &lt;div class=\"expdiv\"&gt; &lt;div class=\"expdiv-list\"&gt; &lt;a href=\"\"&gt;幕客网主页&lt;/a&gt; &lt;/div&gt; &lt;div class=\"expdiv-list\"&gt; &lt;a href=\"\"&gt;前段克成&lt;/a&gt; &lt;a href=\"\"&gt;手机开发&lt;/a&gt; &lt;a href=\"\"&gt;后台变成&lt;/a&gt; &lt;/div&gt; &lt;div class=\"expdiv-list\"&gt; &lt;a href=\"\"&gt;JavaScript&lt;/a&gt; &lt;a href=\"\"&gt;CSS&lt;/a&gt; &lt;a href=\"\"&gt;Jquery&lt;/a&gt; &lt;/div&gt; &lt;div class=\"expdiv-list\"&gt; 个人信息： &lt;/div&gt; &lt;div class=\"expdiv-list\"&gt; 这是公司地址呀~！ &lt;/div&gt; &lt;/div&gt; &lt;div id=\"clostBtn\" class=\"close-btn\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 还有点小bug。让我慢慢改一下 响应式菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; margin: 0 auto; &#125; ul &#123; padding: 0; margin: 0; &#125; a &#123; text-decoration: none; color: #FFF; font-size: 14px; padding: 0 3px; display: block; &#125; .menu li &#123; display: block; float: left; margin: 3px; background: Gray; width: 140px; text-align: center; color: #FFF; font-size: 9pt; &#125; #logo &#123; background: white; width: 230px; &#125; #logo a &#123; color: Gray; font-size: 35pt; background: white; &#125; #toplogo &#123; display: none; margin: 0 auto; text-align: center; &#125; #toplogo a &#123; color: black; font-size: 35pt; &#125; .rMenu &#123; display: none; &#125; @media only screen and (min-width: 585px) and (max-width: 823px)&#123; #logo &#123; display: none; &#125; #toplogo &#123; display: block; width: 100%; &#125; .menu &#123; width: 585px; &#125; &#125; @media only screen and (max-width: 585px) &#123; #logo &#123; display: none; &#125; #toplogo &#123; display: block; &#125; .munu &#123; width: 100%; &#125; .menu li &#123; width: 100%; &#125; .rMenu &#123; display: block; text-align: right; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"menu\"&gt; &lt;div id=\"toplogo\"&gt; &lt;a href=\"\"&gt;木渴望&lt;/a&gt; &lt;a href=\"\" class=\"rMenu\"&gt; &lt;img src=\"icon.png\" alt=\"\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;li&gt;&lt;a href=\"\"&gt;课程大厅&lt;/a&gt;&lt;br&gt;IT课程在这里&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;学习中心&lt;/a&gt;&lt;br&gt;好好学习天天向上&lt;/li&gt; &lt;li id=\"logo\"&gt;&lt;a href=\"\"&gt;木刻万&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;个人中心&lt;/a&gt;&lt;br&gt;个人中心 修改密码&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于我们&lt;/a&gt;&lt;br&gt;单位地址 应聘信息&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 虽然很丑，真的很丑。但是让我入门了响应式设计。媒体查询Js什么的一起上。 CSS3菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .top-nav&#123; width: 960px; margin: 60px auto; border: 1px solid #222; background-color: #111; background-image: linear-gradient(#444,#111); border-radius: 6px; box-shadow: 0 1px 1px #777; padding: 0; list-style: none; &#125; .top-nav:before, .top-nav:after &#123; content: \"\"; display: table; &#125; .top-nav:after &#123; clear: both; &#125; .top-nav &#123; zoom: 1; &#125; .top-nav li &#123; float: left; border-right: 1px solid #222; box-shadow: 1px 0 0 #444; position: relative; &#125; .top-nav li a &#123; float: left; padding: 12px 30px; color: #999; font: bold 12px; text-decoration: none; text-shadow:0 1px 0 #000; &#125; .top-nav li a:hover &#123; color: #fafafa; &#125; .top-nav li ul &#123; visibility: hidden; position: absolute; list-style: none; top: 40px; left: 0; z-index: 1; padding: 0; background-color: #444; background-image: linear-gradient(#444,#111); box-shadow: 0 -1 0 rgba(255,255,255,0.3); border-radius: 3px; opacity: 0; margin: 20px 0 0 0 ; _margin: 0; transition: all 0.5s ease-in-out; &#125; .top-nav li:hover &gt; ul &#123; opacity: 1; visibility: visible; margin: 0; &#125; .top-nav ul li &#123; float: none; display: block; border: 0; box-shadow: 0 1px 0 #111,0 2px 0 #666; &#125; .top-nav ul a &#123; padding: 10px; width: 130px; display: block; float: none; _height: 10px; &#125; .top-nav ul a:hover &#123; background-color: #0186ba; background-image: linear-gradient(#04acec,#0186ba); &#125; .top-nav ul li:first-child &gt; a &#123; border-radius: 3px 3px 0 0; &#125; .top-nav ul li:last-child &gt; a &#123; border-radius: 0 0 3px 3px; &#125; .top-nav ul li:first-child &gt; a:before &#123; content: \"\"; position: absolute; left: 40px; top: -6px; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 6px solid #444; &#125; .top-nav ul li:first-child &gt; a:hover:before &#123; border-bottom-color: #04acec; &#125; .top-nav ul ul &#123; top: 0; left: 150px; margin: 0 0 0 20px; _margin:0; box-shadow: -1px 0 0 rgba(255,255,255,0.3); &#125; .top-nav ul ul li:first-child a:before &#123; left: -6px ; top: 50%; margin-top: -6px; border-left: 0; border-bottom: 6px solid transparent; border-top: 6px solid transparent; border-right: 6px solid #3b3b3b; &#125; .top-nav ul ul li:first-child a:hover:before &#123; border-right-color: #0299d3; border-bottom-color: transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"top-nav\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;span class=\"note\"&gt;首页&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;课程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;学习中心+&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;前端+&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jquery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;手机+&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;IOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;WP&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;ANDROID&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;后台&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;这是什么&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 这个最喜欢啦~入门CSS3看的这个。也很漂亮！","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"前端练习-Agentur(2)","slug":"前端练习-Agentur-2","date":"2015-01-27T12:25:08.000Z","updated":"2015-05-01T08:58:02.000Z","comments":true,"path":"2015/01/27/前端练习-Agentur-2/","link":"","permalink":"http://weibo.com/biousco/2015/01/27/前端练习-Agentur-2/","excerpt":"区块blockHTML1234567&lt;div class=&quot;block&quot;&gt; &lt;img src=&quot;images/schaefer.jpg&quot; alt=&quot;&quot; class=&quot;blimg&quot;&gt; &lt;div class=&quot;blcon&quot;&gt; &lt;p&gt;„Große Ideen haben eine unbändige Kraft. Bei Konzeption und Interface Design helfen wir, aus Ideen nachhaltige digitale Produkte zu entwickeln. Dabei stehen stets der User und die Zielsetzung im Mittelpunkt.“&lt;/p&gt; &lt;p class=&quot;author&quot;&gt;- Christoph Schäfer, Interface Design &amp; Web Development&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536.block&#123; width: 100%; background-color: #F0694B; height: 300px;&#125;.blimg &#123; margin-left: 16px; height: 300px; float: left;&#125;.blcon&#123; color: #FFF; float: left;/* width: 950px;*//* 加了宽度才能浮动到上面 */ padding: 45px 50px 50px 30px; font-size: 32px; line-height: 40px;/* 发现在这里设置margin到了比较窄的屏幕 文字会被挤下去 */ width: 855px;/* 来个固定的宽度就能解决问题啦 只是用Padding宽度会满屏 *//* 解决个毛线问题=。= */&#125;.block .author/* 是用这种方法来写好 还是加个div在里面？标签不用加class*/&#123; color: #F6C3C9; font-size: 15px; margin-top: 18px;&#125; 要说的都在注释里面了= =。一边打代码一遍写注释好欢乐的样子。","text":"区块blockHTML1234567&lt;div class=&quot;block&quot;&gt; &lt;img src=&quot;images/schaefer.jpg&quot; alt=&quot;&quot; class=&quot;blimg&quot;&gt; &lt;div class=&quot;blcon&quot;&gt; &lt;p&gt;„Große Ideen haben eine unbändige Kraft. Bei Konzeption und Interface Design helfen wir, aus Ideen nachhaltige digitale Produkte zu entwickeln. Dabei stehen stets der User und die Zielsetzung im Mittelpunkt.“&lt;/p&gt; &lt;p class=&quot;author&quot;&gt;- Christoph Schäfer, Interface Design &amp; Web Development&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536.block&#123; width: 100%; background-color: #F0694B; height: 300px;&#125;.blimg &#123; margin-left: 16px; height: 300px; float: left;&#125;.blcon&#123; color: #FFF; float: left;/* width: 950px;*//* 加了宽度才能浮动到上面 */ padding: 45px 50px 50px 30px; font-size: 32px; line-height: 40px;/* 发现在这里设置margin到了比较窄的屏幕 文字会被挤下去 */ width: 855px;/* 来个固定的宽度就能解决问题啦 只是用Padding宽度会满屏 *//* 解决个毛线问题=。= */&#125;.block .author/* 是用这种方法来写好 还是加个div在里面？标签不用加class*/&#123; color: #F6C3C9; font-size: 15px; margin-top: 18px;&#125; 要说的都在注释里面了= =。一边打代码一遍写注释好欢乐的样子。 小动画introimgHTML1234567891011121314151617181920212223&lt;div class=\"introimg\"&gt; &lt;div class=\"intro\"&gt; &lt;div class=\"imgcon\"&gt; &lt;img src=\"images/ag-01.svg\" alt=\"\"&gt; &lt;/div&gt; &lt;h3&gt;Concept&lt;/h3&gt; &lt;p&gt;Zuhören, das Problem verstehen und eine Lösung zur Erreichung des Ziels erarbeiten.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"intro line\"&gt; &lt;div class=\"imgcon\"&gt; &lt;img src=\"images/ag-02.svg\" alt=\"\"&gt; &lt;/div&gt; &lt;h3&gt;Design&lt;/h3&gt; &lt;p&gt;Ein Interface Design entwickeln, das Botschaft und Anwender zusammenführt.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"intro\"&gt; &lt;div class=\"imgcon\"&gt; &lt;img src=\"images/ag-03.svg\" alt=\"\"&gt; &lt;/div&gt; &lt;h3&gt;Code&lt;/h3&gt; &lt;p&gt;Zeile für Zeile soliden Code schreiben, der auf allen Endgeräten funktioniert.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 令人激动的。。好吧现在看起来也不激动了。知道了小动画怎么做没了新鲜感。 CSS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.introimg&#123; padding: 40px 100px 110px 100px;&#125;.intro &#123; float: left; width: 33%; height: 305px;&#125;.intro:hover img &#123; height: 100px; width: 100px; transition: all 0.3s ease-in-out;&#125;/* 直接这样写会有浮动 所以决定先用一个div包起来固定大小*/.imgcon&#123; height: 101px; width: 100px; margin: 0 auto; padding: 3px 0;&#125;/* 还是没有那种从中心散开放大的效果 =。= */.intro img &#123; display: block;/* 增加了这个属性才会居中 */ margin: 0 auto; height: 95px;&#125;.intro h3,.intro p &#123; text-align: center; margin-top: 30px; padding: 0 30px;&#125;.intro h3 &#123; font-weight: bold;&#125;.intro p &#123; color: #B7BFBC;&#125;.line &#123; border-left: 1px dashed #F0694B; border-right: 1px dashed #F0694B;/* ff中左边的比较少虚线 右边的比较多 其实左边就是虚线dash 右边的是点dotted*/ &#125;.introimg:after&#123; content: &apos;&apos;; display: table; clear: both;&#125;/* 妈妈我终于用上这个啦！清除浮动 */ 这里有点小长。 div取消高度 发现在这里影响的是两边虚线的长度。 img那里希望能把图片放到父级div的中心，鼠标移到那里的时候有从中心放到的效果，但是设置了Padding好像还是不行，亏我高度多给了1Px… font-weight: bold; 好像没效果，去掉。 清除浮动用一次就记住啦~ 人物介绍introHTML123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"content-wrap team\"&gt; &lt;div class=\"content\"&gt; &lt;h2&gt;Unser Team&lt;/h2&gt; &lt;p&gt;Der Herzschlag von helllicht ist das Team. Hier arbeiten Spezialisten mit absoluter Motivation für die große Sache. Jeden Einzelnen von uns zeichnet dabei nicht nur die Leidenschaft für digitale Medien aus, sondern auch ein umfassendes Wissen in den entsprechenden Disziplinen. &lt;/p&gt; &lt;p&gt;Sollte uns Inhouse das nötige Knowhow einmal fehlen, arbeiten wir mit freien Experten oder anderen Agenturen zusammen. Innerhalb unserer Kernkompetenzen setzen wir aber natürlich auf ein Team von festangestellten Mitarbeitern.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;div class=\"people-wrap team\"&gt; &lt;div class=\"people\"&gt; &lt;div class=\"sub\"&gt; &lt;img src=\"images/goschin.jpg\" alt=\"\"&gt; &lt;h4&gt;NICOLAL GOSCHIN&lt;/h4&gt; &lt;p class=\"post\"&gt;Projektleitung &amp; Konzeption&lt;/p&gt; &lt;p&gt;06152 / 98760-82 • &lt;span&gt;&lt;a href=\"#\"&gt;E-Mail schreiben&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"sub\"&gt; &lt;img src=\"images/schaefer.jpg\" alt=\"\"&gt; &lt;h4&gt;Christoph Schäfer&lt;/h4&gt; &lt;p class=\"post\"&gt;Interface Design &amp; Web Development&lt;/p&gt; &lt;p&gt;06152 / 98760-83 • &lt;span&gt;&lt;a href=\"#\"&gt;E-Mail schreiben&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"sub\"&gt; &lt;img src=\"images/wacker.jpg\" alt=\"\"&gt; &lt;h4&gt;Florian Wacker&lt;/h4&gt; &lt;p class=\"post\"&gt;Interface-Design &amp; Web Development&lt;/p&gt; &lt;/div&gt; &lt;div class=\"sub\"&gt; &lt;img src=\"images/koch.jpg\" alt=\"\"&gt; &lt;h4&gt;Anne Koch&lt;/h4&gt; &lt;p class=\"post\"&gt;Information-Design &amp; Web Development&lt;/p&gt; &lt;/div&gt; &lt;div class=\"sub\"&gt; &lt;img src=\"images/dingeldein.jpg\" alt=\"\"&gt; &lt;h4&gt;Sabine Dingeldein&lt;/h4&gt; &lt;p class=\"post\"&gt;Content-Strategie &amp; Redaktion&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172.team &#123; background-color: #F0F0F0;/* 是要把所有的bg属性都写好还是如果只有背景色就只用这个bgc? */&#125;.people-wrap&#123; padding: 0 250px 50px 310px;&#125;.people &#123;/* padding: 50px 0 100px 0;*/&#125;.people:after&#123; content: ''; display: table; clear: both;&#125;.sub &#123; float: left; width: 300px; height: 400px; background-color: #fff; margin-right: 40px; margin-bottom: 45px;/* box-shadow: 1px 1px 3px;*/ border-bottom: 2px solid #E0E0E0; padding: 25px;/* 尽量使用盒模型来控制边距 不要用图片来设置p m感觉会比较好*/ text-align: center; line-height: 0.9;/* 发现会有奇怪的高度 应该是这个属性 */&#125;.sub img &#123; height: 300px;&#125;.sub h4&#123; margin-top: 25px;&#125;.sub .post&#123; color: #7D6686; font-size: 13px; margin-top: 15px;&#125;.sub p &#123; margin-top: 18px;&#125;.sub a&#123; color: #F0694B; font-weight: bold;&#125;/* 发现一个问题： 设置的wrap没有设置Padding-bottom时，前面底部显示出来的距离其实是P设置了margin-bottom 卧槽这怎么能忍 解决办法：设置padding-bottom 大小和margin一样*/ 怎么又写了这么多= = 有很多写一个选择器却只是用来设置盒子的内外边距感觉非常不好。应该有更好的方式。 原来我在做的时候有发现一些奇怪的问题。。这里就涉及到盒子的相互啥来着。。内外边距合并！ 底部footerHTML123456789101112131415&lt;div class=\"footer\"&gt; &lt;div class=\"copyright\"&gt; &lt;p&gt;© 2015 helllicht medien GmbH&lt;/p&gt; &lt;/div&gt; &lt;div class=\"website\"&gt; &lt;a href=\"#\"&gt;Neue Themenseite &lt;span&gt;onepager.de&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"list\"&gt; &lt;li&gt;&lt;a href=\"#\" class=\"hoverani\"&gt;Presse&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"hoverani\"&gt;Jobs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"hoverani\"&gt;Impressum&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"hoverani\"&gt;Datenschutz&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"hoverani\"&gt;Kontakt&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.footer&#123; padding: 35px 120px; background-color: #464D57;&#125;.copyright,.website&#123; float: left; color: #FFF;/* 这样写还是不能变成一行的排列 oh 妈蛋 不知道问题了 */ display: inline; font-size: 13px;&#125;.website&#123; margin-left: 30px;&#125;.website span&#123; color: #F7CA18; font-weight: bold;&#125;.list &#123; float: right; list-style: none;&#125;.footer .list li &#123; float: left; margin-left: 16px; font-size: 13px;&#125;/*.list li a&#123; transition: all 0.3s ease-in-out; &#125;*//* 感觉这样写有点蛋疼= =*/.list li a:hover&#123; color: #F17357;&#125;/* 这里可以代码重用喔。。。 */ 忘了加上清除浮动。然后好像就没啥了不过要吐槽一下，CSS里面太多样式是只写了一行设置距离的，感觉太冗余，应该有更好的办法。 ## 小结一下好这篇文章先到这里，下一篇写JS方面的。其实学到挺多东西的，最后出来的效果和案例差不多，字体没有换掉所以看起来怪怪的。已经放到新浪的SAE了，准备以后都把自己写的网站都放到那里哈哈。这次的地址是：Agentur-biousco。源地址是：等我回宿舍再更新一下，电脑的无线网卡好像坏了QAQ，能连上wifi但是过几秒钟就断掉了=。==。=。=","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"前端练习-Agentur(1)","slug":"前端练习-Agentur-1","date":"2015-01-27T10:29:29.000Z","updated":"2015-05-01T08:58:09.000Z","comments":true,"path":"2015/01/27/前端练习-Agentur-1/","link":"","permalink":"http://weibo.com/biousco/2015/01/27/前端练习-Agentur-1/","excerpt":"HTML&amp;CSSCSS初始化123456* &#123;margin: 0; padding: 0; &#125;a &#123;color: #FFF; text-decoration: none; &#125;::selection &#123;background: #F0694B; color: #FFF;&#125;::-moz-selection &#123;background: #F0694B; color: #FFF;&#125;/*.content::selection &#123;color: #FFF;&#125;.content::-moz-selection &#123;color: #FFF;&#125;*/ 啊这个自带的代码高亮好丑啊~刚开始没有在意用了*，现在改过来。body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p{padding:0; margin:0;}嗯，改成这样。然后是超链接的样式，去掉下划线，改变颜色。接下来是新学到的东西：元素状态伪类::selection: {attibute} 然后刚好用的是FF,刚开始怎么也没有效果，加上-moz-.","text":"HTML&amp;CSSCSS初始化123456* &#123;margin: 0; padding: 0; &#125;a &#123;color: #FFF; text-decoration: none; &#125;::selection &#123;background: #F0694B; color: #FFF;&#125;::-moz-selection &#123;background: #F0694B; color: #FFF;&#125;/*.content::selection &#123;color: #FFF;&#125;.content::-moz-selection &#123;color: #FFF;&#125;*/ 啊这个自带的代码高亮好丑啊~刚开始没有在意用了*，现在改过来。body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p{padding:0; margin:0;}嗯，改成这样。然后是超链接的样式，去掉下划线，改变颜色。接下来是新学到的东西：元素状态伪类::selection: {attibute} 然后刚好用的是FF,刚开始怎么也没有效果，加上-moz-. 头部headerHTML123456789101112131415161718 &lt;div class=\"header\" id=\"header\"&gt; &lt;div class=\"logo\"&gt; &lt;a href=\"#\"&gt;helllicht medien&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;AGENTUR&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;KOMPETENZEN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;PROZESS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;PROJEKTE&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;BLOG&lt;/a&gt;&lt;/li&gt; &lt;li class=\"contaktli\"&gt; &lt;a class=\"contakt\" href=\"#\"&gt;KONTAKT&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;!-- &lt;div class=\"contakt\"&gt; &lt;a href=\"#\"&gt;KONTAKT&lt;/a&gt; &lt;/div&gt; --&gt; &lt;!-- 这里放了出来却不知道怎么排版 --&gt; &lt;/div&gt; 通过看样例的图片，发现最右边的一个子项和前面的不太一样，有不同的hover样式，有外边框，左外边距也不同。所以刚开始的想法是把这个独立出来，但是后来写样式的时候发现有问题，写起来麻烦了很多。又发现实际上一整个菜单栏都是在一个水平线上的，于是把KONTAKT这个按钮写进li里面，在往a里添加一个class。 CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586.header &#123; width: 100%; height: 75px; background-color: #656B74; position: fixed; top: 0; opacity: 0.9; transition: all 0.3s ease-in-out;&#125;.logo &#123; float: left; font-size: 20px; line-height: 20px; padding: 30px 0 0 30px; transition: all 0.3s ease-in-out;&#125;/*又是这样= = 当有a标签的时候写动画好死鬼麻烦 */.logo a&#123; transition: all 0.3s ease-in-out; &#125;.logo a:hover&#123; color: #CED3DB;&#125;.menu &#123; float: right;&#125;.menu li &#123; float: left; display: block;/* height: 75px;*//* 写了高度又写padding容易混乱*/ margin-left: 25px; padding: 35px 0 0; font-size: 14px; transition: all 0.3s ease-in-out;&#125;.menu li a&#123; transition: all 0.3s ease-in-out; &#125;/* 感觉这样写有点蛋疼= =*/.menu li a:hover&#123; color: #F17357;&#125;.menu .contaktli &#123; padding: 0;/* 如何避免为了更高的优先级写这些东西呢。。。*/&#125;.contakt &#123; display: block; margin: 23px 25px 9px 0 ; padding: 10px 20px; border: 2px solid #FFF; transition: all 0.4s ease-in-out;/* 要计算好距离 包括Padding和border */&#125;.contakt:hover&#123; color: #F2694B; background-color: #FFF; border: 2px solid #FFF;&#125;/* 这里发现写出来挺冗余的而且也实现不了效果 决定换html */.contakt a:hover:&#123; color: #F2694B;&#125; 现在一看写的好多，而且很多是只有一句的=。=。直接改了： 先改Hover相关的样式： 在有Hover的a标签那里直接定义一个类好了，不用每次都要单独写一遍：类名定义为hoverani，给需要的HTML加上，css里面写.hoverani{transition: all 0.3s ease-in-out;}蛋疼的问题解决了。后面也是这么改。 按钮那里感觉好败笔啊。觉得如果把全部设置成固定的大小就没这么多事了= = 不需要改padding和margin算得苦逼苦逼的。可是现在该Js就要重新写一下。先放在这里吧。另外发现在li里的属性：display:{block;}可以去掉列表的圆点。还是在开头定义吧。大图bannerHTML123456&lt;div class=\"banner-wrap\"&gt; &lt;div class=\"banner\"&gt; &lt;p&gt;MIT LEIDENSCHAFT FOR DIGITALE MEDIEN&lt;/p&gt; &lt;h1&gt;helllicht ist eine Agentur, spezialisiert auf Interface Design und Web Development.&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516171819202122232425262728293031323334353637.banner-wrap&#123; background-color: #656B74; padding: 160px 290px 180px 290px;&#125;.banner&#123; width: 100%; /* 设置Padding值使该div撑出屏幕了 *//* 解决办法：在外面套一个wrap设置Padding 内容div再设置成width：100% 不要一起设置 不同浏览器会有问题 */&#125;.banner p &#123; display: block; width: 260px; background-color: #000; color: #FFF; font-size: 10px; padding: 5px; margin: 0 auto; text-align: center;&#125;.banner h1&#123; display: block; color: #FFF; text-align: center; margin-top: 40px; font-size: 35px;/* 添加了宽度后不能居中 */&#125; 在这里终于知道了之前提到过的wrap的含义。对一个div来说，不要直接设置宽度和padding值。引用一篇博文：Afar的专栏-关于width与padding 首先谈谈!important问题的引起（盒模型问题）: 在CSS标准中，一个盒模型包括4个区，分别是：内容、内边距（padding）、边框（border）和外边距（margin）。而Width宽度的计算，CSS有它的标准。但是实际上，不同的浏览器的表现却不同。比如， Firefox（FF）是准确按照CSS标准：width为内容的宽度，也就是说： 层的宽度 = width + padding(left and right) + border-width； 而IE则把width作为整个层的宽度： 内容的宽度 = width - padding - border-width； IE的这种解析，被认为是一个BUG。但事实上，这种解释也不无道理，人们在设计页面的时候关注得更多的是盒子的大小，而不是内容的大小。正是因为浏览器的不同解析，给CSS的设计带来一些困难。 针对这个问题，我们经常使用!important来区分Firefox和IE6.0： 程序代码: #content { width: 414px !important; width: 400px; padding: 5px; border-width: 2px; } Firefox识别!important，而IE不识别，且!important的width优先级高，因此FF理解为width: 400px，IE6.0理解为width: 414px，从而显示就相同了。 但是问题出在IE7，IE7.0对!important有了识别能力，但是对盒模型的解析却和IE6.0等一样，从而造成很大的麻烦。也就是说，!important的方法在IE7.0下变得不适用了。 而一般的情况下，border的使用相对较少的，并且border-width一般较小，因此最主要的问题就出在padding上了。网上很多人总结的经验是：padding要尽量少用，能用margin的，就别用padding。这种说法是消极的，问题的解决不应该总是回避。 盒模型问题的解决： 仔细想想，其实问题就出在“width与padding/border-width的同时定义”上。而明白了这一点，解决的方法就不难想到了，只要添加一个无width定义的wrapper层，把原来的一个content层拆分成2个层，在wrapper中定义padding和border-width，然后在content中定义width： 程序代码: .wrapper { padding: 5px; border-width: 2px; } .content { margin: 0px; width: 400px; } 程序代码: … 这样问题就可以得到解决，FF，IE6.0以及IE7.0都会获得相同的显示效果。更重要的是，没有使用任何CSS hack。 这种解决方法可以说是最终的方案，使用CSS hack的方法只是目前过渡阶段的临时方法。 对于网站构造，特别是对于样式比较复杂的网站，个人建议在重要的层快外加上wrapper层。但是对于目前现成的模板，可以有选择修改部分样式，或者使用其他方法。 是否适合所有的浏览器？ 理论上，这种方法应该适用于各种浏览器。 但是本人认为除非大型网站，兼容FF，IE6.0，IE7.0已经足够，这里也是主要针对这三个最主流的浏览器，IE更低版本，以及其他浏览器上的可行性有待验证 总而言之，就是用wrap和content来一起用啦~不过问题远远没有我想的那么简单= =当把浏览器缩小的时候，我的心灵受到了伤害。好！做响应式布局！然后看看案例是怎么写的。。。另外p h1是块级元素。。。 主内容contentHTML123456789&lt;div class=\"content-wrap\"&gt; &lt;div class=\"content\"&gt; &lt;h2&gt;helllicht führt digitale Projekte zum Erfolg – und das bereits seit vielen Jahren&lt;/h2&gt; &lt;p&gt;Wir sind davon überzeugt, dass Usability der ausschlaggebende Faktor für den Erfolg von digitalen Projekten ist. Mit unserem Gespür für relevante Details sowie dem Blick fürs große Ganze wissen wir, worauf es ankommt und sind mit absoluter Leidenschaft bei der Sache. &lt;/p&gt; &lt;p&gt;Für unsere Auftraggeber aus Industrie, Mittelstand und der Kreativbranche konzipieren und realisieren wir Onepager, Corporate Websites sowie Online-Magazine. Dabei unterstützen wir unsere Kunden über den gesamten Prozess als Berater und schaffen so die Grundlage für richtige und nachhaltige Entscheidungen. &lt;/p&gt; &lt;p class=\"emp\"&gt;Von der Idee bis zum Roll-Out&lt;/p&gt; &lt;p&gt;Unsere Lösungen zeichnen sich durch messbare Ergebnisse aus, die langfristig den Wertschöpfungsprozess unserer Auftraggeber unterstützen. Für das perfekte Ergebnis begleiten wir sie von der ersten Idee bis zum finalen Roll-Out.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 嗯。不要在意我用的是什么语言。这篇文章有点小长~ css1234567891011121314151617181920212223.content-wrap&#123; padding: 120px 320px 55px;&#125;.content h2 &#123; font-size: 33px; margin-bottom: 55px;&#125;.content p &#123; margin-bottom: 55px; line-height: 32px; color: #454545;&#125;.content .emp &#123; color: #F0694B; margin-bottom: 20px;&#125; 这次终于好像没什么好说的了！除了窗口过小排版会很恶心之外。。然后后面的内容用相同的类也可以渲染了。发现个小东西：在.wrap ，.content 和 p 中，p本身设置了margin-bottom。但是它的父元素.content的高度大小不包括这个margin。而.content的父元素.wrap的高度大小却包括了p的margin-bottom。花插这是什么情况!?待我百度一下。。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"http://weibo.com/biousco/tags/JS/"}]},{"title":"下拉菜单","slug":"下拉菜单","date":"2015-01-16T10:32:59.000Z","updated":"2015-05-01T08:58:16.000Z","comments":true,"path":"2015/01/16/下拉菜单/","link":"","permalink":"http://weibo.com/biousco/2015/01/16/下拉菜单/","excerpt":"最近几天在看慕课网上的前端视频。主要是下拉菜单的制作。先把代码贴上去，以后慢慢总结(考试周伤不起啊~~(那你还去看前端…)) 贴几个经典的吧： 1. 最普通的下拉菜单1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;nav&lt;/title&gt; &lt;style&gt; * &#123;margin: 0; padding: 0; &#125; div &#123;width: 960px; height: 40px; margin: 0 auto; background-color: #eee;&#125; ul &#123;list-style: none; &#125; ul li &#123;position: relative; float: left; line-height: 40px; text-align: center; &#125; a &#123;display: block; text-decoration: none; color: #000; padding: 0 10px; height: 40px; &#125; a:hover &#123;color: #fff; background-color: #000;&#125; ul li ul li &#123;float: none; background-color: #eee; margin-top: 2px;&#125; ul li ul &#123;position: absolute; left: 0; top: 40px; display: none;&#125; ul li ul li a&#123; width:80px;&#125; ul li ul li a:hover &#123;background-color: #06F;&#125; ul li:hover ul&#123;display: block;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;课堂大厅&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;视频学习&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;案例学习&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;学习中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;经典案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","text":"最近几天在看慕课网上的前端视频。主要是下拉菜单的制作。先把代码贴上去，以后慢慢总结(考试周伤不起啊~~(那你还去看前端…)) 贴几个经典的吧： 1. 最普通的下拉菜单1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;nav&lt;/title&gt; &lt;style&gt; * &#123;margin: 0; padding: 0; &#125; div &#123;width: 960px; height: 40px; margin: 0 auto; background-color: #eee;&#125; ul &#123;list-style: none; &#125; ul li &#123;position: relative; float: left; line-height: 40px; text-align: center; &#125; a &#123;display: block; text-decoration: none; color: #000; padding: 0 10px; height: 40px; &#125; a:hover &#123;color: #fff; background-color: #000;&#125; ul li ul li &#123;float: none; background-color: #eee; margin-top: 2px;&#125; ul li ul &#123;position: absolute; left: 0; top: 40px; display: none;&#125; ul li ul li a&#123; width:80px;&#125; ul li ul li a:hover &#123;background-color: #06F;&#125; ul li:hover ul&#123;display: block;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;课堂大厅&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;视频学习&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;案例学习&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;学习中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;经典案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 下拉菜单的变种1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;nav&lt;/title&gt; &lt;style&gt; * &#123;margin: 0; padding: 0; &#125; div &#123;width: 960px; height: 40px; margin: 0 auto; background-color: #eee; border-bottom: 10px solid #E25; overflow: auto;&#125; ul &#123;list-style: none; &#125; ul li &#123;float: left; line-height: 40px; text-align: center; &#125; a &#123;display: block; text-decoration: none; color: #000; width: 120px;&#125; /*这里加了Height会出错*/ a:hover &#123;color: #fff; &#125; li a span &#123;display: none;&#125; li a:hover span&#123;display: block; background-color: #E25; &#125; li a:hover &#123;margin-top: -40px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;span&gt;Home&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;课堂大厅&lt;span&gt;Course&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;学习中心&lt;span&gt;Center&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;经典案例&lt;span&gt;Case&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;关于我们&lt;span&gt;About&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3. 三级菜单的JS实现（兼容IE6）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123;margin: 0; padding: 0; &#125; #nav &#123;width: 960px; height: 40px; margin: 0 auto; &#125; ul &#123;list-style: none; &#125; ul li &#123;float: left; line-height: 40px; text-align: center; &#125; a &#123;display: block; text-decoration: none; color: #000; width: 120px; background-color: #eee;&#125; a:hover &#123;color: #fff;background-color: #E25;&#125; /*二级菜单*/ #nav li ul&#123;display: none; position: relative;width: 80px;&#125; /*三级菜单*/ #nav li ul li ul &#123;position: absolute; top: 0; left: 120px; width: 80px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; // var isIE = !!window.ActiveXObject; // var isIE6 = isIE &amp;&amp; !window.XMLHttpRequest; // if (isIE6) &#123; var Lis = document.getElementsByTagName('li'); for (var i = 0; i &lt; Lis.length; i++) &#123; Lis[i].onmouseover = function () &#123; var u = this.getElementsByTagName('ul')[0]; if (u != undefined) &#123; u.style.display = \"block\"; &#125;; &#125; Lis[i].onmouseout = function () &#123; var u = this.getElementsByTagName('ul')[0]; if (u != undefined) &#123; u.style.display = \"none\"; &#125;; &#125; &#125;; // &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"nav\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;课程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;学习中心+&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;前端+&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jquery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;手机&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;IOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;WP&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;ANDROID&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;后台&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;这是什么&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 好吧我又给自己挖了好多坑了…让我想想怎样把代码的效果放在这篇文章中。。","categories":[{"name":"前端","slug":"前端","permalink":"http://weibo.com/biousco/categories/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://weibo.com/biousco/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://weibo.com/biousco/tags/CSS/"}]},{"title":"Thinkphp学习笔记(2)","slug":"Thinkphp学习笔记-2","date":"2015-01-08T13:40:01.000Z","updated":"2015-05-01T08:58:21.000Z","comments":true,"path":"2015/01/08/Thinkphp学习笔记-2/","link":"","permalink":"http://weibo.com/biousco/2015/01/08/Thinkphp学习笔记-2/","excerpt":"3.主页作品展示模块 foreach不能直接修改数组的内容，如果要修改使用(引用传递)： 1foreach ($list as $key =&gt; &amp;$value) html文件内容只需要写一个li就可以了，使用&lt;volist name=&quot;&quot; id=&quot;&quot; &gt;&lt;/volist&gt;来调用后台数据。 如果html文件是用&lt;ul&gt;&lt;li&gt;来展示图片，&lt;volist&gt;标签要放到&lt;ul&gt;后&lt;li&gt;前;如果是div布局，放在div前。分页数字使用$page. 把逻辑代码都整合到Model中，在控制器中调用。如果需要重复的代码，用A方法实例化控制器，再调用控制器的方法。当需要不同的参数时再设置传入的变量，还可以设置变量的默认值。 4.作品详情模块 html中修改链接的地址：1__URL__/buying?id=$vo.id 使用get方法把作品的唯一id传递到控制器中。 注意不要混淆登陆信息与作品信息。当对一个一维数组进行foreach时可能造成乱码 按照相同原理进行数据的读取，赋值，渲染。","text":"3.主页作品展示模块 foreach不能直接修改数组的内容，如果要修改使用(引用传递)： 1foreach ($list as $key =&gt; &amp;$value) html文件内容只需要写一个li就可以了，使用&lt;volist name=&quot;&quot; id=&quot;&quot; &gt;&lt;/volist&gt;来调用后台数据。 如果html文件是用&lt;ul&gt;&lt;li&gt;来展示图片，&lt;volist&gt;标签要放到&lt;ul&gt;后&lt;li&gt;前;如果是div布局，放在div前。分页数字使用$page. 把逻辑代码都整合到Model中，在控制器中调用。如果需要重复的代码，用A方法实例化控制器，再调用控制器的方法。当需要不同的参数时再设置传入的变量，还可以设置变量的默认值。 4.作品详情模块 html中修改链接的地址：1__URL__/buying?id=$vo.id 使用get方法把作品的唯一id传递到控制器中。 注意不要混淆登陆信息与作品信息。当对一个一维数组进行foreach时可能造成乱码 按照相同原理进行数据的读取，赋值，渲染。 5.众筹模块 添加商品： 数据表：添加字段存储众筹的id号码，用@分隔； php中：使用两个函数：array explode(string separator,string string,[int limit])来分隔字符串： 1$array = explode(\"@\", $userinfo['geeid']); 使用bool in_array( mixed needle,array array[,bool strict]) 来在数组中搜索某个值： 1in_array($id, $array); 6.上传头像 吸取教训，不要把存储的文件路径以及文件名分开（又或者在其他场景中有好处？） 对文件夹进行分类，使用上传类的属性确保业务逻辑的最佳。","categories":[{"name":"知识积累","slug":"知识积累","permalink":"http://weibo.com/biousco/categories/知识积累/"}],"tags":[{"name":"Thinkphp","slug":"Thinkphp","permalink":"http://weibo.com/biousco/tags/Thinkphp/"},{"name":"Gee!Jee!","slug":"Gee-Jee","permalink":"http://weibo.com/biousco/tags/Gee-Jee/"}]},{"title":"Git基础总结","slug":"Git基础总结","date":"2015-01-07T05:18:11.000Z","updated":"2015-05-01T08:58:25.000Z","comments":true,"path":"2015/01/07/Git基础总结/","link":"","permalink":"http://weibo.com/biousco/2015/01/07/Git基础总结/","excerpt":"教程地址 初始化 在现存的目录下，导入所有文件来创建新的 Git 仓库$ git init初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。如果要开始添加：$ git add *.c $ git add README $ git commit -m &#39;initial project version&#39; 已有的 Git 仓库克隆出一个新的镜像仓库$ git clone git://github.com/schacon/grit.git","text":"教程地址 初始化 在现存的目录下，导入所有文件来创建新的 Git 仓库$ git init初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。如果要开始添加：$ git add *.c $ git add README $ git commit -m &#39;initial project version&#39; 已有的 Git 仓库克隆出一个新的镜像仓库$ git clone git://github.com/schacon/grit.git 记录更新 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 2-1 所示。 检查当前文件状态要确定哪些文件当前处于什么状态，可以用 git status 命令。$ git status # On branch master nothing to commit (working directory clean)未跟踪：untracked (当新建一个新的README时，查看状态发现是untracked，说明未跟踪) 跟踪新文件$ git add README 只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。） 暂存已修改文件修改文件时，查看状态可以发现“Changed but not updated”。这时候就需要运行git add 命令（根据目标文件的状态不同，此命令的效果不同：跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）如果此时再修改文件，需要再次运行git add保存最新的文件。 忽略某些文件.gitignore 的文件内容说明了忽略的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 查看已暂存和未暂存的更新git diff 会使用文件补丁的格式显示具体添加和删除的行。 提交更新提交前先确认status。提交命令：$ git commit。这种方式会启动文本编辑器以便输入本次提交的说明。也可以直接加参数提交： git commit -m &quot;Story 182: Fix benchmarks for speed&quot; 提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域$ git commit -a 省去$ git add的步骤，一步提交。 查看提交历史git log 撤消操作 修改最后一次提交撤消刚才的提交操作，可以使用 --amend 选项重新提交:$ git commit --amend123$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend 上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。 取消已经暂存的文件查看文件状态的时候就提示了该如何撤消。使用 git reset HEAD ... 的方式取消暂存。 取消对文件的修改$ git checkout -- benchmarks.rb 这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过 来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍 的 stashing 和分支来处理，应该会更好些。记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。","categories":[{"name":"知识积累","slug":"知识积累","permalink":"http://weibo.com/biousco/categories/知识积累/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://weibo.com/biousco/tags/Github/"},{"name":"Git","slug":"Git","permalink":"http://weibo.com/biousco/tags/Git/"}]},{"title":"Pacman使用说明","slug":"pacman使用说明","date":"2015-01-06T14:10:02.000Z","updated":"2015-05-01T08:58:45.000Z","comments":true,"path":"2015/01/06/pacman使用说明/","link":"","permalink":"http://weibo.com/biousco/2015/01/06/pacman使用说明/","excerpt":"PacmanPacman is a flat and responsive design theme for Hexo. Demo || Alimon’s Blog 中文说明请访问这里","text":"PacmanPacman is a flat and responsive design theme for Hexo. Demo || Alimon’s Blog 中文说明请访问这里 ##Installation ###Install1$ git clone https://github.com/A-limon/pacman.git themes/pacman Pacman requires Hexo 2.4.5 and above. ###EnableModify theme setting in blog folder_config.yml to pacman. ###Update12cd themes/pacmangit pull please backup your _config.yml file before update. ##Configuration Modify settings in /themes/pacman/_config.yml. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091##### Menumenu: Home: / Archives: /archives## you can create `tags` and `categories` folders in `../source`.## And create a `index.md` file in each of them.## set `front-matter`as## layout: tags (or categories)## title: tags (or categories)## ---#### Widgetswidgets: - category- tag- rss## provide six widgets:category,tag,rss,archive,tagcloud,links.## modify links in `/layout/_widget/links.ejs`.#### RSSrss: ## RSS address.#### Imageimglogo: enable: true ## display image logo true/false. src: img/logo.svg ## `.svg` and `.png` are recommended,please put image into the theme folder `/pacman/source/img`.favicon: img/favicon.ico ## size:16px*16px,`.ico` is recommended,please put image into the theme folder `/pacman/source/img`. apple_icon: img/pacman.jpg ## size:64px*64px,please put image into the theme folder `/pacman/source/img`.#### Author Avatar Pictureauthor_img_enable: true ## display author avatar picturedataURI: false## if the picture&apos;s format is dataURI please set the value to true,otherwise set the value to false.## convert an image into base 64 data URIs http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/ .author_img_data: &apos;&apos;## paste the dataURI in ONE LINE and included it by &apos;&apos;.author_img: img/author.jpg ## size:220px*220px.## if the picture&apos;s format is `.png` or `.jpg` instead of dataURI,you should set the `dataURI` value to false.#### FontShowCustomFont: true ## you can change custom font in `variable.styl` and `font.styl` which in the theme folder `/pacman/source/css`.#### Toctoc: article: true ## show contents in article. aside: true ## show contents in aside.## you can set both of the value to true of neither of them.## if you don&apos;t want display contents in a specified post,you can modify `front-matter` and add `toc: false`.#### Fancyboxfancybox: false ## if you use gallery post or want use fancybox please set the value to true.## if you want use fancybox in ANY post please copy the file `fancybox.js`.## in theme folder `/pacman/scripts` to your hexo blog folder `../scritps`.#### Author informationauthor: google_plus: ## eg:116338260303228776998 for https://plus.google.com/u/0/116338260303228776998 intro_line1: &quot;&quot; ## eg: &quot;Hello ,I&apos;m Larry Page in Google.&quot; intro_line2: &quot;&quot; ## eg: &quot;This is my blog,believe it or not.&quot; weibo: ## e.g. 436062867 for http://weibo.com/436062867 twitter: ## e.g. yangjiansky for https://twitter.com/yangjiansky github: ## e.g. A-limon for https://github.com/A-limon facebook: ## e.g. yangjian for https://favebook.com/yangjian tsina: ## e.g. 1664838973 Your weibo ID,It will be used in share button.#### Commentduoshuo: enable: false ## duoshuo.com short_name: ## duoshuo short name.#### Share buttonjiathis: enable: false ## if you use jiathis as your share tool,the built-in share tool won&apos;t be display. id: ## e.g. 1501277 your jiathis ID. tsina: ## e.g. 1664838973 Your weibo id,It will be used in share button.#### Analyticsgoogle_analytics: enable: false id: ## e.g. UA-1766729-8 your google analytics ID. site: ## e.g. yangjian.me your google analytics site or set the value as auto.## You MUST upgrade to Universal Analytics first!## https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN#### Custom Searchgoogle_cse: enable: false cx: ## e.g. 000561263943549425496:mrzrm0gr4kg your Custom Search ID.## https://www.google.com/cse/","categories":[{"name":"知识积累","slug":"知识积累","permalink":"http://weibo.com/biousco/categories/知识积累/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://weibo.com/biousco/tags/hexo/"},{"name":"Pacman","slug":"Pacman","permalink":"http://weibo.com/biousco/tags/Pacman/"}]},{"title":"Thinkphp学习笔记","slug":"Thinkphp学习笔记","date":"2015-01-06T04:33:35.000Z","updated":"2015-05-01T08:58:33.000Z","comments":true,"path":"2015/01/06/Thinkphp学习笔记/","link":"","permalink":"http://weibo.com/biousco/2015/01/06/Thinkphp学习笔记/","excerpt":"大二上学期开始学习网站建设的知识，参加了校内的一个社团。刚开始学习的是HTML/CSS，关注重构方面，后期是PHP，后台方面。11月左右开始组队参加内部比赛，1个月后进行展示。因为某种不(mei)可(you)抗(ren)拒(yao)的原因，最后和一个大一的设计师组队。我负责前端和后台。作品最后拿了一等奖，我拿了最佳研发。接下来几天慢慢把当时做这个作品的各种坑写在这里。噢，最后的作品名是Gee!Jee!,目标是做一个众筹网站。","text":"大二上学期开始学习网站建设的知识，参加了校内的一个社团。刚开始学习的是HTML/CSS，关注重构方面，后期是PHP，后台方面。11月左右开始组队参加内部比赛，1个月后进行展示。因为某种不(mei)可(you)抗(ren)拒(yao)的原因，最后和一个大一的设计师组队。我负责前端和后台。作品最后拿了一等奖，我拿了最佳研发。接下来几天慢慢把当时做这个作品的各种坑写在这里。噢，最后的作品名是Gee!Jee!,目标是做一个众筹网站。 后台准备工作交接前端重构完成后，和框架结合时需要做一些改动： 把html文件放入view文件夹，把css/js/images/文件夹及其内容放进根目录下的PUBLIC文件夹。 修改html文件内容： 修改css/js/images路径：添加PUBLIC/ 修改各个超链接的路径：URL/控制器中操作名(一般为链接网页名)[确保都是放在一个模块下,否则URL/模块名/操作名]之后就是开始写后台啦： 写控制器/模型模块 用户注册登陆模块 作品上传模块 主页作品展示模块 作品详情模块 众筹模块 上传头像模块 分页模块 作者展示模块 分析上面这些是当时敲代码时写的，现在看来发现当时做的好乱。。接下来慢慢看模块当时的写法吧。 1.用户注册登陆模块 注册模块： 多用var_dump()查看错误信息； 非法数据对象：是否用了post，表单是否有name属性，是否有错，自动验证是否有错 页面跳转：查看url是否有错，$this-&gt;success(‘登陆成功！’,’index2’,2),直接填写方法名 查询出错：查看语法，使用数组传递条件：12$condition['email'] = $email;$result = $User-&gt;where($condition)-&gt;find(); 当使用select()方法时会返回多个数据集。使用：$result[0][‘id’]; 登陆模块： 用户头像：使用模型的函数记得用D方法，正确处理图像的路径。 检测是否登陆：session。根据是否登陆改变的html内容在控制器中赋值，Thinkphp会自动转义字符。 默认用户头像：在数据表中设置好默认的路径 全局session：封装成函数，每次都调用。应该有更好的办法。 2. 作品上传模块 $info[&#39;file1&#39;][&#39;savepath&#39;]单独取出存储到数据库时使用该语法； 不知道如何调用数组时var_dump来查看数组组成。 文件上传模块可以和数据上传模块一起使用，测试过程良好~一路顺畅。","categories":[{"name":"知识积累","slug":"知识积累","permalink":"http://weibo.com/biousco/categories/知识积累/"}],"tags":[{"name":"Thinkphp","slug":"Thinkphp","permalink":"http://weibo.com/biousco/tags/Thinkphp/"},{"name":"Gee!Jee!","slug":"Gee-Jee","permalink":"http://weibo.com/biousco/tags/Gee-Jee/"}]},{"title":"那些搭建Hexo的事儿~","slug":"那些搭建Hexo的事儿","date":"2015-01-04T23:41:41.000Z","updated":"2015-01-16T11:06:01.000Z","comments":true,"path":"2015/01/05/那些搭建Hexo的事儿/","link":"","permalink":"http://weibo.com/biousco/2015/01/05/那些搭建Hexo的事儿/","excerpt":"","text":"Hexo优化修改原生内置的谷歌字体和jquery：由于某些众所周知的原因，ajax.googleapis.com和fonts.googleapis.com不能访问，导致加载博客会非常慢（观察浏览器的请求链接可以发现），所以都要替换掉。字体文件位于：hexo/themes/modernist/source/css_base/variable.styl,修改下面这句： https://fonts.googleapis.com/css?family=Droid+Serif:400italic,700italic,400,700 把googleapis换成useso。 jquery文件位于：hexo/themes/~/layout/_partial/after_footer.ejs,修改下面这句： &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js&quot;&gt;&lt;/script&gt; 换成国内的CDN： &lt;script src=&quot;//lib.sinaapp.com/js/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; 不过我当时好像是用百度提供的。 主题与插件这个其实没啥好说的~有很详细的中文/英文文档，一步步做下来都能成功。不过目前没太多精力去优化了。嗯，等我考完试再说。 GitHub和Gitcafe会想用到Gitcafe是因为第一次部署好后发现访问很慢，所以想迁移到国内服务比较好的Gitcafe（其实感觉差不多，因为之前没有做上面的优化=。=）。不过用一个新的Git花了不少时间。 注册帐号，注意密码 新建的项目要和用户名一样，项目的设置中发现教程里有默认分支可以设置为page服务，但是实际操作发现没有。查看了文档才发现是要自己创建一个gitcafe-page分支。 按照教程创建新的SSH密钥。因为在linux系统中我找不到那个文文件夹在哪里（我跪了），所以用命令行的方式来打开，然后发现我不知道命令=。=gedit gitcafe.pub好像是这样哈哈，可以用图形画的界面打开来复制粘贴了（心好累）不过也可以用vi gitcafe.pub，上课学到的。然后balabala全部设置好后就可以用Gitcafe的服务了。 GitCafe常用命令： $ git status 查看状态 $ git commit -m “commit message” 提交最后一次修改 $ git push &lt;remote&gt; &lt;branch&gt; 上传代码好吧我目前就用到这么多=。= 把要提交的文件全部丢到那个仓库里面，然后执行commit和push就好了。记得要用gitcafe-page的分支$ git checkout -b gitcafe-pages 然后登陆***.gitcafe.io就可以看了。 Hexo部署刚开始太年轻，以为只要一个$ hexo d就可以部署了。弄了好几遍发现还是原来的页面。百度后才知道要先$ hexo generate，生成静态页面，再放上服务器。放上服务器后问题又来了，页面的CSS简直崩掉。又百度了一下（其实在linux下我都是用bing的），要先把hexo/public/css/下的style.css删除，再generate一下，才能正确生成静态页面。不知道这是不是bug=。=","categories":[{"name":"知识积累","slug":"知识积累","permalink":"http://weibo.com/biousco/categories/知识积累/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://weibo.com/biousco/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://weibo.com/biousco/tags/Github/"}]}]}