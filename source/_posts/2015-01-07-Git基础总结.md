title: Git基础总结
date: 2015-01-07 13:18:11
categories: 知识积累
tags: [Git,Github]
description: 第一次用Git心好累。
---

[教程地址][1]

## 初始化
* 在现存的目录下，导入所有文件来创建新的 Git 仓库
`$ git init`初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。如果要开始添加：
`$ git add *.c` `$ git add README` `$ git commit -m 'initial project version'`
* 已有的 Git 仓库克隆出一个新的镜像仓库
`$ git clone git://github.com/schacon/grit.git`

<!-- more -->

## 记录更新

> 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。
在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 2-1 所示。
![此处输入图片的描述][3]
> 

* 检查当前文件状态
要确定哪些文件当前处于什么状态，可以用 git status 命令。
`$ git status # On branch master nothing to commit (working directory clean)`
未跟踪：untracked (当新建一个新的README时，查看状态发现是untracked，说明未跟踪)
* 跟踪新文件
`$ git add README`

> 只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）

* 暂存已修改文件
修改文件时，查看状态可以发现“Changed but not updated”。这时候就需要运行`git add` 命令（根据目标文件的状态不同，此命令的效果不同：跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）
如果此时再修改文件，需要再次运行`git add`保存最新的文件。

* 忽略某些文件
.gitignore 的文件内容说明了忽略的文件。

> 文件 .gitignore 的格式规范如下：
* 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。
* 可以使用标准的 glob 模式匹配。 * 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 * 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。

* 查看已暂存和未暂存的更新
`git diff` 会使用文件补丁的格式显示具体添加和删除的行。

* 提交更新
提交前先确认status。
提交命令：`$ git commit`。这种方式会启动文本编辑器以便输入本次提交的说明。
也可以直接加参数提交： `git commit -m "Story 182: Fix benchmarks for speed"`

> 提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。

* 跳过使用暂存区域
`$ git commit -a` 省去`$ git add`的步骤，一步提交。

## 查看提交历史
`git log`

## 撤消操作
* 修改最后一次提交
撤消刚才的提交操作，可以使用 `--amend` 选项重新提交:`$ git commit --amend`
```
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```
上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。

* 取消已经暂存的文件
查看文件状态的时候就提示了该如何撤消。
使用 `git reset HEAD ...` 的方式取消暂存。

* 取消对文件的修改
`$ git checkout -- benchmarks.rb`

> 这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过 来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍 的 stashing 和分支来处理，应该会更好些。
记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 --amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。


  [1]: http://www.open-open.com/lib/view/open1328069733264.html
  [2]: http://www.open-open.com/lib/view/open1328069733264.html
  [3]: http://7u2ex0.com1.z0.glb.clouddn.com/20150107a.png?attname=&e=1420692735&token=8g0L21s5iHv9Y05CDLV5LZlpN2_AtWSVDBNLwYiM:W4C9Y2YuB7WWyUEF4pItPIe6lcg
